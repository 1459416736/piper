{"version":3,"sources":["webpack:///webpack/bootstrap c7e17ba4f7ba134d1a93","webpack:///external \"lodash\"","webpack:///./node_modules/Sequelize/lib/utils.js","webpack:///./node_modules/Sequelize/lib/data-types.js","webpack:///./node_modules/Sequelize/lib/errors.js","webpack:///./node_modules/Sequelize/lib/promise.js","webpack:///./node_modules/babel-runtime/regenerator/index.js","webpack:///./server/models/index.js","webpack:///external \"util\"","webpack:///./node_modules/Sequelize/lib/associations/base.js","webpack:///./node_modules/Sequelize/lib/query-types.js","webpack:///external \"path\"","webpack:///./node_modules/Sequelize/lib/utils/inherits.js","webpack:///./node_modules/Sequelize/lib/associations/belongs-to.js","webpack:///./node_modules/Sequelize/lib/associations/has-many.js","webpack:///external \"semver\"","webpack:///external \"dotenv\"","webpack:///./node_modules/Sequelize/lib/utils/validator-extras.js","webpack:///external \"moment\"","webpack:///external \"moment-timezone\"","webpack:///./node_modules/Sequelize/lib/associations/helpers.js","webpack:///./node_modules/Sequelize/lib/transaction.js","webpack:///./node_modules/Sequelize/lib/associations/belongs-to-many.js","webpack:///./node_modules/Sequelize/lib/dialects/abstract/index.js","webpack:///./node_modules/Sequelize/lib/dialects/abstract/connection-manager.js","webpack:///./node_modules/Sequelize/lib/dialects/parserStore.js","webpack:///./node_modules/Sequelize/lib/dialects/abstract/query.js","webpack:///./node_modules/Sequelize/lib/dialects/abstract/query-generator.js","webpack:///external \"fs\"","webpack:///./node_modules/Sequelize/lib/dialects/postgres/hstore.js","webpack:///./node_modules/Sequelize/lib/sql-string.js","webpack:///external \"uuid\"","webpack:///./node_modules/Sequelize/lib/associations/has-one.js","webpack:///external \"dottie\"","webpack:///external \"koa-router\"","webpack:///external \"wkx\"","webpack:///./node_modules/Sequelize/lib/model.js","webpack:///./node_modules/Sequelize/lib/hooks.js","webpack:///external \"tedious\"","webpack:///./node_modules/Sequelize/lib/dialects/mysql/query-generator.js","webpack:///./server/lib/publish/index.js","webpack:///./server/controllers/page.js","webpack:///./server/constants.js","webpack:///external \"koa-passport\"","webpack:///./server/index.js","webpack:///external \"koa\"","webpack:///external \"nuxt\"","webpack:///./server/lib/api.js","webpack:///external \"regenerator-runtime\"","webpack:///./server/controllers/changelogs.js","webpack:///./node_modules/Sequelize/index.js","webpack:///./node_modules/Sequelize/lib/sequelize.js","webpack:///external \"url\"","webpack:///external \"retry-as-promised\"","webpack:///external \"cls-bluebird\"","webpack:///external \"terraformer-wkt-parser\"","webpack:///./node_modules/Sequelize/lib/errors/index.js","webpack:///external \"validator\"","webpack:///./node_modules/Sequelize/lib/dialects/postgres/data-types.js","webpack:///external \"pg-hstore\"","webpack:///./node_modules/Sequelize/lib/dialects/postgres/range.js","webpack:///./node_modules/Sequelize/lib/dialects/mysql/data-types.js","webpack:///./node_modules/Sequelize/lib/dialects/sqlite/data-types.js","webpack:///./node_modules/Sequelize/lib/dialects/mssql/data-types.js","webpack:///./node_modules/Sequelize/lib/utils/parameter-validator.js","webpack:///./node_modules/Sequelize/lib/utils/logger.js","webpack:///external \"depd\"","webpack:///external \"debug\"","webpack:///external \"bluebird\"","webpack:///external \"inflection\"","webpack:///./node_modules/Sequelize/lib/instance-validator.js","webpack:///./node_modules/Sequelize/lib/associations/mixin.js","webpack:///external \"assert\"","webpack:///./node_modules/Sequelize/lib/deferrable.js","webpack:///./node_modules/Sequelize/lib/model-manager.js","webpack:///external \"toposort-class\"","webpack:///./node_modules/Sequelize/lib/query-interface.js","webpack:///./node_modules/Sequelize/lib/dialects/sqlite/query-interface.js","webpack:///./node_modules/Sequelize/lib/dialects/mssql/query-interface.js","webpack:///./node_modules/Sequelize/lib/dialects/mysql/query-interface.js","webpack:///./node_modules/Sequelize/lib/associations/index.js","webpack:///./node_modules/Sequelize/lib/dialects/mssql/index.js","webpack:///./node_modules/Sequelize/lib/dialects/mssql/connection-manager.js","webpack:///external \"generic-pool\"","webpack:///external \"timers\"","webpack:///./node_modules/Sequelize/lib/dialects/mssql/resource-lock.js","webpack:///./node_modules/Sequelize/lib/dialects/mssql","webpack:///./node_modules/Sequelize/lib/dialects/mssql/query.js","webpack:///./node_modules/Sequelize/lib/dialects/mssql/query-generator.js","webpack:///external \"crypto\"","webpack:///./node_modules/Sequelize/lib/dialects/mysql/index.js","webpack:///./node_modules/Sequelize/lib/dialects/mysql/connection-manager.js","webpack:///./node_modules/Sequelize/lib/dialects/mysql","webpack:///external \"mysql2\"","webpack:///./node_modules/Sequelize/lib/dialects/mysql/query.js","webpack:///./node_modules/Sequelize/lib/dialects/postgres/index.js","webpack:///./node_modules/Sequelize/lib/dialects/postgres/connection-manager.js","webpack:///./node_modules/Sequelize/lib/dialects/postgres","webpack:///external \"pg\"","webpack:///./node_modules/Sequelize/lib/dialects/postgres/query.js","webpack:///./node_modules/Sequelize/lib/dialects/postgres/query-generator.js","webpack:///./node_modules/Sequelize/lib/dialects/sqlite/index.js","webpack:///./node_modules/Sequelize/lib/dialects/sqlite/connection-manager.js","webpack:///./node_modules/Sequelize/lib/dialects/sqlite","webpack:///external \"sqlite3\"","webpack:///./node_modules/Sequelize/lib/dialects/sqlite/query.js","webpack:///./node_modules/Sequelize/lib/dialects/sqlite/query-generator.js","webpack:///./node_modules/Sequelize/lib","webpack:///./node_modules/Sequelize/package.json","webpack:///./server/models/db.js","webpack:///./server/models/changelog.js","webpack:///./server/models/pages.js","webpack:///./server/models/users.js","webpack:///./server/controllers/count.js","webpack:///./server/controllers/files.js","webpack:///external \"async-busboy\"","webpack:///./server/lib/publish/qiniu.js","webpack:///external \"qiniu\"","webpack:///./server/controllers/pages.js","webpack:///./server/controllers/publish.js","webpack:///external \"mkdirp\"","webpack:///external \"webshot\"","webpack:///./server/controllers/users.js","webpack:///external \"koa-session\"","webpack:///external \"koa-bodyparser\"","webpack:///./server/lib/passport.js","webpack:///external \"passport-github\"","webpack:///./nuxt.config.js"],"names":["require","config","env","dbConfig","params","Object","assign","underscored","dialectOptions","ssl","define","timestamps","createdAt","updatedAt","logging","sequelize","url","database","username","password","db","forEach","md","model","name","keys","modelName","associate","Sequelize","ctx","id","models","pages","update","is_delete","where","changelog","create","action","page_id","items","create_by","state","user","body","message","findAll","result","page","status","JSON","parse","request","change","count","reduce","title","trim","stringify","length","__","VALUE_MAX_LENGTH","VALUE_TOO_LONG","attributes","changed","app","host","process","HOST","port","PORT","use","passport","initialize","session","router","get","authenticate","successRedirect","failureRedirect","routes","apiRoute","Promise","resolve","reject","res","on","nuxt","render","req","promise","then","catch","dev","builder","build","console","error","e","exit","sync","listen","log","err","Error","apiRouter","prefix","klass","controller","method","logout","query","size","parseInt","start","limit","$like","findAndCountAll","include","users","offset","order","total","data","rows","DATABASE_DIALECT","DATABASE_STORAGE","DATABASE_HOST","DATABASE_PORT","DATABASE_NAME","DATABASE_USER","DATABASE_PASSWORD","DATABASE_URL","base","DataTypes","type","INTEGER","allowNull","primaryKey","autoIncrement","defaultValue","STRING","tableName","belongsTo","foreignKey","cover","is_publish","publish_at","DATE","NOW","hasOne","email","github_id","avatar","fn","literal","asyncBusboy","files","fields","upload","uploadRes","_","qiniu","QINIU_ACCESS_KEY","QINIU_SECRET_KEY","QINIU_BUCKET","QINIU_BASEURL","conf","ACCESS_KEY","SECRET_KEY","getUptoken","key","isEmpty","putPolicy","rs","PutPolicy","token","uptoken","localFile","extra","io","PutExtra","putFile","ret","hash","tasks","map","file","path","all","isPublish","findOrCreate","defaults","created","item","protocol","put","Date","now","dir","fs","existsSync","mkdirp","shotUrl","options","screenSize","width","height","shotSize","userAgent","webshot","createReadStream","coverRes","serializeUser","done","deserializeUser","findById","GitHubStrategy","Strategy","clientID","GITHUB_CLIENT_ID","clientSecret","GITHUB_CLIENT_SECRET","callbackURL","GITHUB_CLIENT_CALLBACK_URL","accessToken","refreshToken","profile","cb","_json","avatar_url","spread","module","exports","srcDir","middleware","head","meta","charset","hid","content","link","rel","href","css","loading","color","vendor","plugins"],"mappings":";;;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;AC7DA,mC;;;;;;;ACAA;;AAEA;AACA;AACA,gDAA2C;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,EAAE;AACd,YAAY,QAAQ;AACpB;AACA;AACA;AACA,qCAAqC,cAAc;;AAEnD;AACA;AACA,uCAAuC,cAAc;;AAErD,+EAA+E,cAAc;;AAE7F;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA,0CAA0C,QAAQ,GAAG,IAAI,OAAO,IAAI;AACpE;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpjBA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,KAAK,mBAAmB,KAAK;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2DAA2D;;AAE3D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,2DAA2D;;AAE3D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;;AAEA;;AAEA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;;AAEA;;AAEA;AACA,iEAAiE;AACjE;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,2DAA2D;;AAE3D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wDAAwD;;AAExD;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kDAAkD;;AAElD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kDAAkD;;AAElD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,IAAI;AACJ;AACA;AACA,cAAc,8BAA8B;AAC5C,cAAc,8BAA8B;AAC5C,cAAc,2BAA2B;AACzC,cAAc,8BAA8B;AAC5C,cAAc,0BAA0B;AACxC,cAAc,6CAA6C;AAC3D,cAAc,6CAA6C;AAC3D,cAAc,6CAA6C;AAC3D,cAAc,6CAA6C;AAC3D,cAAc,SAAS;AACvB,cAAc,yBAAyB;AACvC,cAAc,2BAA2B;AACzC,cAAc,0BAA0B;AACxC,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,cAAc,0BAA0B;AACxC,cAAc,0BAA0B;AACxC;AACA,cAAc,qCAAqC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,gBAAgB,uCAAuC;AACvD;AACA;AACA,iBAAiB;AACjB;AACA,gBAAgB,sCAAsC;AACtD;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,gBAAgB,yCAAyC;;AAEzD;AACA;AACA;AACA;AACA,WAAW,4BAA4B,mBAAmB;AAC1D;AACA;AACA,gBAAgB,uCAAuC;AACvD;AACA,cAAc,qCAAqC;AACnD,cAAc,kDAAkD;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;;;;;;;;AC90BA;;AAEA;;;;;;;;ACFA;;AAEA;;AAEA;AACA;AACA;;;;;;;ACNA;;;;;;;;;;;;;;;;;;ACAA,mBAAAA,CAAQ,EAAR,EAAkBC,MAAlB;AACA;AACA;AACA;AACA;;AAEA,IAAMC,MAAM,iBAAwB,aAApC;AACA,IAAMD,SAAS,uDAAAE,CAASD,GAAT,CAAf;;AAEA;AACA;AACA;;AAEA,IAAME,SAASC,OAAOC,MAAP,CAAc;AAC3B;AACAC,eAAa,IAFc;AAG3BC,kBAAgB;AACdC,SAAK;AADS,GAHW;AAM3BC,UAAQ;AACNC,gBAAY,IADN;AAENC,eAAW,WAFL;AAGNC,eAAW;AAHL,GANmB;AAW3BC,WAAS;AAXkB,CAAd,EAYZb,MAZY,CAAf;;AAcA,IAAIc,kBAAJ;;AAEA,IAAId,OAAOe,GAAX,EAAgB;AACdD,cAAY,IAAI,iDAAJ,CAAcd,OAAOe,GAArB,EAA0BZ,MAA1B,CAAZ;AACD,CAFD,MAEO;AACLW,cAAY,IAAI,iDAAJ,CAAcd,OAAOgB,QAArB,EAA+BhB,OAAOiB,QAAtC,EAAgDjB,OAAOkB,QAAvD,EAAiEf,MAAjE,CAAZ;AACD;;AAED,IAAIgB,KAAK,EAAT;;AAEA,CAAC,2DAAD,EAAY,uDAAZ,EAAmB,uDAAnB,EAA0BC,OAA1B,CAAkC,UAASC,EAAT,EAAa;AAC7C,MAAIC,QAAQD,GAAGP,SAAH,EAAc,iDAAd,CAAZ;AACAK,KAAGG,MAAMC,IAAT,IAAiBD,KAAjB;AACD,CAHD;;AAKAlB,OAAOoB,IAAP,CAAYL,EAAZ,EAAgBC,OAAhB,CAAwB,UAASK,SAAT,EAAoB;AAC1C,MAAI,eAAeN,GAAGM,SAAH,CAAnB,EAAkC;AAChCN,OAAGM,SAAH,EAAcC,SAAd,CAAwBP,EAAxB;AACD;AACF,CAJD;;AAMAA,GAAGL,SAAH,GAAeA,SAAf;AACAK,GAAGQ,SAAH,GAAe,iDAAf;;AAEA,yDAAeR,EAAf,E;;;;;;ACnDA,iC;;;;;;;ACAA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2CAA2C;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iBAAiB;AACzB,QAAQ,uCAAuC;AAC/C;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,0BAA0B,oBAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,4DAA4D,WAAW;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACjIA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACrCA,iC;;;;;;;ACAA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,0CAA0C;AAC1C;;AAEA;AACA;AACA;;;;;;;;AChBA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kDAAkD;AAClD;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,eAAe;AAC5B,aAAa,OAAO;AACpB,WAAW,oBAAoB;AAC/B,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA,OAAO,6BAA6B;AACpC;;AAEA;AACA;AACA;AACA;AACA,uDAAuD,UAAU;AACjE;;AAEA;AACA,sDAAsD,UAAU;AAChE;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,oBAAoB;AACjC,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,cAAc;AACd;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,WAAW,mBAAmB;AAC9B,cAAc;AACd;AACA;AACA;;AAEA;;AAEA,8BAA8B;AAC9B;AACA;AACA,4CAA4C;;AAE5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;AC1OA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sFAAsF,aAAa;AACnG;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oDAAoD;AACpD,kDAAkD;AAClD;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,eAAe;AAC5B,aAAa,OAAO;AACpB,WAAW,oBAAoB;AAC/B,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,8EAA8E,UAAU;;AAExF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,2EAA2E,UAAU;AACrF;;;AAGA;AACA,OAAO,6BAA6B;AACpC;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,oDAAoD,UAAU;AAC9D;;AAEA;AACA,qDAAqD,UAAU;AAC/D;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,eAAe;AAC5B,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,8CAA8C;AAC3D,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yBAAyB;AACzB;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,2BAA2B;AACxC,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA,uDAAuD,wBAAwB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,aAAa,8CAA8C;AAC3D,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,oEAAoE,MAAM;AAC1E;;AAEA;AACA;AACA;AACA,aAAa,8CAA8C;AAC3D,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,oEAAoE,MAAM;AAC1E;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;AC/cA,mC;;;;;;ACAA,mC;;;;;;;ACAA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC9GA,mC;;;;;;ACAA,4C;;;;;;;ACAA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP,mCAAmC;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa,UAAU;AACvB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK,eAAe;;AAEpB;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,4CAA4C;AAC/E;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,oEAAoE;AACvG;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;ACpSA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,gCAAgC,uBAAuB;AACvD,gCAAgC,uBAAuB;AACvD;AACA;AACA,6BAA6B,WAAW,mBAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,WAAW,kBAAkB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,yEAAyE;AACzE;AACA;AACA;AACA,sBAAsB;AACtB,SAAS;AACT,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,6BAA6B,sBAAsB;AAC5F,yCAAyC,2BAA2B,sBAAsB;;AAE1F;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,eAAe;AAC5B,aAAa,OAAO;AACpB,WAAW,oBAAoB;AAC/B,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,eAAe;AAC5B,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,8CAA8C;AAC3D,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;;AAEL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,2BAA2B;AACxC,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA,yDAAyD,iBAAiB;AAC1E;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA,0CAA0C;;AAE1C;AACA;;AAEA;AACA,0FAA0F,MAAM;AAChG;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oEAAoE,MAAM;AAC1E;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET,2EAA2E,iBAAiB;AAC5F;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,8CAA8C;AAC3D,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,0DAA0D;;AAE1D;;AAEA;AACA;AACA;;AAEA;;AAEA,yDAAyD,iBAAiB;AAC1E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,0CAA0C;;AAE1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0CAA0C;;AAE1C;AACA;;AAEA;;AAEA;AACA,SAAS;;AAET,2EAA2E,iBAAiB;AAC5F;;AAEA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,sFAAsF,MAAM;AAC5F;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,oBAAoB;AACjC,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,yDAAyD,MAAM;AAC/D;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;AC3tBA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;ACtEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,6CAA6C;AAC7C;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,OAAO;;AAEP,qCAAqC,gBAAgB,GAAG,gBAAgB;AACxE;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,eAAe;AACf,WAAW;AACX,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,kCAAkC,YAAY;AAC9C;AACA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,oBAAoB,8BAA8B,EAAE;AACpD;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;AC1TA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;;;;;;ACvBA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,gBAAgB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,UAAU;AACV;AACA;AACA,yBAAyB;AACzB,UAAU;AACV;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,oBAAoB;AAClC,cAAc,oBAAoB;AAClC,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,oBAAoB;AACvC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,cAAc;AACpC;AACA;AACA;AACA;AACA;AACA,sBAAsB,iCAAiC;AACvD;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,kBAAkB;AACtC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,YAAY;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,cAAc;AAC5C;AACA;AACA;AACA;AACA;AACA,8BAA8B,iCAAiC;AAC/D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,YAAY;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;AACA;AACA,0BAA0B,iCAAiC;AAC3D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;ACjsBA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA,mCAAmC;AACnC,GAAG;;AAEH;AACA,mCAAmC,4BAA4B;AAC/D,GAAG;;AAEH;AACA,0BAA0B,wBAAwB,aAAa,wBAAwB;AACvF,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA,0DAA0D;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC;;AAElC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iIAAiI;AACjI;AACA,mDAAmD;AACnD,6BAA6B,2FAA2F;AACxH,OAAO;AACP,6DAA6D;AAC7D,+IAA+I,yCAAyC,yBAAyB,kCAAkC,4CAA4C;AAC/R;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA,oGAAoG,oBAAoB;AACxH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2EAA2E;AAC3E;AACA;AACA,2DAA2D;AAC3D;AACA,4DAA4D;AAC5D;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uJAAuJ;AACvJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,oEAAoE,oBAAoB;AACxF,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,+CAA+C,YAAY;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,0DAA0D;AAC1D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B;;AAE5B;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kIAAkI,oBAAoB;AACtJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,YAAY;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA,0BAA0B,UAAU,OAAO,mBAAmB;AAC9D,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA,iEAAiE,UAAU,GAAG,gBAAgB;AAC9F,0CAA0C,eAAe,WAAW,sBAAsB;AAC1F;AACA;AACA;AACA,iEAAiE,UAAU,GAAG,gBAAgB;AAC9F,0CAA0C,eAAe,UAAU,cAAc;AACjF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iEAAiE,UAAU,GAAG,gBAAgB;AAC9F,0CAA0C,eAAe,YAAY,kCAAkC,QAAQ,aAAa;AAC5H;AACA;AACA,iEAAiE,UAAU,GAAG,gBAAgB;AAC9F,0CAA0C,eAAe,gBAAgB,sBAAsB;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,UAAU,GAAG,gBAAgB,GAAG,iBAAiB;AAClH,qCAAqC,kCAAkC,IAAI,uCAAuC;AAClH,0CAA0C,eAAe;AACzD,6CAA6C,sBAAsB,eAAe,kBAAkB;AACpG;AACA,6CAA6C,+BAA+B;AAC5E;AACA;AACA,6CAA6C,+BAA+B;AAC5E;AACA;AACA,kCAAkC,aAAa;AAC/C;AACA;AACA,GAAG;;AAEH;AACA,0BAA0B,iCAAiC,mBAAmB,sCAAsC;AACpH,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;;AAGA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,mDAAmD,yBAAyB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,0BAA0B;AAC3C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,6BAA6B,WAAW;AACxC,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iDAAiD,+DAA+D;;AAEhH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,+CAA+C,YAAY;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gEAAgE,aAAa;;AAE7E;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2DAA2D,qDAAqD;;AAEhH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,4CAA4C,EAAE;AAC9C;;AAEA;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,oBAAoB;AACpB,0EAA0E,QAAQ;AAClF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW;AACX;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,wBAAwB,2BAA2B,SAAS,uBAAuB,OAAO,aAAa,EAAE,yBAAyB,EAAE,wBAAwB;AAC5J,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc,OAAO;AACrB,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,gCAAgC,2BAA2B,IAAI,WAAW;AAC1E,gCAAgC,2BAA2B,GAAG,WAAW;AACzE;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT,0BAA0B;AAC1B,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT,sBAAsB,2CAA2C,GAAG,2BAA2B;AAC/F;AACA,kBAAkB,OAAO,MAAM,wBAAwB,qBAAqB,GAAG,OAAO,SAAS;AAC/F,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,yCAAyC,4CAA4C,GAAG,uFAAuF;AAC/K;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;;AAET;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT,wCAAwC;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC,eAAe,KAAK,eAAe,EAAE,0BAA0B,QAAQ,oBAAoB;AACjI,OAAO;AACP,sCAAsC,eAAe,GAAG,eAAe,MAAM,oBAAoB;AACjG;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,uCAAuC,eAAe,KAAK,eAAe,EAAE,2BAA2B,QAAQ,oBAAoB;AACnI,OAAO;AACP,uCAAuC,eAAe,GAAG,eAAe,MAAM,oBAAoB;AAClG;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,WAAW,IAAI,OAAO;AAC1C,OAAO;AACP;AACA;AACA;;AAEA;AACA,sBAAsB,OAAO,IAAI,QAAQ;;AAEzC,oBAAoB,wBAAwB,GAAG,gCAAgC;;AAE/E;AACA;AACA;AACA,oBAAoB,gDAAgD,GAAG,+BAA+B;AACtG,OAAO;AACP,yCAAyC,2BAA2B,GAAG,SAAS;AAChF;AACA;;AAEA,oBAAoB,8BAA8B,GAAG,iCAAiC;;AAEtF;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,2BAA2B,UAAU;AACrC,SAAS;AACT,4BAA4B,UAAU;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,yBAAyB,qBAAqB,IAAI,WAAW;AAC7D,iCAAiC,qBAAqB,GAAG,WAAW;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB,YAAY,GAAG,WAAW,GAAG;AAC7E,KAAK;AACL,wBAAwB,6BAA6B,GAAG,iCAAiC;AACzF;AACA,uBAAuB,gCAAgC,GAAG,kCAAkC;;AAE5F;AACA;AACA,sBAAsB,kCAAkC,GAAG,iCAAiC;AAC5F,uBAAuB,gCAAgC,GAAG,kCAAkC;;AAE5F;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,yCAAyC,cAAc,oEAAoE,MAAM,aAAa;AACpK;AACA,4BAA4B,aAAa;AACzC;AACA;AACA;AACA,KAAK;AACL;AACA,oBAAoB,yCAAyC,MAAM,aAAa,GAAG,SAAS,GAAG,oEAAoE;AACnK;AACA;AACA,iCAAiC,aAAa;AAC9C;AACA;;AAEA;AACA;AACA;AACA;AACA,mCAAmC,YAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0CAA0C;AAC1C,uCAAuC,UAAU,0BAA0B;AAC3E;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,YAAY;AACZ,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qDAAqD;AACrD,GAAG;;AAEH;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA,kEAAkE;AAClE,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,cAAc,YAAY;AAC1B,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA,6EAA6E;AAC7E;;AAEA,8BAA8B;AAC9B,GAAG;;AAEH;AACA;AACA;AACA,cAAc,YAAY;AAC1B,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;AACA,4BAA4B;;AAE5B,yBAAyB;AACzB,uBAAuB;AACvB,wBAAwB;;AAExB;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB;AACnB,GAAG;;AAEH;AACA;AACA;AACA,cAAc,YAAY;AAC1B,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;;AAEA,qBAAqB;AACrB,GAAG;;AAEH;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC,qBAAqB;AAC1D;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA,GAAG;;AAEH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,yBAAyB,2CAA2C,GAAG,QAAQ;AAC/E,WAAW;AACX,yBAAyB,gCAAgC,GAAG,QAAQ;AACpE;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gEAAgE,YAAY,YAAY;AACxF;AACA;;AAEA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,wDAAwD;AACxD;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,uBAAuB;AACvB;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,mFAAmF;AACnF,OAAO;AACP,qBAAqB,gCAAgC;AACrD;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA,wCAAwC,EAAE;AAC1C,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;;;;;;;AC34EA,+B;;;;;;;ACAA;;AAEA,wCAAqC,gBAAgB;;AAErD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;ACdA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4DAA4D,qBAAqB;AACjF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,uDAAuD,sBAAsB;AAC7E;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;;;;;;;ACtGA,iC;;;;;;;ACAA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kDAAkD;AAClD;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,eAAe;AAC5B,aAAa,OAAO;AACpB,WAAW,oBAAoB;AAC/B,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO,6BAA6B;AACpC;;AAEA;AACA;AACA;AACA;AACA,sDAAsD,UAAU;AAChE;;AAEA;AACA,uDAAuD,UAAU;AACjE;;AAEA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,oBAAoB;AACjC,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;;AAEA;;AAEA,yBAAyB;AACzB;AACA,KAAK;;AAEL;AACA;AACA;AACA,oCAAoC,UAAU,mEAAmE,UAAU;AAC3H;;AAEA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,WAAW,mBAAmB;AAC9B,cAAc;AACd;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;AC/PA,mC;;;;;;ACAA,uC;;;;;;ACAA,gC;;;;;;;ACAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,uBAAuB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sDAAsD,OAAO,+DAA+D;;AAE5H;;AAEA;AACA;AACA,KAAK;AACL,uBAAuB;AACvB;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gFAAgF,eAAe;AAC/F;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,yCAAyC,eAAe;AACxD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA,iBAAiB;AACjB,KAAK;AACL,iBAAiB;AACjB,KAAK;AACL;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,gBAAgB;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB,kBAAkB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;;;AAGP;AACA,yDAAyD,8CAA8C;AACvG;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,uCAAuC,mDAAmD;AAC1F;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,qDAAqD,iBAAiB,wBAAwB,UAAU;AACxG,KAAK;AACL;AACA;AACA;AACA,yDAAyD,iBAAiB,oBAAoB,UAAU;AACxG,yCAAyC,YAAY;AACrD,SAAS;AACT,yDAAyD,iBAAiB,oBAAoB,UAAU;AACxG;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,uDAAuD,iBAAiB,oBAAoB,UAAU;AACtG;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,yBAAyB;AAChD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM,GAAG,UAAU;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA,WAAW;AACX,WAAW;AACX;AACA,aAAa,OAAO;AACpB,aAAa,wBAAwB;AACrC,aAAa,iBAAiB;AAC9B,aAAa,QAAQ;AACrB,aAAa,IAAI;AACjB,aAAa,eAAe;AAC5B,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB,aAAa,aAAa;AAC1B,aAAa,aAAa;AAC1B,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO,0CAA0C;AAC9D,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,cAAc;AAC3B,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,qBAAqB;AAClC,aAAa,eAAe;AAC5B,aAAa,eAAe;AAC5B,aAAa,eAAe;AAC5B,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;;AAEpB,cAAc;AACd;AACA,oCAAoC;AACpC;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA,2CAA2C,yBAAyB;AACpE;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,eAAe;AACf;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,8FAA8F;AAC9F;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;;AAEA,uDAAuD;AACvD,sBAAsB;AACtB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI;;AAET;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,qBAAqB;AAChC,cAAc;AACd;AACA;AACA,yBAAyB;AACzB;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB,aAAa,QAAQ;AACrB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,aAAa,QAAQ;AACrB;AACA,WAAW,uBAAuB;AAClC;AACA,cAAc;AACd;AACA,kCAAkC;;AAElC;AACA,0CAA0C,iBAAiB;;AAE3D;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,gBAAgB;AAC7B,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,oEAAoE,iBAAiB;AACrF;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,oBAAoB,SAAS,OAAO,SAAS,EAAE,EAAE;AACjD;AACA;AACA;AACA;AACA,kBAAkB,qDAAqD;AACvE;AACA;AACA;AACA,aAAa,yBAAyB;AACtC,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA,yCAAyC,iBAAiB;;AAE1D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wFAAwF;AACxF,WAAW;AACX;AACA;;AAEA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA,gBAAgB,KAAK,QAAQ;AAC7B,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,qBAAqB;AACnC,cAAc,cAAc,6KAA6K,cAAc,mEAAmE;AAC1R,cAAc,cAAc,uKAAuK,cAAc,wBAAwB,EAAE;AAC3O,cAAc,QAAQ;AACtB,cAAc,2BAA2B,kIAAkI,iCAAiC,OAAO,YAAY,6BAA6B,EAAE,OAAO,oBAAoB,mEAAmE,SAAS;AACrW,cAAc,MAAM;AACpB,cAAc,OAAO;AACrB,cAAc,YAAY;AAC1B,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,cAAc,cAAc;AAC5B,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,MAAM;AACpB,cAAc,2BAA2B;AACzC,cAAc,mDAAmD;AACjE,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,YAAY;AAC1B,cAAc,cAAc;AAC5B,cAAc,QAAQ;AACtB,cAAc,SAAS;AACvB,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,cAAc;AAC5B;AACA,cAAc;AACd,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,yBAAyB,yDAAyD;;AAElF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sCAAsC,qCAAqC,+CAA+C,UAAU;AACpI;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,sDAAsD,WAAW;AACjE;AACA;AACA;AACA,WAAW;AACX;AACA,cAAc;AACd;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,qBAAqB;AACnC,cAAc,OAAO;AACrB,cAAc,YAAY;AAC1B,cAAc,OAAO;AACrB;AACA,WAAW,oBAAoB;AAC/B,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,YAAY;AAC1B,cAAc,OAAO;AACrB;AACA,WAAW,oBAAoB;AAC/B,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,aAAa,QAAQ;AACrB,aAAa,iBAAiB;AAC9B,aAAa,QAAQ;AACrB,aAAa,YAAY;AACzB,aAAa,QAAQ;AACrB;AACA,cAAc,0BAA0B;AACxC;AACA;AACA;AACA,mCAAmC,iBAAiB;AACpD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,YAAY;AACzB,aAAa,SAAS;AACtB,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB;AACA,cAAc;AACd;AACA;AACA;AACA,sDAAsD,cAAc;AACpE;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA,WAAW,oBAAoB;AAC/B,cAAc,SAAS,8BAA8B;AACrD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,WAAW,sBAAsB;AACjC;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,WAAW,sBAAsB;AACjC;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,WAAW,sBAAsB;AACjC;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO,uBAAuB;AAC3C,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,MAAM;AACnB;AACA,cAAc;AACd;AACA,iCAAiC;AACjC;AACA;AACA;;AAEA;AACA;;AAEA,wCAAwC;AACxC;AACA;AACA,KAAK,eAAe;;AAEpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,WAAW;AACX,WAAW;AACX;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,MAAM;AACnB,aAAa,MAAM;AACnB,aAAa,SAAS;AACtB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB,aAAa,QAAQ;AACrB,aAAa,YAAY;AACzB,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;AACA,cAAc;AACd;AACA;AACA;AACA,2CAA2C;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,aAAa,QAAQ;AACrB;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,YAAY;AACzB,WAAW,oBAAoB;AAC/B,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB;;AAEzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sCAAsC,YAAY;AAClD,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,oDAAoD,YAAY;AAChE;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA,wFAAwF,KAAK;AAC7F;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAiC,UAAU,gCAAgC,KAAK,0DAA0D,oBAAoB,QAAQ,MAAM;AAC5K;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,WAAW,oBAAoB;AAC/B,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,MAAM;AACpB,cAAc,QAAQ;AACtB,cAAc,YAAY;AAC1B,cAAc,SAAS;AACvB,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB;AACA,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA,KAAK,+BAA+B;;AAEpC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB,cAAc,OAAO;AACrB,cAAc,MAAM;AACpB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,MAAM;AACpB,cAAc,YAAY;AAC1B,cAAc,SAAS;AACvB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK,eAAe;;AAEpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,8DAA8D,kBAAkB;;AAEhF;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB,8BAA8B;AACvD,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wGAAwG,UAAU;AAClH,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,yFAAyF,iBAAiB;AAC1G;AACA,aAAa,OAAO;AACpB,aAAa,iBAAiB;AAC9B,aAAa,YAAY;AACzB,aAAa,iBAAiB;AAC9B,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB;AACA,cAAc;AACd;AACA,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,YAAY;AAC1B,cAAc,SAAS;AACvB,cAAc,QAAQ;AACtB,cAAc,iBAAiB;AAC/B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,6BAA6B,+GAA+G;AAC5I;AACA;AACA;AACA,WAAW;AACX;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,cAAc,SAAS;AACvB,cAAc,QAAQ;AACtB,cAAc,YAAY;AAC1B;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK,eAAe;;AAEpB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,6BAA6B,gIAAgI;AAC7J;AACA;AACA;AACA,WAAW;AACX;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,MAAM;AACpB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,cAAc,SAAS;AACvB,cAAc,QAAQ;AACtB,cAAc,YAAY;AAC1B,cAAc,QAAQ;AACtB;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,qGAAqG,YAAY;;AAEjH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,6BAA6B,+GAA+G;AAC5I;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA,aAAa;AACb,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe;AACf;AACA,eAAe;AACf;AACA,WAAW;AACX,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,uEAAuE,4CAA4C;AACnH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mDAAmD;;AAEnD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,SAAS,aAAa;AACrD,0CAA0C,gBAAgB,aAAa,EAAE;AACzE,qBAAqB,uBAAuB,GAAG,gBAAgB,aAAa,EAAE;AAC9E;AACA;AACA;AACA,UAAU;AACV,YAAY,oBAAoB;AAChC,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,SAAS;AACrB,YAAY,YAAY;AACxB,aAAa,OAAO;AACpB;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,oBAAoB;AACpB,eAAe;AACf;AACA,KAAK;;AAEL,6BAA6B;;AAE7B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP,KAAK,OAAO;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO,YAAY;AAChC,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,eAAe;;AAEpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA,gBAAgB;AAChB;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,+CAA+C,UAAU;AACzD;AACA,KAAK,IAAI;;AAET;AACA;AACA;AACA;AACA;AACA,kDAAkD,UAAU;AAC5D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,IAAI;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,cAAc;AACd;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B,aAAa,cAAc;AAC3B,aAAa,IAAI;AACjB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA,4BAA4B;AAC5B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+CAA+C,YAAY;AAC3D;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB,aAAa,YAAY;AACzB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kFAAkF,UAAU;AAC5F;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,sDAAsD,UAAU;AAChE;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,yEAAyE;AACzE;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,WAAW;AACX;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX,2GAA2G,sCAAsC;AACjJ,OAAO;AACP,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;;AAEf;AACA;AACA;AACA;AACA;AACA,2GAA2G,UAAU;AACrH,iHAAiH,UAAU;AAC3H;AACA;AACA;AACA,iBAAiB;AACjB,eAAe;AACf,6GAA6G,UAAU;AACvH;AACA;AACA,aAAa;AACb,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB;AACA,aAAa;AACb;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,8DAA8D,oDAAoD,4BAA4B;AAC9I;AACA,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,YAAY,QAAQ;AACpB;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX,WAAW;AACX,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA,2CAA2C;;AAE3C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO,iBAAiB;AACrC,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB,aAAa,YAAY;AACzB,cAAc,OAAO;AACrB;AACA,cAAc;AACd;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,mFAAmF,eAAe;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT,OAAO;AACP,wHAAwH,uCAAuC;AAC/J;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO,iBAAiB;AACrC,aAAa,SAAS;AACtB,aAAa,YAAY;AACzB;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,kCAAkC,YAAY,gCAAgC;AAC9E,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,QAAQ;AACrD,wBAAwB,sBAAsB,GAAG,QAAQ;AACzD;AACA;AACA;AACA,UAAU;AACV,YAAY,oBAAoB;AAChC,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,SAAS;AACrB,YAAY,YAAY;AACxB,aAAa,OAAO;AACpB;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,+BAA+B;AAC/B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,QAAQ;AACtD,yBAAyB,sBAAsB,GAAG,QAAQ;AAC1D;AACA;AACA;AACA,WAAW;AACX,aAAa,oBAAoB;AACjC,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB,aAAa,YAAY;AACzB,cAAc,OAAO;AACrB;AACA,cAAc;AACd;AACA;AACA,0BAA0B,mBAAmB;AAC7C;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA,aAAa,MAAM;AACnB,cAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kGAAkG,UAAU,4BAA4B,UAAU;AAClJ;;AAEA;AACA;AACA;AACA,aAAa,MAAM;AACnB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,OAAO;AACpB,aAAa,QAAQ,iLAAiL,gCAAgC;AACtO,aAAa,cAAc;AAC3B,aAAa,cAAc;AAC3B,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO,0CAA0C;AAC9D,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA;AACA,oCAAoC;;;AAGpC;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,OAAO;AACpB,aAAa,QAAQ,iLAAiL,gCAAgC;AACtO,aAAa,oBAAoB;AACjC,aAAa,MAAM;AACnB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,cAAc;AAC3B,aAAa,cAAc;AAC3B,aAAa,cAAc;AAC3B,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,OAAO,0CAA0C;AAC9D,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,cAAc;AACd;AACA;AACA,kCAAkC,0BAA0B;AAC5D,kCAAkC,0BAA0B;AAC5D;AACA;AACA;AACA;AACA,MAAM;AACN,kCAAkC,wBAAwB;AAC1D,kCAAkC,wBAAwB;AAC1D;AACA,0CAA0C;;AAE1C;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,OAAO;AACpB,aAAa,QAAQ,6KAA6K,gCAAgC;AAClO,aAAa,OAAO;AACpB,aAAa,cAAc;AAC3B,aAAa,OAAO,sCAAsC;AAC1D,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA;AACA,mCAAmC;;;AAGnC;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,OAAO;AACpB,aAAa,QAAQ,6KAA6K,gCAAgC;AAClO,aAAa,OAAO;AACpB,aAAa,cAAc;AAC3B,aAAa,OAAO;AACpB,aAAa,OAAO,sCAAsC,aAAa;AACvE,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA;AACA,sCAAsC;AACtC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;ACjhIA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,UAAU;AAC7B,kBAAkB,UAAU;AAC5B,qBAAqB,UAAU;AAC/B,iBAAiB,UAAU;AAC3B,gBAAgB,UAAU;AAC1B,kBAAkB,UAAU;AAC5B,iBAAiB,UAAU;AAC3B,kBAAkB,UAAU;AAC5B,iBAAiB,UAAU;AAC3B,iBAAiB,UAAU;AAC3B,gBAAgB,UAAU;AAC1B,eAAe,qDAAqD;AACpE,cAAc,mDAAmD;AACjE,iBAAiB,UAAU;AAC3B,gBAAgB,UAAU;AAC1B,qBAAqB,UAAU;AAC/B,oBAAoB,UAAU;AAC9B,sBAAsB,UAAU;AAChC,qBAAqB,UAAU;AAC/B,sBAAsB,UAAU;AAChC,qBAAqB,UAAU;AAC/B,qBAAqB,UAAU;AAC/B,oBAAoB,UAAU;AAC9B,eAAe,UAAU;AACzB,oCAAoC,UAAU;AAC9C,2BAA2B,UAAU;AACrC,cAAc,UAAU;AACxB,gBAAgB,UAAU;AAC1B,iBAAiB,sBAAsB;AACvC,gBAAgB,sBAAsB;AACtC,eAAe,sBAAsB;AACrC,cAAc,sBAAsB;AACpC,kBAAkB,UAAU;AAC5B,iBAAiB,UAAU;AAC3B,eAAe,UAAU;AACzB,cAAc,UAAU;AACxB,mBAAmB,UAAU;AAC7B,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,SAAS;AACrC;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,SAAS;AAClC;;AAEA;AACA;;AAEA;AACA;AACA,4CAA4C,SAAS;AACrD,KAAK;;AAEL;AACA,GAAG;;AAEH;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iCAAiC,SAAS;;AAE1C;AACA;;AAEA;AACA;AACA;AACA,+BAA+B;AAC/B,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA,+DAA+D,WAAW,SAAS,EAAE;AACrF,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB;AACA;AACA;;;;;;;ACzhBA,oC;;;;;;;ACAA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,KAAK,eAAe;;AAEpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,sDAAsD;AACtD,GAAG;;AAEH;AACA,wBAAwB;AACxB,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,0BAA0B,uBAAuB,OAAO,0BAA0B,GAAG,YAAY;AACjG,GAAG;;AAEH;AACA,0BAA0B,2BAA2B,QAAQ,qCAAqC;AAClG,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,OAAO,gBAAgB,SAAS,IAAI,WAAW;AAChF,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,2BAA2B,GAAG,YAAY;AACpE,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA,0BAA0B,2BAA2B,UAAU,uBAAuB;AACtF,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA,4EAA4E;AAC5E,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,UAAU;AACrC;;AAEA;AACA,wCAAwC,eAAe;AACvD;;AAEA,mBAAmB;AACnB,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA,yBAAyB,gCAAgC,MAAM,2BAA2B;AAC1F,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA,4CAA4C,iCAAiC;;AAE7E;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,+CAA+C,kBAAkB,GAAG,SAAS;;AAE7E,wCAAwC,OAAO,gBAAgB,SAAS;AACxE;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA,yHAAyH,EAAE;AAC3H,GAAG;;AAEH;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA,qHAAqH;AACrH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;ACnWA;;AAEA,yDAAe,uDAAf,E;;;;;;;;;;;;;;;;;;;;;ACFA;AACA;;;AAGE,oBAAc;AAAA;;AACZ,SAAKJ,GAAL,GAAW,WAAX;AACD;;;;;gLAEYa,G;;;;;;AACLC,kB,GAAOD,IAAIzB,M,CAAX0B,E;;uBAEA,wDAAAC,CAAOC,KAAP,CAAaC,MAAb,CACJ;AACEC,6BAAW;AADb,iBADI,EAIJ;AACEC,yBAAO;AACLL,wBAAIA;AADC;AADT,iBAJI,C;;;;uBAWA,wDAAAC,CAAOK,SAAP,CAAiBC,MAAjB,CAAwB;AAC5BC,0BAAQ,CADoB;AAE5BC,2BAAST,EAFmB;AAG5BU,yBAAO,IAHqB;AAI5BC,6BAAWZ,IAAIa,KAAJ,CAAUC,IAAV,CAAeb;AAJE,iBAAxB,C;;;;AAOND,oBAAIe,IAAJ,GAAW;AACTC,2BAAS;AADA,iBAAX;;;;;;;;;;;;;;;;;;;kLAKQhB,G;;;;;;AACFC,kB,GAAOD,IAAIzB,M,CAAX0B,E;;uBAEa,wDAAAC,CAAOC,KAAP,CAAac,OAAb,CACjB;AACEX,yBAAO;AACLD,+BAAW,CADN;AAELJ,wBAAIA;AAFC;AADT,iBADiB,C;;;AAAfiB,sB;AASAC,oB,GAAOD,OAAO,CAAP,C;;oBACNC,I;;;;;sBACG;AACJC,0BAAQ,GADJ;AAEJzB,wBAAM,iBAFF;AAGJqB,2BAAS;AAHL,iB;;;;;AAON,oBAAIG,KAAKR,KAAT,EAAgBQ,KAAKR,KAAL,GAAaU,KAAKC,KAAL,CAAWH,KAAKR,KAAhB,CAAb;AAChB,oBAAIQ,KAAK/C,MAAT,EAAiB+C,KAAK/C,MAAL,GAAciD,KAAKC,KAAL,CAAWH,KAAK/C,MAAhB,CAAd;;;;;;;sBAEX;AACJgD,0BAAQ,GADJ;AAEJzB,wBAAM,kBAFF;AAGJqB,2BAAS;AAHL,iB;;;;AAORhB,oBAAIe,IAAJ,GAAWI,IAAX;;;;;;;;;;;;;;;;;;;kLAGQnB,G;;;;;;;AACFC,kB,GAAOD,IAAIzB,M,CAAX0B,E;AACAc,oB,GAASf,IAAIuB,O,CAAbR,I;AACFS,sB,GAAShD,OAAOgC,MAAP,CAAc,IAAd,C;AACTiB,qB,GAAQ,CAAC,OAAD,EAAU,QAAV,EAAoB,OAApB,EAA6BC,MAA7B,CAAoC,UAACD,KAAD,EAAQ9B,IAAR,EAAiB;AAC/D,sBAAI,EAAEA,QAAQoB,IAAV,CAAJ,EAAqB,OAAOU,KAAP;AACrBD,yBAAO7B,IAAP,IAAeoB,KAAKpB,IAAL,CAAf;AACA,yBAAO8B,QAAQ,CAAf;AACD,iBAJW,EAIT,CAJS,C;;sBAMRA,UAAU,C;;;;;sBACN;AACJL,0BAAQ,GADJ;AAEJzB,wBAAM,KAFF;AAGJqB,2BAAS;AAHL,iB;;;;AAMRQ,uBAAOG,KAAP,GAAeH,OAAOG,KAAP,CAAaC,IAAb,EAAf;;oBAEKJ,OAAOG,K;;;;;sBACJ,EAAEP,QAAQ,GAAV,EAAezB,MAAM,cAArB,EAAqCqB,SAAS,YAA9C,E;;;sBAEJ,WAAWQ,M;;;;;AACbA,uBAAOb,KAAP,GAAeU,KAAKQ,SAAL,CAAeL,OAAOb,KAAtB,CAAf;;sBACIa,OAAOb,KAAP,CAAamB,MAAb,GAAsB,2DAAAC,CAAGC,gB;;;;;sBAAwB,2DAAAD,CAAGE,c;;;AAE1D,oBAAI,YAAYT,MAAhB,EAAwB;AACtBA,yBAAOpD,MAAP,GAAgBiD,KAAKQ,SAAL,CAAeL,OAAOpD,MAAtB,CAAhB;AACD;;;uBAEkB,wDAAA8B,CAAOC,KAAP,CAAac,OAAb,CAAqB;AACtCiB,8BAAY,CAAC,WAAD,EAAc,OAAd,CAD0B;AAEtC5B,yBAAO;AACLL,wBAAIA;AADC;AAF+B,iBAArB,C;;;;;AAAdkB,oB;;sBAOD,CAACA,IAAD,IAASA,KAAKd,S;;;;;sBACR;AACJe,0BAAQ,GADJ;AAEJzB,wBAAM,gBAFF;AAGJqB,2BAAS;AAHL,iB;;;;uBAMJ,wDAAAd,CAAOC,KAAP,CAAaC,MAAb,CACJoB,MADI,EAEJ;AACElB,yBAAO;AACLL,wBAAIA;AADC;AADT,iBAFI,C;;;AASFkC,uB,GAAU,CAAC,OAAD,EAAU,QAAV,EAAoB,OAApB,EAA6BT,MAA7B,CAAoC,UAACS,OAAD,EAAUxC,IAAV,EAAmB;AACnE,yBAAOwB,KAAKxB,IAAL,MAAe6B,OAAO7B,IAAP,CAAf,GAA8BwC,UAAU,CAAxC,GAA4CA,OAAnD;AACD,iBAFa,EAEX,CAFW,C;;sBAGVA,UAAU,C;;;;;;uBACN,wDAAAjC,CAAOK,SAAP,CAAiBC,MAAjB,CAAwB;AAC5BC,0BAAQ,CADoB;AAE5BC,2BAAST,EAFmB;AAG5BU,yBAAOa,OAAOb,KAHc;AAI5BC,6BAAWZ,IAAIa,KAAJ,CAAUC,IAAV,CAAeb;AAJE,iBAAxB,C;;;;AAQRD,oBAAIe,IAAJ,GAAW;AACTC,2BAAS;AADA,iBAAX;;;;;;;;;;;;;;;;;;;;;;AAIH,C;;;;;;;ACzID,yDAAe;AACbgB,oCAAkB,KADL;AAEbC,kCAAgB;AACEb,4CAAQ,GADV;AAEEJ,6CAAS,sBAFX;AAGErB,0CAAM;AAHR;AAFH,CAAf,E;;;;;;ACAA,yC;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;;AAEA,IAAMyC,MAAM,IAAI,2CAAJ,EAAZ;AACA,IAAMC,OAAOC,QAAQjE,GAAR,CAAYkE,IAAZ,IAAoB,WAAjC;AACA,IAAMC,OAAOF,QAAQjE,GAAR,CAAYoE,IAAZ,IAAoB,IAAjC;;AAEAL,IAAIxC,IAAJ,GAAW,CAAC,cAAD,CAAX;AACAwC,IAAIM,GAAJ,CAAQ,mBAAAvE,CAAQ,GAAR,EAAuB,EAAvB,EAA2BiE,GAA3B,CAAR;AACAA,IAAIM,GAAJ,CAAQ,mBAAAvE,CAAQ,GAAR,GAAR;;AAEA;AACA,mBAAAA,CAAQ,GAAR;AACA,IAAMwE,WAAW,mBAAAxE,CAAQ,EAAR,CAAjB;AACAiE,IAAIM,GAAJ,CAAQC,SAASC,UAAT,EAAR;AACAR,IAAIM,GAAJ,CAAQC,SAASE,OAAT,EAAR;;AAEA,IAAMC,SAAS,mBAAA3E,CAAQ,EAAR,GAAf;;AAEA2E,OAAOC,GAAP,CAAW,cAAX,EACEJ,SAASK,YAAT,CAAsB,QAAtB,CADF;;AAIAF,OAAOC,GAAP,CAAW,uBAAX,EACEJ,SAASK,YAAT,CAAsB,QAAtB,EAAgC;AAC9BC,mBAAiB,GADa;AAE9B;AACAC,mBAAiB;AAHa,CAAhC,CADF;;AAQAd,IAAIM,GAAJ,CAAQI,OAAOK,MAAP,EAAR;AACAf,IAAIM,GAAJ,CAAQ,yDAAAU,CAASD,MAAT,EAAR;;AAEAf,IAAIM,GAAJ,CAAQ,eAAO;AACb1C,MAAIoB,MAAJ,GAAa,GAAb,CADa,CACI;;AAEjB,SAAO,IAAIiC,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACtCvD,QAAIwD,GAAJ,CAAQC,EAAR,CAAW,OAAX,EAAoBH,OAApB;AACAtD,QAAIwD,GAAJ,CAAQC,EAAR,CAAW,QAAX,EAAqBH,OAArB;AACAI,SAAKC,MAAL,CAAY3D,IAAI4D,GAAhB,EAAqB5D,IAAIwD,GAAzB,EAA8B,mBAAW;AACvC;AACAK,cAAQC,IAAR,CAAaR,OAAb,EAAsBS,KAAtB,CAA4BR,MAA5B;AACD,KAHD;AAID,GAPM,CAAP;AAQD,CAXD;;AAaA;AACA,IAAInF,SAAS,mBAAAD,CAAQ,GAAR,CAAb;AACAC,OAAO4F,GAAP,GAAa,EAAE5B,IAAI/D,GAAJ,KAAY,YAAd,CAAb;;AAEA;AACA,IAAMqF,OAAO,IAAI,0CAAJ,CAAStF,MAAT,CAAb;;AAEA;AACA,IAAIA,OAAO4F,GAAX,EAAgB;AACd,MAAMC,UAAU,IAAI,6CAAJ,CAAYP,IAAZ,CAAhB;AACAO,UAAQC,KAAR,GAAgBH,KAAhB,CAAsB,aAAK;AACzBI,YAAQC,KAAR,CAAcC,CAAd,EADyB,CACR;AACjB/B,YAAQgC,IAAR,CAAa,CAAb;AACD,GAHD;AAID;;AAED,wDAAApE,CAAOhB,SAAP,CAAiBqF,IAAjB,GAAwBT,IAAxB,CAA6B,YAAU;AACrC1B,MAAIoC,MAAJ,CAAWhC,IAAX,EAAiBH,IAAjB;AACA8B,UAAQM,GAAR,CAAY,yBAAyBpC,IAAzB,GAAgC,GAAhC,GAAsCG,IAAlD,EAFqC,CAEmB;AACzD,CAHD,EAGGuB,KAHH,CAGS,UAASW,GAAT,EAAa;AACpBP,UAAQC,KAAR,CAAc,IAAIO,KAAJ,CAAUD,GAAV,CAAd;AACD,CALD,E;;;;;;ACjEA,gC;;;;;;ACAA,iC;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAME,YAAY,IAAI,kDAAJ,CAAc,EAAEC,QAAQ,MAAV,EAAd,CAAlB;;AAEA,CAAC,wEAAD,EAAa,mEAAb,EAAoB,mEAApB,EAA2B,kEAA3B,EAAiC,mEAAjC,EAAwC,qEAAxC,EAAiD,oEAAjD,EAAwDrF,OAAxD,CAAgE,UAASsF,KAAT,EAAgB;AAAA;;AAC9E,MAAIC,aAAa,IAAID,KAAJ,EAAjB;;AAD8E,6BAErEE,MAFqE;AAG5E,QAAIA,UAAUD,UAAd,EAA0B;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAH,gBAAUI,MAAV,EAAkBD,WAAW5F,GAA7B;AAAA,iKAAkC,iBAAOa,GAAP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,yBAAqB+E,WAAWC,MAAX,EAAmBhF,GAAnB,CAArB;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAlC;;AAAA;AAAA;AAAA;AAAA;AACD;AAjB2E;;AAAA,aAE3D,CAAE,SAAF,EAAa,KAAb,EAAoB,MAApB,EAA4B,QAA5B,EAAsC,KAAtC,CAF2D;AAE9E,2CAAkE;AAA7D,QAAIgF,iBAAJ;AAA6D,UAAzDA,MAAyD;AAgBjE;AACF,CAnBD;;AAqBAJ,UAAU7B,GAAV,CAAc,SAAd,EAAyB,UAAC/C,GAAD,EAAS;AAChCA,MAAIiF,MAAJ;AACAjF,MAAIe,IAAJ,GAAW;AACTC,aAAS;AADA,GAAX;AAGD,CALD;;AAOA,yDAAe4D,SAAf,E;;;;;;AC1CA,gD;;;;;;;;;;;;;;;;;;ACAA;;;AAGE,oBAAc;AAAA;;AACZ,SAAKzF,GAAL,GAAW,aAAX;AACD;;;;;gLAESa,G;;;;;;;6BAC4BA,IAAIkF,K,EAAlC/D,I,cAAAA,I,EAAMgE,I,cAAAA,I,EAAMxD,K,cAAAA,K,EAAOlB,M,cAAAA,M;;AACzBU,uBAAOiE,SAASjE,IAAT,EAAe,EAAf,CAAP;AACAgE,uBAAOC,SAASD,IAAT,EAAe,EAAf,CAAP;AACIE,qB,GAAQ,CAAClE,OAAO,CAAR,IAAagE,I;AACrBG,qB,GAAQH,I;AACR7E,qB,GAAQ,E;;AACZ,oBAAIqB,KAAJ,EAAW;AACTrB,wBAAM,cAAN,IAAwB;AACtBiF,iCAAW5D,KAAX;AADsB,mBAAxB;AAGD;AACD,oBAAIlB,UAAUA,UAAU,CAAxB,EAA2B;AACzBH,wBAAM,QAAN,IAAkBG,MAAlB;AACD;;;uBAEkB,wDAAAP,CAAOK,SAAP,CAAiBiF,eAAjB,CAAiC;AAClDtD,8BAAY,CAAC,QAAD,EAAW,WAAX,CADsC;AAElDuD,2BAAS,CACP;AACE/F,2BAAO,wDAAAQ,CAAOC,KADhB;AAEE+B,gCAAY,CAAC,OAAD;AAFd,mBADO,EAKP;AACExC,2BAAO,wDAAAQ,CAAOwF,KADhB;AAEExD,gCAAY,CAAC,MAAD;AAFd,mBALO,CAFyC;AAYlDyD,0BAAQN,KAZ0C;AAalDC,yBAAOA,KAb2C;AAclDhF,yBAAOA,KAd2C;AAelDsF,yBAAO,CAAC,CAAC,WAAD,EAAc,MAAd,CAAD;AAf2C,iBAAjC,C;;;AAAf1E,sB;;;AAkBJlB,oBAAIe,IAAJ,GAAW;AACT8E,yBAAO3E,OAAOO,KADL;AAETN,wBAAMA,IAFG;AAGTgE,wBAAMA,IAHG;AAITW,wBAAM5E,OAAO6E;AAJJ,iBAAX;;;;;;;;;;;;;;;;;;;;;;AAQH,C;;;;;;;ACjDD;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACPA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA,qEAAqE;AACrE;AACA;AACA,sCAAsC,+BAA+B;AACrE;AACA;AACA,0EAA0E;AAC1E;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO,cAAc;AAClC,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO,qBAAqB;AACzC,aAAa,OAAO,oBAAoB;AACxC,aAAa,OAAO,kBAAkB;AACtC,aAAa,OAAO,mBAAmB;AACvC,aAAa,OAAO,scAAsc;AAC1d,aAAa,SAAS;AACtB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,OAAO,mBAAmB;AACvC,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,MAAM;AACnB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA,KAAK;AACL,6BAA6B,cAAc;;AAE3C;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL,sDAAsD,cAAc;AACpE;AACA,gBAAgB;AAChB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,eAAe;AACf,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,eAAe;AACf,cAAc,mDAAmD;AACjE;AACA;AACA;AACA;AACA;AACA,KAAK,eAAe;;AAEpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc,eAAe;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO,2EAA2E;AAC/F,aAAa,OAAO;AACpB;AACA,WAAW,iBAAiB;AAC5B;AACA,WAAW,gBAAgB;AAC3B;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,0CAA0C;AAC1C;;AAEA;AACA;;AAEA;;AAEA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,mCAAmC,oCAAoC;AACvE;AACA,MAAM;AACN;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO,qBAAqB;AACzC,aAAa,QAAQ;AACrB,aAAa,YAAY;AACzB,aAAa,WAAW;AACxB,aAAa,QAAQ,yLAAyL,0BAA0B,UAAU,QAAQ,oBAAoB;AAC9Q,aAAa,QAAQ;AACrB,aAAa,aAAa;AAC1B,aAAa,aAAa;AAC1B,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB,aAAa,YAAY;AACzB,aAAa,MAAM;AACnB,aAAa,OAAO;AACpB,aAAa,MAAM;AACnB,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB;AACA,cAAc;AACd;AACA,WAAW,kBAAkB;AAC7B;;AAEA;AACA;;AAEA;AACA,2BAA2B;;AAE3B;AACA;AACA;;AAEA;AACA;AACA,uEAAuE;AACvE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,OAAO,yDAAyD;AAChE,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,YAAY;AACzB;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,+BAA+B,gEAAgE;;AAE/F;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,iBAAiB;AAC9B,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,iBAAiB;AAC9B,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,iBAAiB;AAC9B,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,iBAAiB;AAC9B,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO,YAAY;AAChC,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB,aAAa,iBAAiB;AAC9B,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,cAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;;AAEP;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,iBAAiB;AAC9B,aAAa,iBAAiB;AAC9B,cAAc;AACd;AACA,WAAW,qBAAqB;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK,GAAG,iBAAiB;;AAEzB;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,WAAW,iBAAiB;AAC5B;AACA,aAAa,OAAO;AACpB,aAAa,iBAAiB;AAC9B,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK,GAAG,iBAAiB;;AAEzB;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,8DAA8D,yBAAyB;AACvF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,WAAW;AACX,WAAW;AACX,WAAW;AACX;AACA;AACA,aAAa,OAAO;AACpB,aAAa,IAAI;AACjB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB,aAAa,OAAO;AACpB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA,aAAa,cAAc;AAC3B;AACA;AACA,cAAc;AACd;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA,aAAa,cAAc;AAC3B;AACA;AACA,cAAc;AACd;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,sBAAsB;AACnC;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS,mBAAmB;AAC1E;AACA,WAAW;AACX;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8BAA8B,YAAY;AAC1C,mDAAmD,YAAY;AAC/D;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,8BAA8B,YAAY;AAC1C,mDAAmD,YAAY;AAC/D,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,aAAa,OAAO,cAAc;AAClC,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,aAAa,SAAS,qJAAqJ;AAC3K,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF;AACnF,WAAW;AACX,SAAS;AACT,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,eAAe,EAAE;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB;;AAErB;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;;;;;;AC7rCA,gC;;;;;;ACAA,8C;;;;;;ACAA,yC;;;;;;ACAA,mD;;;;;;;ACAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;;AAExC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;;AAExC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC5YA,sC;;;;;;;ACAA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;;;;;;AC7eA,sC;;;;;;;ACAA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;;;;;;;AC3EA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;;;;;;;AC9LA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,4BAA4B;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;;;;;;;;ACzOA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;;;;;;;AC1PA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,uBAAuB,oBAAoB,0BAA0B,wBAAwB;AAC7F;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,2CAA2C,MAAM,UAAU,iBAAiB;AAC5E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,eAAe;;AAElB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;AC1DA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK,cAAc;;AAEnB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB,oBAAoB,aAAa,QAAQ;AAC9D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC9CA,iC;;;;;;ACAA,kC;;;;;;ACAA,qC;;;;;;ACAA,uC;;;;;;;ACAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;;AAEA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yBAAyB,EAAE;AAC1D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,2CAA2C;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA,cAAc,2CAA2C;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA,aAAa,EAAE;AACf,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAqC;AACrC;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA,iCAAiC;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,EAAE;AACf,aAAa,EAAE;AACf,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,cAAc,MAAM,MAAM;AAC5E;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,EAAE;AACf,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,EAAE;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA,yDAAyD,MAAM;AAC/D;AACA;AACA;;AAEA;AACA;AACA,0DAA0D,MAAM;AAChE;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,cAAc;AAC3B,aAAa,kCAAkC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB,aAAa,aAAa;AAC1B,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;AC9XA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B;AAC5B;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,GAAG;;AAEH,uCAAuC;AACvC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;;;;;;AC3GA,mC;;;;;;;ACAA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;AC1HD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,sCAAsC;AACtC;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC;AACtC;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;ACjGA,2C;;;;;;;ACAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA,yBAAyB;AACzB;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,YAAY,2BAA2B;AACxD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA,uBAAuB,YAAY,kDAAkD;AACrF;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,YAAY,YAAY;AACnD;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,+EAA+E,yBAAyB;;AAExG;AACA;;AAEA;AACA;;AAEA,yBAAyB,YAAY;AACrC;AACA;AACA;AACA,iEAAiE,YAAY,YAAY;AACzF;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,oDAAoD,YAAY,gBAAgB;AAChF;AACA,KAAK;;AAEL;AACA;AACA,yDAAyD;AACzD;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb,WAAW;;AAEX;AACA,SAAS;AACT;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,iBAAiB,YAAY,YAAY;AACzC;AACA;;AAEA;AACA;AACA;AACA,gDAAgD,YAAY,mDAAmD;AAC/G;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,iBAAiB,YAAY,4BAA4B;AACzD;AACA;AACA;AACA;AACA;AACA,mHAAmH;AACnH,OAAO;AACP;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mCAAmC;AACnC,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gDAAgD,YAAY,4BAA4B;AACxF;;AAEA;AACA;AACA,gDAAgD,YAAY,+BAA+B;AAC3F;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,+BAA+B;AAC/B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,OAAO;;AAEP;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,qDAAqD,YAAY,mCAAmC;AACpG;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC;AACnC;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6DAA6D;AAC7D,oEAAoE,6BAA6B;;AAEjG;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,mCAAmC,YAAY;AAC/C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB;AACzB;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yBAAyB;AACzB;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yBAAyB;AACzB;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA,yBAAyB;AACzB;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB;AACzB;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yBAAyB;AACzB;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;ACj8BA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,iBAAiB;;AAE5B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mCAAmC;;AAEnC,kFAAkF,mBAAmB,UAAU;AAC/G,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,iBAAiB;;AAE5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mCAAmC;;AAEnC,kFAAkF,mBAAmB,UAAU;AAC/G,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,iBAAiB;;AAE5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mCAAmC;;AAEnC,kFAAkF,mBAAmB,UAAU;AAC/G,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,gDAAgD,0BAA0B,GAAG,0BAA0B,GAAG,+BAA+B;;AAEzI;AACA;AACA;AACA;AACA,8CAA8C,mBAAmB,IAAI,mBAAmB;AACxF,6CAA6C,wBAAwB;AACrE,6CAA6C,wBAAwB;AACrE;;AAEA;AACA,4BAA4B;;AAE5B;AACA,OAAO;AACP,uDAAuD,eAAe,YAAY,UAAU;AAC5F;AACA,KAAK;AACL;AACA;AACA,qCAAqC;;AAErC,oFAAoF,mBAAmB,UAAU;AACjH,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,kBAAkB,+BAA+B;;AAErG;AACA,KAAK;AACL;AACA;AACA,qCAAqC;;AAErC,oFAAoF,mBAAmB,UAAU;AACjH,KAAK;AACL;AACA;;;;;;;;ACvKA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA,2BAA2B,YAAY,eAAe;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;;;;;;;ACnEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,YAAY;AAC9B;AACA,KAAK;AACL;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;;;AAGA;AACA;;AAEA,mDAAmD,YAAY,kDAAkD;AACjH;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP,uDAAuD,eAAe,YAAY,UAAU;AAC5F;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;;;;;;;;ACvEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;ACVA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AChEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA,6C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;AC1JA,yC;;;;;;ACAA,mC;;;;;;;ACAA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;;;;;;;ACxBA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA,4B;;;;;;;ACNA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,eAAe;;AAEpB;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB,oCAAoC;AAC3D;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,uBAAuB,kCAAkC,MAAM,SAAS;;AAExE;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;;AAEA,4BAA4B,kCAAkC,MAAM,SAAS;;AAE7E;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP,wDAAwD,uCAAuC;AAC/F;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA,KAAK,IAAI;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;AC5YA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,WAAW;AACX;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,oCAAoC;AACpC,sFAAsF;AACtF;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,sBAAsB;AACtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,wCAAwC,iCAAiC,EAAE;;AAE3E;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,sDAAsD;AACtD,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA,8DAA8D;AAC9D;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA,2EAA2E;AAC3E,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA,sDAAsD;AACtD,GAAG;;AAEH;AACA;AACA;AACA;;AAEA,iEAAiE;AACjE;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;;AAEP;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA,iFAAiF;AACjF;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA,6DAA6D;AAC7D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA,6FAA6F;AAC7F;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA,kGAAkG;AAClG;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8DAA8D;AAC9D;AACA;AACA,iEAAiE;AACjE;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,GAAG;;AAEH;AACA;AACA;AACA,uCAAuC,2BAA2B;AAClE;AACA;AACA;AACA,GAAG;;AAEH;AACA,gDAAgD,UAAU;AAC1D,gDAAgD,UAAU;AAC1D;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uCAAuC,oBAAoB,GAAG;AAC9D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB,GAAG,IAAI,KAAK,iBAAiB,GAAG,IAAI;AACvE,OAAO;AACP;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,kBAAkB,iBAAiB,GAAG,IAAI,KAAK,MAAM;AACrD,OAAO;;AAEP,8BAA8B,iBAAiB,WAAW,oBAAoB;AAC9E,8BAA8B,gBAAgB,qBAAqB,iBAAiB,UAAU,iBAAiB,OAAO,iBAAiB,GAAG,iBAAiB,OAAO,cAAc;AAChL,8CAA8C,cAAc,gCAAgC,cAAc,4BAA4B;AACtI;AACA,qCAAqC,gBAAgB,IAAI,GAAG,MAAM,uBAAuB,gBAAgB,KAAK;AAC9G;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oEAAoE;AACpE,mDAAmD;;AAEnD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA,sEAAsE;AACtE;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA,gDAAgD,yCAAyC;AACzF,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,+BAA+B;AAC5D,4BAA4B,WAAW;AACvC;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA,4EAA4E;AAC5E;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;;AAEA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,8EAA8E;AAC9E;;AAEA,8BAA8B;AAC9B,GAAG;;AAEH;AACA;AACA;AACA;;AAEA,+BAA+B;AAC/B,GAAG;;AAEH;AACA;AACA,kFAAkF;AAClF;;AAEA,iCAAiC;AACjC,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;AC51BA,mC;;;;;;;ACAA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACxDA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oCAAoC,OAAO;;AAE3C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL,mBAAmB,8BAA8B,EAAE;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,SAAS;AACxD,sBAAsB,aAAa,EAAE,OAAO,qBAAqB;AACjE,WAAW;AACX,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;;;;;ACnLA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA,4B;;;;;;ACNA,mC;;;;;;;ACAA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,eAAe;;AAEpB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,uBAAuB,kCAAkC,MAAM,SAAS;;AAExE;AACA,6BAA6B,gBAAgB;AAC7C,0BAA0B,kCAAkC,MAAM,SAAS;;AAE3E;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iCAAiC;AAChE,yBAAyB,sEAAsE;AAC/F;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA,0DAA0D;;AAE1D;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET,0DAA0D,qCAAqC;AAC/F;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK,IAAI;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;;;;;;;AChQA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;ACjEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,kCAAkC,SAAS;AAC3C;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA,qDAAqD;AACrD;;AAEA;AACA;AACA;AACA,uDAAuD,2DAA2D;AAClH,SAAS;AACT,uDAAuD,mFAAmF;AAC1I;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;;;;;AChMA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA,4B;;;;;;ACNA,+B;;;;;;;ACAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,eAAe;;AAEpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,yBAAyB;AAC/F,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,uBAAuB,8BAA8B,MAAM,SAAS;;AAEpE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,0BAA0B,8BAA8B,MAAM,SAAS;;AAEvE;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,KAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,eAAe;AACf,aAAa;AACb;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gDAAgD,+BAA+B;;AAE/E;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,8DAA8D,6DAA6D;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA,4DAA4D,qCAAqC;AACjG;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;;AAEA;AACA,yPAAyP;AACzP;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;;;;;;AC9WA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;;AAEA;AACA,iCAAiC,YAAY;AAC7C,GAAG;;AAEH;AACA,4BAA4B,QAAQ;AACpC,GAAG;;AAEH;AACA,oCAAoC,OAAO,SAAS;AACpD,GAAG;;AAEH;AACA,iKAAiK;AACjK,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;;AAEA;AACA,KAAK,eAAe;;AAEpB;AACA;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB;;AAEA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,4CAA4C,oCAAoC;AAChF;;AAEA;AACA;AACA,mCAAmC;AACnC;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA,2BAA2B,sFAAsF,EAAE,aAAa,IAAI,kBAAkB,GAAG,iBAAiB;AAC1K,GAAG;;AAEH;AACA;AACA,mCAAmC,2BAA2B,EAAE,mCAAmC;AACnG,GAAG;;AAEH;AACA,4JAA4J;AAC5J,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,uBAAuB,wBAAwB,oBAAoB;AACjG,GAAG;;AAEH;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA,gDAAgD,IAAI,kBAAkB,IAAI;AAC1E,+DAA+D,EAAE;AACjE,4DAA4D,EAAE,sBAAsB;;AAEpF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS,8BAA8B;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,qBAAqB;AACpC,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,kCAAkC,EAAE,iBAAiB;AACrD;AACA,eAAe,aAAa,KAAK,QAAQ;AACzC,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,aAAa,8EAA8E,MAAM,gBAAgB;AACjH;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA,sDAAsD,uBAAuB;AAC7E;AACA;AACA;;AAEA,+BAA+B,YAAY,cAAc,UAAU,GAAG,YAAY;;AAElF;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA,0BAA0B,gBAAgB,eAAe,qBAAqB;AAC9E,GAAG;;AAEH;AACA,0EAA0E;AAC1E;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,uGAAuG;AACvG,SAAS;;AAET,oDAAoD;AACpD,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,kGAAkG,gBAAgB;AAClH;AACA;;AAEA,mCAAmC;AACnC,gDAAgD;;AAEhD;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA,GAAG;;AAEH;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA,0BAA0B,2BAA2B,iBAAiB,uBAAuB;AAC7F,GAAG;;AAEH;AACA;AACA;AACA;;AAEA,iDAAiD,OAAO,aAAa,QAAQ,mBAAmB,KAAK,KAAK,mBAAmB,UAAU,yBAAyB,OAAO,GAAG;AAC1K,GAAG;;AAEH;AACA;;AAEA,oBAAoB,KAAK,kBAAkB,KAAK,QAAQ,MAAM;;AAE9D;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,oEAAoE,iBAAiB;AACrF;AACA;;AAEA;AACA;AACA;AACA,+EAA+E,WAAW;AAC1F;AACA,0CAA0C,UAAU,GAAG,YAAY;AACnE,wGAAwG;AACxG,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,UAAU,EAAE;AACvC;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA,mCAAmC,iCAAiC;AACpE,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA,4BAA4B,gBAAgB,IAAI,cAAc;;AAE9D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,6CAA6C,UAAU,YAAY;AACxF,aAAa,iBAAiB,GAAG,UAAU;AAC3C,gBAAgB,UAAU;AAC1B,aAAa,gBAAgB;AAC7B,+BAA+B,aAAa,GAAG,UAAU,EAAE;AAC3D,GAAG;;AAEH;AACA,2BAA2B,YAAY,MAAM,UAAU,UAAU;AACjE,GAAG;;AAEH;AACA,4BAA4B,eAAe,MAAM,UAAU,aAAa,gBAAgB;AACxF,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA,8BAA8B,aAAa,GAAG,UAAU;AACxD,mBAAmB,WAAW;AAC9B;AACA,aAAa,aAAa;AAC1B,aAAa;AACb,4BAA4B,SAAS,GAAG,iBAAiB;AACzD,GAAG;;AAEH;AACA;AACA;AACA;AACA,4BAA4B,aAAa,GAAG,UAAU,WAAW;AACjE,GAAG;;AAEH;AACA;AACA,6BAA6B,gBAAgB,GAAG,UAAU,cAAc,iBAAiB;AACzF,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iDAAiD,mCAAmC;AACpF,4CAA4C,8BAA8B;AAC1E;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA,wFAAwF,gBAAgB;AACxG;;AAEA;AACA;AACA;AACA,4BAA4B,oBAAoB,GAAG,SAAS;AAC5D,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA,iDAAiD;AACjD,GAAG;;AAEH;AACA,2BAA2B,iBAAiB;AAC5C;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA,iJAAiJ;AACjJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA,uEAAuE,UAAU,0CAA0C;AAC3H,GAAG;;AAEH;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA,oHAAoH;AACpH,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;AC/3BA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;ACtDA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,aAAa;AACpD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA,mCAAmC,gBAAgB;AACnD;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;;;;;ACnGA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA,6B;;;;;;ACNA,oC;;;;;;;ACAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,eAAe;;AAEpB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,sEAAsE,yBAAyB;AAC/F,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,yBAAyB;AAC/F;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8FAA8F,qBAAqB;AACnH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,uBAAuB,gCAAgC,MAAM,SAAS;;AAEtE;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,kCAAkC,iCAAiC,MAAM,UAAU;;AAEnF;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,gCAAgC;AAC7E,uCAAuC,wEAAwE;AAC/G;AACA,uBAAuB;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,mBAAmB;AACnB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,2BAA2B;AAC3B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;;AAEA;AACA;AACA;AACA,yBAAyB;AACzB,uBAAuB;AACvB;;AAEA;AACA,mBAAmB;AACnB;AACA,mBAAmB;AACnB;AACA,mBAAmB;AACnB;AACA,mBAAmB;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,uBAAuB;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6DAA6D,wBAAwB;AACrF;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,iDAAiD;AACpE;AACA,mBAAmB;AACnB;AACA,mBAAmB;AACnB;AACA,mBAAmB;AACnB;AACA,mBAAmB;AACnB;AACA,mBAAmB;AACnB;AACA,mBAAmB;AACnB;AACA,mBAAmB;AACnB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,eAAe;AACf;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wGAAwG,EAAE;AAC1G,wGAAwG,EAAE;;AAE1G;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,4CAA4C;AACvE;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA,0DAA0D,qCAAqC;AAC/F;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA,oBAAoB;AACpB,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;ACxcA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;;AAEA;AACA,4FAA4F;AAC5F,GAAG;;AAEH;AACA,4FAA4F;AAC5F,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,sDAAsD;AACtD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC;AACnC;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA,8CAA8C,MAAM,IAAI,QAAQ,EAAE;AAClE;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA,oDAAoD,IAAI;AACxD,4DAA4D,EAAE,sBAAsB;;AAEpF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS,8BAA8B;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,qBAAqB;AACpC,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,MAAM;;AAE/D;AACA,2BAA2B,aAAa,IAAI,QAAQ;AACpD,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,aAAa,8EAA8E,MAAM,gBAAgB;AACjH;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,qDAAqD,uBAAuB;AAC5E;;AAEA,+BAA+B,uBAAuB,OAAO,WAAW;;AAExE;AACA,GAAG;;AAEH;AACA,4FAA4F;AAC5F,GAAG;;AAEH;AACA;;AAEA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,kIAAkI,oBAAoB;AACtJ;;AAEA,qBAAqB,2BAA2B,OAAO,iBAAiB,GAAG,gCAAgC;AAC3G,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,0BAA0B,2BAA2B,EAAE,YAAY;AACnE,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA,gCAAgC,gBAAgB,IAAI,cAAc;;AAElE;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA,gCAAgC,2BAA2B;AAC3D,GAAG;;AAEH;AACA,gEAAgE,UAAU;;AAE1E;AACA,gCAAgC,eAAe;AAC/C;;AAEA,mBAAmB;AACnB,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA,mCAAmC,gCAAgC;AACnE,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uCAAuC,EAAE;AACzE,GAAG;;AAEH;AACA,4DAA4D,UAAU,EAAE;AACxE,GAAG;;AAEH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB,sBAAsB,UAAU,eAAe,QAAQ,iBAAiB;AAC/F,sBAAsB,iBAAiB;AACvC;AACA,uBAAuB,gBAAgB,UAAU,eAAe,QAAQ,uBAAuB;AAC/F,sBAAsB,uBAAuB;AAC7C,GAAG;;AAEH;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA,kDAAkD,gBAAgB,mBAAmB,sBAAsB;AAC3G,uBAAuB,sBAAsB,UAAU,eAAe,QAAQ,iBAAiB;AAC/F,sBAAsB,iBAAiB;AACvC,uBAAuB,sBAAsB,aAAa,iBAAiB;AAC3E,GAAG;;AAEH;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,sBAAsB,UAAU,qBAAqB,QAAQ,iBAAiB;AACrG,sBAAsB,iBAAiB;AACvC;AACA,uBAAuB,gBAAgB,UAAU,qBAAqB,QAAQ,uBAAuB;AACrG,sBAAsB,uBAAuB;AAC7C,GAAG;;AAEH;AACA;AACA,uEAAuE;AACvE;;AAEA,+DAA+D;AAC/D,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA,sCAAsC,UAAU;AAChD;AACA;;AAEA;;;;;;;ACreA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA,6B;;;;;;ACNA,kBAAkB,iJAAiJ,mDAAmD,EAAE,sEAAsE,EAAE,uDAAuD,EAAE,4DAA4D,EAAE,4DAA4D,gBAAgB,gEAAgE,SAAS,sDAAsD,iBAAiB,6WAA6W,oBAAoB,2pBAA2pB,mIAAmI,2gHAA2gH,YAAY,iBAAiB,2BAA2B,cAAc,oD;;;;;;;ACAn2K,mBAAA5H,CAAQ,EAAR,EAAkBC,MAAlB;;mBAWIkE,QAAQjE,G;yCARV2H,gB;IAAAA,gB,yCAAmB,O;0CACnBC,gB;IAAAA,gB,0CAAmB,a;0CACnBC,a;IAAAA,a,0CAAgB,W;0CAChBC,a;IAAAA,a,0CAAgB,I;0CAChBC,a;IAAAA,a,0CAAgB,O;IAChBC,a,gBAAAA,a;IACAC,iB,gBAAAA,iB;IACAC,Y,gBAAAA,Y;;;AAGF,IAAIC,OAAO;AACT,cAAYH,aADH;AAET,cAAYC,iBAFH;AAGT,cAAYF,aAHH;AAIT,UAAQF,aAJC;AAKT,UAAQC,aALC;AAMT,aAAWH,gBANF;AAOT,aAAWC,gBAPF;AAQT,SAAOM;AARE,CAAX;;AAWA,yDAAe;AACb,iBAAeC,IADF;AAEb,UAAQA,IAFK;AAGb,gBAAcA;AAHD,CAAf,E;;;;;;;ACxBA;;AAEA,yDAAe,UAAStH,SAAT,EAAoBuH,SAApB,EAA+B;AAC5C,MAAIlG,YAAYrB,UAAUL,MAAV,CAAiB,WAAjB,EAA8B;AAC5CoB,QAAI;AACFyG,YAAMD,UAAUE,OAAV,CAAkB,EAAlB,CADJ;AAEFC,iBAAW,KAFT;AAGFC,kBAAY,IAHV;AAIFC,qBAAe;AAJb,KADwC;AAO5CrG,YAAQ;AACNiG,YAAMD,UAAUE,OAAV,CAAkB,CAAlB,CADA;AAENC,iBAAW,KAFL;AAGNG,oBAAc;AAHR,KAPoC;AAY5CrG,aAAS;AACPgG,YAAMD,UAAUE,OAAV,CAAkB,EAAlB,CADC;AAEPC,iBAAW;AAFJ,KAZmC;AAgB5CjG,WAAO;AACL+F,YAAMD,UAAUO,MAAV,CAAiB,KAAjB,CADD;AAELJ,iBAAW,IAFN;AAGLG,oBAAc;AAHT,KAhBqC;AAqB5CnG,eAAW;AACT8F,YAAMD,UAAUE,OAAV,CAAkB,EAAlB,CADG;AAETC,iBAAW,KAFF;AAGTG,oBAAc;AAHL;AArBiC,GAA9B,EA0Bb;AACDE,eAAW;AADV,GA1Ba,CAAhB;;AA8BA1G,YAAUT,SAAV,GAAsB,UAASI,MAAT,EAAiB;AACrCK,cAAU2G,SAAV,CAAoBhH,OAAOC,KAA3B,EAAkC,EAACgH,YAAY,SAAb,EAAlC;AACA5G,cAAU2G,SAAV,CAAoBhH,OAAOwF,KAA3B,EAAkC,EAACyB,YAAY,WAAb,EAAlC;AACD,GAHD;;AAKA,SAAO5G,SAAP;AACD,I;;;;;;;ACvCD;;AAEA,yDAAe,UAASrB,SAAT,EAAoBuH,SAApB,EAA+B;AAC5C,MAAItG,QAAQjB,UAAUL,MAAV,CAAiB,OAAjB,EAA0B;AACpCoB,QAAI;AACFyG,YAAMD,UAAUE,OAAV,CAAkB,EAAlB,CADJ;AAEFC,iBAAW,KAFT;AAGFC,kBAAY,IAHV;AAIFC,qBAAe;AAJb,KADgC;AAOpCnF,WAAO;AACL+E,YAAMD,UAAUO,MAAV,CAAiB,EAAjB,CADD;AAELJ,iBAAW;AAFN,KAP6B;AAWpCQ,WAAO;AACLV,YAAMD,UAAUO,MAAV,CAAiB,EAAjB,CADD;AAELJ,iBAAW,IAFN;AAGLG,oBAAc;AAHT,KAX6B;AAgBpC3I,YAAQ;AACNsI,YAAMD,UAAUO,MAAV,CAAiB,GAAjB,CADA;AAENJ,iBAAW,KAFL;AAGNG,oBAAc;AAHR,KAhB4B;AAqBpCpG,WAAO;AACL+F,YAAMD,UAAUO,MAAV,CAAiB,KAAjB,CADD;AAELJ,iBAAW;AAFN,KArB6B;AAyBpChG,eAAW;AACT8F,YAAMD,UAAUE,OAAV,CAAkB,EAAlB,CADG;AAETC,iBAAW,KAFF;AAGTG,oBAAc;AAHL,KAzByB;AA8BpCM,gBAAY;AACVX,YAAMD,UAAUE,OAAV,CAAkB,CAAlB,CADI;AAEVC,iBAAW,KAFD;AAGVG,oBAAc;AAHJ,KA9BwB;AAmCpC1G,eAAW;AACTqG,YAAMD,UAAUE,OAAV,CAAkB,CAAlB,CADG;AAETC,iBAAW,KAFF;AAGTG,oBAAc;AAHL,KAnCyB;AAwCpCO,gBAAY;AACVZ,YAAMD,UAAUc,IADN;AAEVX,iBAAW,IAFD;AAGVG,oBAAc7H,UAAUsI;AAHd;AAxCwB,GAA1B,EA6CT;AACDP,eAAW;AADV,GA7CS,CAAZ;;AAiDA9G,QAAML,SAAN,GAAkB,UAASI,MAAT,EAAiB;AACjCC,UAAMsH,MAAN,CAAavH,OAAOK,SAApB,EAA+B,EAAC4G,YAAY,SAAb,EAA/B;AACAhH,UAAM+G,SAAN,CAAgBhH,OAAOwF,KAAvB,EAA8B,EAACyB,YAAY,WAAb,EAA9B;AACD,GAHD;;AAKA,SAAOhH,KAAP;AACD,I;;;;;;;AC1DD;;AAEA,yDAAe,UAASjB,SAAT,EAAoBuH,SAApB,EAA+B;AAC5C,MAAIf,QAAQxG,UAAUL,MAAV,CAAiB,OAAjB,EAA0B;AACpCoB,QAAI;AACFyG,YAAMD,UAAUE,OAAV,CAAkB,EAAlB,CADJ;AAEFC,iBAAW,KAFT;AAGFC,kBAAY,IAHV;AAIFC,qBAAe;AAJb,KADgC;AAOpCnH,UAAM;AACJ+G,YAAMD,UAAUO,MAAV,CAAiB,EAAjB,CADF;AAEJJ,iBAAW;AAFP,KAP8B;AAWpCc,WAAO;AACLhB,YAAMD,UAAUO,MAAV,CAAiB,EAAjB,CADD;AAELJ,iBAAW;AAFN,KAX6B;AAepCe,eAAW;AACTjB,YAAMD,UAAUE,OAAV,CAAkB,EAAlB,CADG;AAETC,iBAAW,KAFF;AAGTG,oBAAc;AAHL,KAfyB;AAoBpCa,YAAQ;AACNlB,YAAMD,UAAUO,MAAV,CAAiB,EAAjB,CADA;AAENJ,iBAAW,IAFL;AAGNG,oBAAc;AAHR;AApB4B,GAA1B,EAyBT;AACDE,eAAW;AADV,GAzBS,CAAZ;;AA6BAvB,QAAM5F,SAAN,GAAkB,UAASI,MAAT,EAAiB;AACjCwF,UAAM+B,MAAN,CAAavH,OAAOK,SAApB,EAA+B,EAAC4G,YAAY,WAAb,EAA/B;AACAzB,UAAM+B,MAAN,CAAavH,OAAOC,KAApB,EAA2B,EAACgH,YAAY,WAAb,EAA3B;AACD,GAHD;;AAKA,SAAOzB,KAAP;AACD,I;;;;;;;;;;;;;;;;;;;;ACtCD;;;AAGE,oBAAc;AAAA;;AACZ,SAAKvG,GAAL,GAAW,QAAX;AACD;;;;;gLAESa,G;;;;;;;;uBACa,wDAAAE,CAAOC,KAAP,CAAac,OAAb,CAAqB;AACxCiB,8BAAY,CACV,CAAC,wDAAAhC,CAAOhB,SAAP,CAAiB2I,EAAjB,CAAoB,OAApB,EAA6B,wDAAA3H,CAAOhB,SAAP,CAAiB4I,OAAjB,CAAyB,+CAAzB,CAA7B,CAAD,EAA0G,SAA1G,CADU,EAEV,CAAC,wDAAA5H,CAAOhB,SAAP,CAAiB2I,EAAjB,CAAoB,OAApB,EAA6B,wDAAA3H,CAAOhB,SAAP,CAAiB4I,OAAjB,CAAyB,+CAAzB,CAA7B,CAAD,EAA0G,WAA1G,CAFU,CAD4B;AAKxCxH,yBAAO;AACLD,+BAAW;AADN;AALiC,iBAArB,C;;;;;AAAhBa,sB;;;AAULlB,oBAAIe,IAAJ,GAAWG,MAAX;;;;;;;;;;;;;;;;;;;;;;AAGH,C;;;;;;;;;;;;;;;;;;;;ACrBD;AACA;;;AAGE,oBAAc;AAAA;;AACZ,SAAK/B,GAAL,GAAW,QAAX;AACD;;;;;gLAEUa,G;;;;;;;;uBACqB,oDAAA+H,CAAY/H,IAAI4D,GAAhB,C;;;;AAAvBoE,qB,SAAAA,K;AAAOC,sB,SAAAA,M;;uBAEQ,qEAAAC,CAAOF,KAAP,C;;;AAAlBG,yB;;;AAEJnI,oBAAIe,IAAJ,GAAWoH,SAAX;;;;;;;;;;;;;;;;;;;;;;AAGH,C;;;;;;AChBD,yC;;;;;;;;;;;;;;;ACAA,mBAAAhK,CAAQ,EAAR,EAAkBC,MAAlB;AACA,IAAMgK,IAAI,mBAAAjK,CAAQ,CAAR,CAAV;AACA,IAAMkK,QAAQ,mBAAAlK,CAAQ,GAAR,CAAd;;mBAOImE,QAAQjE,G;IAJViK,gB,gBAAAA,gB;IACAC,gB,gBAAAA,gB;IACAC,Y,gBAAAA,Y;IACAC,a,gBAAAA,a;;;AAGFJ,MAAMK,IAAN,CAAWC,UAAX,GAAwBL,gBAAxB;AACAD,MAAMK,IAAN,CAAWE,UAAX,GAAwBL,gBAAxB;;AAEA,IAAMM,aAAa,SAAbA,UAAa,CAACC,GAAD,EAAS;AAC1B,MAAIV,EAAEW,OAAF,CAAUD,GAAV,CAAJ,EAAoB;;AAEpB,MAAME,YAAY,IAAIX,MAAMY,EAAN,CAASC,SAAb,CAA0BV,YAA1B,SAA0CM,GAA1C,CAAlB;AACA,SAAOE,UAAUG,KAAV,EAAP;AACD,CALD;;AAOA,IAAMjB,SAAS,SAATA,MAAS,CAACkB,OAAD,EAAUC,SAAV,EAAwB;;AAErC,MAAIjB,EAAEW,OAAF,CAAUK,OAAV,CAAJ,EAAwB;;AAExB,MAAME,QAAQ,IAAIjB,MAAMkB,EAAN,CAASC,QAAb,EAAd;;AAEA,SAAO,IAAInG,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACtC8E,UAAMkB,EAAN,CAASE,OAAT,CAAiBL,OAAjB,EAA0BC,SAA1B,EAAqCA,SAArC,EAAgDC,KAAhD,EAAuD,UAAC5E,GAAD,EAAMgF,GAAN,EAAc;AACnE,UAAI,CAAChF,GAAL,EAAU;AACRpB,gBAAQ;AACNqG,gBAAMD,IAAIC,IADJ;AAENb,eAAKY,IAAIZ,GAFH;AAGN3J,eAAQsJ,aAAR,SAAyBiB,IAAIZ;AAHvB,SAAR;AAKD,OAND,MAMO;AACL3E,gBAAQM,GAAR,CAAY,cAAZ,EAA4BC,GAA5B,EAAiC2E,SAAjC;AACA9F,eAAOmB,GAAP;AACD;AACF,KAXD;AAYD,GAbM,CAAP;AAcD,CApBD;;AAsBA;AAAA,2JAAe,iBAAOsD,KAAP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBAGXM,qBAAqB,eAArB,IACAC,qBAAqB,eADrB,IAEAC,iBAAiB,mBAFjB,IAGAC,kBAAkB,gBANP;AAAA;AAAA;AAAA;;AAAA,kBAQL,EAAErH,QAAQ,GAAV,EAAezB,MAAM,qBAArB,EAA4CqB,SAAS,gGAArD,EARK;;AAAA;AAWT4I,iBAXS,GAWD5B,MAAM6B,GAAN,CAAU,UAACC,IAAD,EAAOhB,GAAP;AAAA,qBAAeZ,OAAOW,WAAWiB,KAAKC,IAAhB,CAAP,EAA8BD,KAAKC,IAAnC,CAAf;AAAA,aAAV,CAXC;AAAA;AAAA,mBAaA1G,QAAQ2G,GAAR,CAAYJ,KAAZ,CAbA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAf;;AAAA;AAAA;AAAA;AAAA,M;;;;;;AC3CA,kC;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;;;AAGE,oBAAc;AAAA;;AACZ,SAAKzK,GAAL,GAAW,QAAX;AACD;;;;;gLAESa,G;;;;;;;6BAC+BA,IAAIkF,K,EAArC/D,I,cAAAA,I,EAAMgE,I,cAAAA,I,EAAMxD,K,cAAAA,K,EAAOsI,S,cAAAA,S;;AACzB9I,uBAAOiE,SAASjE,IAAT,EAAe,EAAf,CAAP;AACAgE,uBAAOC,SAASD,IAAT,EAAe,EAAf,CAAP;AACIE,qB,GAAQ,CAAClE,OAAO,CAAR,IAAagE,I;AACrBG,qB,GAAQH,I;AACR7E,qB,GAAQ;AACVD,6BAAW;AADD,iB;;AAGZ,oBAAIsB,KAAJ,EAAW;AACTrB,wBAAM,OAAN,IAAiB;AACfiF,iCAAW5D,KAAX;AADe,mBAAjB;AAGD;AACD,oBAAIsI,aAAa,CAAC,CAAlB,EAAqB;AACnB3J,wBAAM,YAAN,IAAsB2J,SAAtB;AACD;;uBACkB,wDAAA/J,CAAOC,KAAP,CAAaqF,eAAb,CAA6B;AAC9CC,2BAAS,CACP;AACE/F,2BAAO,wDAAAQ,CAAOwF,KADhB;AAEExD,gCAAY,CAAC,MAAD;AAFd,mBADO,CADqC;AAO9CyD,0BAAQN,KAPsC;AAQ9CC,yBAAOA,KARuC;AAS9ChF,yBAAOA,KATuC;AAU9CsF,yBAAO,CAAC,CAAC,WAAD,EAAc,MAAd,CAAD;AAVuC,iBAA7B,C;;;AAAf1E,sB;;;AAaJlB,oBAAIe,IAAJ,GAAW;AACT8E,yBAAO3E,OAAOO,KADL;AAETN,wBAAMA,IAFG;AAGTgE,wBAAMA,IAHG;AAITW,wBAAM5E,OAAO6E;AAJJ,iBAAX;;;;;;;;;;;;;;;;;;;kLAQQ/F,G;;;;;;;oCACsCA,IAAIuB,OAAJ,CAAYR,I,4CAApDY,K,EAAAA,K,yCAAQ,E,oEAAIvD,M,EAAAA,M,yCAAS,E,oEAAIuC,K,EAAAA,K,yCAAQ,E;;AACvCgB,wBAAQA,MAAMC,IAAN,EAAR;;oBACKD,K;;;;;sBAAa,EAAEP,QAAQ,GAAV,EAAezB,MAAM,cAArB,EAAqCqB,SAAS,YAA9C,E;;;AAClBL,wBAAQU,KAAKQ,SAAL,CAAelB,KAAf,CAAR;;sBACIA,MAAMmB,MAAN,GAAe,2DAAAC,CAAGC,gB;;;;;sBAAwB,2DAAAD,CAAGE,c;;;AACjD7D,yBAASiD,KAAKQ,SAAL,CAAezD,MAAf,CAAT;;;uBAE4B,wDAAA8B,CAAOC,KAAP,CAAa+J,YAAb,CAA0B;AACpD5J,yBAAO;AACLD,+BAAW,CADN;AAELsB,2BAAOA;AAFF,mBAD6C;AAKpDwI,4BAAU;AACRxI,2BAAOA,KADC;AAERvD,4BAAQA,MAFA;AAGRuC,2BAAOA,KAHC;AAIRC,+BAAWZ,IAAIa,KAAJ,CAAUC,IAAV,CAAeb;AAJlB;AAL0C,iBAA1B,C;;;;;AAAvBkB,oB;AAAMiJ,uB;;sBAaPjJ,QAAQ,CAACiJ,O;;;;;sBACL,EAAEhJ,QAAQ,GAAV,EAAezB,MAAM,KAArB,EAA4BqB,SAAS,OAArC,E;;;;uBAGF,wDAAAd,CAAOK,SAAP,CAAiBC,MAAjB,CAAwB;AAC5BC,0BAAQ,CADoB;AAE5BC,2BAASS,KAAKlB,EAFc;AAG5BU,yBAAOA,KAHqB;AAI5BC,6BAAWZ,IAAIa,KAAJ,CAAUC,IAAV,CAAeb;AAJE,iBAAxB,C;;;;AAOND,oBAAIe,IAAJ,GAAW;AACTC,2BAAS,cADA;AAETqJ,wBAAMlJ;AAFG,iBAAX;;;;;;;;;;;;;;;;;;;;;;AAMH,C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpFD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAMmJ,WAAW,SAAjB;;;AAGE,oBAAc;AAAA;;AACZ,SAAKnL,GAAL,GAAW,cAAX;AACD;;;;;gLAESa,G;;;;;;;;uBAEF,IAAI,sDAAJ,GAAcuK,GAAd,CAAkBvK,GAAlB,C;;;AAEAC,kB,GAAOD,IAAIzB,M,CAAX0B,E;;uBAEa,wDAAAC,CAAOC,KAAP,CAAac,OAAb,CAAqB;AACtCX,yBAAO;AACLD,+BAAW,CADN;AAELJ,wBAAIA;AAFC;AAD+B,iBAArB,C;;;;;AAAdkB,oB;;oBAOAA,I;;;;;sBAAY,EAAEC,QAAQ,GAAV,EAAezB,MAAM,iBAArB,EAAwCqB,SAAS,mBAAjD,E;;;;uBAEX,wDAAAd,CAAOC,KAAP,CAAaC,MAAb,CAAoB;AACxBiH,8BAAY,CADY;AAExBC,8BAAYkD,KAAKC,GAAL;AAFY,iBAApB,EAGH;AACDnK,yBAAO;AACLL,wBAAIA;AADC;AADN,iBAHG,C;;;;uBASA,wDAAAC,CAAOK,SAAP,CAAiBC,MAAjB,CAAwB;AAC5BC,0BAAQ,CADoB;AAE5BC,2BAAST,EAFmB;AAG5BU,yBAAO,IAHqB;AAI5BC,6BAAWZ,IAAIa,KAAJ,CAAUC,IAAV,CAAeb;AAJE,iBAAxB,C;;;AAOAyK,mB,eAAgBzK,E;;;AAEtB,oBAAI,CAAC,0CAAA0K,CAAGC,UAAH,CAAcF,GAAd,CAAL,EAAyB;;AAEvBG,kBAAA,8CAAAA,CAAOH,GAAP,EAAY,UAAUhG,GAAV,EAAe;AACzB,wBAAIA,GAAJ,EAAS;AACPP,8BAAQC,KAAR,CAAcM,GAAd;AACD;AACF,mBAJD;AAKD;;;;AAGCvD,qBAAK/C,MAAL,GAAciD,KAAKC,KAAL,CAAWH,KAAK/C,MAAhB,CAAd;AACA+C,qBAAKR,KAAL,GAAaU,KAAKC,KAAL,CAAWH,KAAKR,KAAhB,CAAb;;;;;;;sBAEM,EAAES,QAAQ,GAAV,EAAezB,MAAM,kBAArB,EAAyCqB,SAAS,kBAAlD,E;;;AACP;;AAEG8J,uB,mCAAwC7K,E;AAExC8K,uB,GAAU;AACZC,8BAAY;AACVC,2BAAO,GADG;AAEVC,4BAAQ;AAFE,mBADA;AAKZC,4BAAU;AACRF,2BAAO,GADC;AAERC,4BAAQ;AAFA,mBALE;AASZE,6BAAW,oEACP;AAVQ,iB;;;AAadC,gBAAA,+CAAAA,CAAQP,OAAR,EAAoBJ,GAApB,iBAAqCK,OAArC,EAA8C,UAASrG,GAAT,EAAc;AAC1D,sBAAGA,GAAH,EAAQ;AACN,0BAAM,EAAEtD,QAAQ,GAAV,EAAezB,MAAM,aAArB,EAAoCqB,SAAS,gBAA7C,EAAN;AACD;;AAEDkH,kBAAA,qEAAAA,CAAO,CAAC,0CAAAyC,CAAGW,gBAAH,CAAuBZ,GAAvB,gBAAD,CAAP,EAAkD5G,IAAlD,CAAuD,UAACyH,QAAD,EAAc;AACnErL,oBAAA,wDAAAA,CAAOC,KAAP,CAAaC,MAAb,CAAoB;AAClBgH,6BAAOkD,WAAWiB,SAAS,CAAT,EAAYpM;AADZ,qBAApB,EAEG;AACDmB,6BAAO;AACLL,4BAAIA;AADC;AADN,qBAFH;AAOD,mBARD;AASD,iBAdD;;AAgBAD,oBAAIe,IAAJ,GAAW;AACT5B,uBAAK2L;AADI,iBAAX;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/FJ,mC;;;;;;ACAA,oC;;;;;;;;;;;;;;;;;;ACAA;;;AAGE,oBAAc;AAAA;;AACZ,SAAK3L,GAAL,GAAW,QAAX;AACD;;;;;gLAESa,G;;;;;;;uBACU,wDAAAE,CAAOwF,KAAP,CAAazE,OAAb,E;;;AAAdyE,qB;;AACJ1F,oBAAIe,IAAJ,GAAW2E,KAAX;;;;;;;;;;;;;;;;;;;;;;AAGH,C;;;;;;ACZD,wC;;;;;;ACAA,2C;;;;;;;;;;;;;;;ACAA,mBAAAvH,CAAQ,EAAR,EAAkBC,MAAlB;AACA,IAAMuE,WAAW,mBAAAxE,CAAQ,EAAR,CAAjB;AACA;;AAEAwE,SAAS6I,aAAT,CAAuB,UAAS1K,IAAT,EAAe2K,IAAf,EAAqB;AAC1CA,OAAK,IAAL,EAAW3K,KAAKb,EAAhB;AACD,CAFD;;AAIA0C,SAAS+I,eAAT;AAAA,2JAAyB,iBAAezL,EAAf,EAAmBwL,IAAnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAEF,wDAAAvL,CAAOwF,KAAP,CAAaiG,QAAb,CAAsB1L,EAAtB,CAFE;;AAAA;AAEfa,gBAFe;;AAGrB2K,iBAAK,IAAL,EAAW3K,IAAX;AAHqB;AAAA;;AAAA;AAAA;AAAA;;AAKrB2K;;AALqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAzB;;AAAA;AAAA;AAAA;AAAA;;AASA,IAAMG,iBAAiB,mBAAAzN,CAAQ,GAAR,EAA2B0N,QAAlD;AACAlJ,SAASD,GAAT,CAAa,IAAIkJ,cAAJ,CAAmB;AAC5BE,YAAUxJ,QAAQjE,GAAR,CAAY0N,gBADM;AAE5BC,gBAAc1J,QAAQjE,GAAR,CAAY4N,oBAFE;AAG5BC,eAAa5J,QAAQjE,GAAR,CAAY8N;AAHG,CAAnB,EAKX,UAASC,WAAT,EAAsBC,YAAtB,EAAoCC,OAApC,EAA6CC,EAA7C,EAAiD;AAAA,uBAM3CD,QAAQE,KANmC;AAAA,MAE7C7M,IAF6C,kBAE7CA,IAF6C;AAAA,MAG7C+H,KAH6C,kBAG7CA,KAH6C;AAAA,MAI7CzH,EAJ6C,kBAI7CA,EAJ6C;AAAA,MAK7CwM,UAL6C,kBAK7CA,UAL6C;;AAO/CvM,EAAA,wDAAAA,CAAOwF,KAAP,CAAawE,YAAb,CAA0B,EAAC5J,OAAO,EAACqH,WAAW1H,EAAZ,EAAR,EAAyBkK,UAAU;AAC3DxK,YAAMA,IADqD;AAE3D+H,aAAOA,KAFoD;AAG3DE,cAAQ6E;AAHmD,KAAnC,EAA1B,EAIIC,MAJJ,CAIW,UAAC5L,IAAD,EAAOsJ,OAAP;AAAA,WAAmBmC,GAAG,IAAH,EAASzL,IAAT,CAAnB;AAAA,GAJX,EAI8CiD,KAJ9C,CAIoD,eAAO;AACzDI,YAAQM,GAAR,CAAYC,GAAZ;AACD,GAND;AAOD,CAnBU,CAAb,E;;;;;;AClBA,4C;;;;;;ACAA,IAAMqF,OAAO,mBAAA5L,CAAQ,EAAR,CAAb;;AAEAwO,OAAOC,OAAP,GAAiB;AACfC,UAAQ,SADO;AAEf;;;AAGA/J,UAAQ;AACNgK,gBAAY,CACV,YADU;AADN,GALO;AAUf;;;AAGAC,QAAM;AACJpL,WAAO,OADH;AAEJqL,UAAM,CACJ,EAAEC,SAAS,OAAX,EADI,EAEJ,EAAEC,KAAK,UAAP,EAAmBvN,MAAM,UAAzB,EAAqCwN,SAAS,qCAA9C,EAFI,EAGJ,EAAED,KAAK,aAAP,EAAsBvN,MAAM,aAA5B,EAA2CwN,SAAS,qDAApD,EAHI,CAFF;AAOJC,UAAM,CACJ,EAAEC,KAAK,MAAP,EAAe3G,MAAM,cAArB,EAAqC4G,MAAM,cAA3C,EADI;AAPF,GAbS;AAwBf;;;AAGAC,OAAK,CACH,mBADG,CA3BU;AA8Bf;;;AAGAC,WAAS,EAAEC,OAAO,SAAT,EAjCM;AAkCf;;;AAGAvJ,SAAO;AACLwJ,YAAQ,CACN,OADM,EAEN,YAFM,EAGN,YAHM,EAIN,QAJM,EAKN,OALM,EAMN,eANM;AADH,GArCQ;AA+CfC,WAAS,CACP,sBADO,EAEP,yBAFO,EAGP,0BAHO;AA/CM,CAAjB,C","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 43);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c7e17ba4f7ba134d1a93","module.exports = require(\"lodash\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash\"\n// module id = 0\n// module chunks = 0","'use strict';\n\nconst DataTypes = require('./data-types');\nconst SqlString = require('./sql-string');\nconst _ = require('lodash').runInContext(); // Prevent anyone messing with template settings by creating a fresh copy\nconst parameterValidator = require('./utils/parameter-validator');\nconst Logger = require('./utils/logger');\nconst uuid = require('uuid');\nconst Promise = require('./promise');\nconst primitives = ['string', 'number', 'boolean'];\n\nlet inflection = require('inflection');\nconst logger = new Logger();\n\nexports.Promise = Promise;\nexports._ = _;\nexports.debug = logger.debug.bind(logger);\nexports.deprecate = logger.deprecate.bind(logger);\nexports.warn = logger.warn.bind(logger);\nexports.getLogger = () =>  logger ;\n\nfunction useInflection(_inflection) {\n  inflection = _inflection;\n}\nexports.useInflection = useInflection;\n\nfunction camelizeIf(str, condition) {\n  let result = str;\n\n  if (condition) {\n    result = camelize(str);\n  }\n\n  return result;\n}\nexports.camelizeIf = camelizeIf;\n\nfunction underscoredIf(str, condition) {\n  let result = str;\n\n  if (condition) {\n    result = underscore(str);\n  }\n\n  return result;\n}\nexports.underscoredIf = underscoredIf;\n\nfunction isPrimitive(val) {\n  return primitives.indexOf(typeof val) !== -1;\n}\nexports.isPrimitive = isPrimitive;\n\n// Same concept as _.merge, but don't overwrite properties that have already been assigned\nfunction mergeDefaults(a, b) {\n  return _.mergeWith(a, b, objectValue => {\n    // If it's an object, let _ handle it this time, we will be called again for each property\n    if (!this._.isPlainObject(objectValue) && objectValue !== undefined) {\n      return objectValue;\n    }\n  });\n}\nexports.mergeDefaults = mergeDefaults;\n\n// An alternative to _.merge, which doesn't clone its arguments\n// Cloning is a bad idea because options arguments may contain references to sequelize\n// models - which again reference database libs which don't like to be cloned (in particular pg-native)\nfunction merge() {\n  const result = {};\n\n  for (const obj of arguments) {\n    _.forOwn(obj, (value, key) => {\n      if (typeof value !== 'undefined') {\n        if (!result[key]) {\n          result[key] = value;\n        } else if (_.isPlainObject(value) && _.isPlainObject(result[key])) {\n          result[key] = merge(result[key], value);\n        } else if (Array.isArray(value) && Array.isArray(result[key])) {\n          result[key] = value.concat(result[key]);\n        } else {\n          result[key] = value;\n        }\n      }\n    });\n  }\n\n  return result;\n}\nexports.merge = merge;\n\nfunction lowercaseFirst(s) {\n  return s[0].toLowerCase() + s.slice(1);\n}\nexports.lowercaseFirst = lowercaseFirst;\n\nfunction uppercaseFirst(s) {\n  return s[0].toUpperCase() + s.slice(1);\n}\nexports.uppercaseFirst = uppercaseFirst;\n\nfunction spliceStr(str, index, count, add) {\n  return str.slice(0, index) + add + str.slice(index + count);\n}\nexports.spliceStr = spliceStr;\n\nfunction camelize(str) {\n  return str.trim().replace(/[-_\\s]+(.)?/g, (match, c) => c.toUpperCase());\n}\nexports.camelize = camelize;\n\nfunction underscore(str) {\n  return inflection.underscore(str);\n}\nexports.underscore = underscore;\n\nfunction format(arr, dialect) {\n  const timeZone = null;\n  // Make a clone of the array beacuse format modifies the passed args\n  return SqlString.format(arr[0], arr.slice(1), timeZone, dialect);\n}\nexports.format = format;\n\nfunction formatNamedParameters(sql, parameters, dialect) {\n  const timeZone = null;\n  return SqlString.formatNamedParameters(sql, parameters, timeZone, dialect);\n}\nexports.formatNamedParameters = formatNamedParameters;\n\nfunction cloneDeep(obj) {\n  obj = obj || {};\n  return _.cloneDeepWith(obj, elem => {\n    // Do not try to customize cloning of arrays or POJOs\n    if (Array.isArray(elem) || _.isPlainObject(elem)) {\n      return undefined;\n    }\n\n    // Don't clone stuff that's an object, but not a plain one - fx example sequelize models and instances\n    if (typeof elem === 'object') {\n      return elem;\n    }\n\n    // Preserve special data-types like `fn` across clones. _.get() is used for checking up the prototype chain\n    if (elem && typeof elem.clone === 'function') {\n      return elem.clone();\n    }\n  });\n}\nexports.cloneDeep = cloneDeep;\n\n/* Expand and normalize finder options */\nfunction mapFinderOptions(options, Model) {\n  if (Model._hasVirtualAttributes && Array.isArray(options.attributes)) {\n    for (const attribute of options.attributes) {\n      if (Model._isVirtualAttribute(attribute) && Model.rawAttributes[attribute].type.fields) {\n        options.attributes = options.attributes.concat(Model.rawAttributes[attribute].type.fields);\n      }\n    }\n    options.attributes = _.without.apply(_, [options.attributes].concat(Model._virtualAttributes));\n    options.attributes = _.uniq(options.attributes);\n  }\n\n  mapOptionFieldNames(options, Model);\n\n  return options;\n}\nexports.mapFinderOptions = mapFinderOptions;\n\n/* Used to map field names in attributes and where conditions */\nfunction mapOptionFieldNames(options, Model) {\n  if (Array.isArray(options.attributes)) {\n    options.attributes = options.attributes.map(attr => {\n      // Object lookups will force any variable to strings, we don't want that for special objects etc\n      if (typeof attr !== 'string') return attr;\n      // Map attributes to aliased syntax attributes\n      if (Model.rawAttributes[attr] && attr !== Model.rawAttributes[attr].field) {\n        return [Model.rawAttributes[attr].field, attr];\n      }\n      return attr;\n    });\n  }\n\n  if (options.where && _.isPlainObject(options.where)) {\n    options.where = mapWhereFieldNames(options.where, Model);\n  }\n\n  return options;\n}\nexports.mapOptionFieldNames = mapOptionFieldNames;\n\nfunction mapWhereFieldNames(attributes, Model) {\n  let attribute;\n  let rawAttribute;\n\n  if (attributes) {\n    for (attribute in attributes) {\n      rawAttribute = Model.rawAttributes[attribute];\n\n      if (rawAttribute && rawAttribute.field !== rawAttribute.fieldName) {\n        attributes[rawAttribute.field] = attributes[attribute];\n        delete attributes[attribute];\n      }\n\n      if (_.isPlainObject(attributes[attribute])\n        && !(rawAttribute && (\n          rawAttribute.type instanceof DataTypes.HSTORE\n          || rawAttribute.type instanceof DataTypes.JSON))) { // Prevent renaming of HSTORE & JSON fields\n        attributes[attribute] = mapOptionFieldNames({\n          where: attributes[attribute]\n        }, Model).where;\n      }\n\n      if (Array.isArray(attributes[attribute])) {\n        attributes[attribute] = attributes[attribute].map(where => {\n          if (_.isPlainObject(where)) {\n            return mapWhereFieldNames(where, Model);\n          }\n\n          return where;\n        });\n      }\n    }\n  }\n\n  return attributes;\n}\nexports.mapWhereFieldNames = mapWhereFieldNames;\n\n/* Used to map field names in values */\nfunction mapValueFieldNames(dataValues, fields, Model) {\n  const values = {};\n\n  for (const attr of fields) {\n    if (dataValues[attr] !== undefined && !Model._isVirtualAttribute(attr)) {\n      // Field name mapping\n      if (Model.rawAttributes[attr] && Model.rawAttributes[attr].field && Model.rawAttributes[attr].field !== attr) {\n        values[Model.rawAttributes[attr].field] = dataValues[attr];\n      } else {\n        values[attr] = dataValues[attr];\n      }\n    }\n  }\n\n  return values;\n}\nexports.mapValueFieldNames = mapValueFieldNames;\n\nfunction isColString(value) {\n  return typeof value === 'string' && value.substr(0, 1) === '$' && value.substr(value.length - 1, 1) === '$';\n}\nexports.isColString = isColString;\n\nfunction argsArePrimaryKeys(args, primaryKeys) {\n  let result = args.length === Object.keys(primaryKeys).length;\n  if (result) {\n    _.each(args, arg => {\n      if (result) {\n        if (['number', 'string'].indexOf(typeof arg) !== -1) {\n          result = true;\n        } else {\n          result = arg instanceof Date || Buffer.isBuffer(arg);\n        }\n      }\n    });\n  }\n  return result;\n}\nexports.argsArePrimaryKeys = argsArePrimaryKeys;\n\nfunction canTreatArrayAsAnd(arr) {\n  return arr.reduce((treatAsAnd, arg) => {\n    if (treatAsAnd) {\n      return treatAsAnd;\n    } else {\n      return _.isPlainObject(arg);\n    }\n  }, false);\n}\nexports.canTreatArrayAsAnd = canTreatArrayAsAnd;\n\nfunction combineTableNames(tableName1, tableName2) {\n  return tableName1.toLowerCase() < tableName2.toLowerCase() ? tableName1 + tableName2 : tableName2 + tableName1;\n}\nexports.combineTableNames = combineTableNames;\n\nfunction singularize(str) {\n  return inflection.singularize(str);\n}\nexports.singularize = singularize;\n\nfunction pluralize(str) {\n  return inflection.pluralize(str);\n}\nexports.pluralize = pluralize;\n\nfunction removeCommentsFromFunctionString(s) {\n  s = s.replace(/\\s*(\\/\\/.*)/g, '');\n  s = s.replace(/(\\/\\*[\\n\\r\\s\\S]*?\\*\\/)/mg, '');\n\n  return s;\n}\nexports.removeCommentsFromFunctionString = removeCommentsFromFunctionString;\n\nfunction toDefaultValue(value) {\n  if (typeof value === 'function') {\n    const tmp = value();\n    if (tmp instanceof DataTypes.ABSTRACT) {\n      return tmp.toSql();\n    } else {\n      return tmp;\n    }\n  } else if (value instanceof DataTypes.UUIDV1) {\n    return uuid.v1();\n  } else if (value instanceof DataTypes.UUIDV4) {\n    return uuid.v4();\n  } else if (value instanceof DataTypes.NOW) {\n    return now();\n  } else if (_.isPlainObject(value) || _.isArray(value)) {\n    return _.clone(value);\n  } else {\n    return value;\n  }\n}\nexports.toDefaultValue = toDefaultValue;\n\n/**\n * Determine if the default value provided exists and can be described\n * in a db schema using the DEFAULT directive.\n *\n * @param  {*} value Any default value.\n * @return {boolean} yes / no.\n * @private\n */\nfunction defaultValueSchemable(value) {\n  if (typeof value === 'undefined') { return false; }\n\n  // TODO this will be schemable when all supported db\n  // have been normalized for this case\n  if (value instanceof DataTypes.NOW) { return false; }\n\n  if (value instanceof DataTypes.UUIDV1 || value instanceof DataTypes.UUIDV4) { return false; }\n\n  if (_.isFunction(value)) {\n    return false;\n  }\n\n  return true;\n}\nexports.defaultValueSchemable = defaultValueSchemable;\n\nfunction removeNullValuesFromHash(hash, omitNull, options) {\n  let result = hash;\n\n  options = options || {};\n  options.allowNull = options.allowNull || [];\n\n  if (omitNull) {\n    const _hash = {};\n\n    _.forIn(hash, (val, key) => {\n      if (options.allowNull.indexOf(key) > -1 || key.match(/Id$/) || val !== null && val !== undefined) {\n        _hash[key] = val;\n      }\n    });\n\n    result = _hash;\n  }\n\n  return result;\n}\nexports.removeNullValuesFromHash = removeNullValuesFromHash;\n\nfunction stack() {\n  const orig = Error.prepareStackTrace;\n  Error.prepareStackTrace = (_, stack) => stack;\n  const err = new Error();\n  Error.captureStackTrace(err, stack);\n  const errStack = err.stack;\n  Error.prepareStackTrace = orig;\n  return errStack;\n}\nexports.stack = stack;\n\nfunction sliceArgs(args, begin) {\n  begin = begin || 0;\n  const tmp = new Array(args.length - begin);\n  for (let i = begin; i < args.length; ++i) {\n    tmp[i - begin] = args[i];\n  }\n  return tmp;\n}\nexports.sliceArgs = sliceArgs;\n\nfunction now(dialect) {\n  const now = new Date();\n  if (['mysql', 'postgres', 'sqlite'].indexOf(dialect) === -1) {\n    now.setMilliseconds(0);\n  }\n  return now;\n}\nexports.now = now;\n\n// Note: Use the `quoteIdentifier()` and `escape()` methods on the\n// `QueryInterface` instead for more portable code.\n\nconst TICK_CHAR = '`';\nexports.TICK_CHAR = TICK_CHAR;\n\nfunction addTicks(s, tickChar) {\n  tickChar = tickChar || TICK_CHAR;\n  return tickChar + removeTicks(s, tickChar) + tickChar;\n}\nexports.addTicks = addTicks;\n\nfunction removeTicks(s, tickChar) {\n  tickChar = tickChar || TICK_CHAR;\n  return s.replace(new RegExp(tickChar, 'g'), '');\n}\nexports.removeTicks = removeTicks;\n\n/**\n * Receives a tree-like object and returns a plain object which depth is 1.\n *\n * - Input:\n *\n *  {\n *    name: 'John',\n *    address: {\n *      street: 'Fake St. 123',\n *      coordinates: {\n *        longitude: 55.6779627,\n *        latitude: 12.5964313\n *      }\n *    }\n *  }\n *\n * - Output:\n *\n *  {\n *    name: 'John',\n *    address.street: 'Fake St. 123',\n *    address.coordinates.latitude: 55.6779627,\n *    address.coordinates.longitude: 12.5964313\n *  }\n *\n * @param {object} value Object to be deeply flattened\n */\nfunction flattenObjectDeep(value) {\n  if (!_.isPlainObject(value)) return value;\n  const flattenedObj = {};\n\n  function flattenObject(obj, subPath) {\n    Object.keys(obj).forEach(key => {\n      const pathToProperty = subPath ? `${subPath}.${key}` : `${key}`;\n      if (typeof obj[key] === 'object') {\n        flattenObject(obj[key], flattenedObj, pathToProperty);\n      } else {\n        flattenedObj[pathToProperty] = _.get(obj, key);\n      }\n    });\n    return flattenedObj;\n  }\n\n  return flattenObject(value, undefined);\n}\nexports.flattenObjectDeep = flattenObjectDeep;\n\n/**\n * Utility functions for representing SQL functions, and columns that should be escaped.\n * Please do not use these functions directly, use Sequelize.fn and Sequelize.col instead.\n * @private\n */\nclass SequelizeMethod {}\nexports.SequelizeMethod = SequelizeMethod;\n\nclass Fn extends SequelizeMethod {\n  constructor(fn, args) {\n    super();\n    this.fn = fn;\n    this.args = args;\n  }\n  clone() {\n    return new Fn(this.fn, this.args);\n  }\n}\nexports.Fn = Fn;\n\nclass Col extends SequelizeMethod {\n  constructor(col) {\n    super();\n    if (arguments.length > 1) {\n      col = this.sliceArgs(arguments);\n    }\n    this.col = col;\n  }\n}\nexports.Col = Col;\n\nclass Cast extends SequelizeMethod {\n  constructor(val, type) {\n    super();\n    this.val = val;\n    this.type = (type || '').trim();\n  }\n}\nexports.Cast = Cast;\n\nclass Literal extends SequelizeMethod {\n  constructor(val) {\n    super();\n    this.val = val;\n  }\n}\nexports.Literal = Literal;\n\nclass Json extends SequelizeMethod {\n  constructor(conditionsOrPath, value) {\n    super();\n    if (_.isObject(conditionsOrPath)) {\n      this.conditions = conditionsOrPath;\n    } else {\n      this.path = conditionsOrPath;\n      if (value) {\n        this.value = value;\n      }\n    }\n  }\n}\nexports.Json = Json;\n\nclass Where extends SequelizeMethod {\n  constructor(attribute, comparator, logic) {\n    super();\n    if (logic === undefined) {\n      logic = comparator;\n      comparator = '=';\n    }\n\n    this.attribute = attribute;\n    this.comparator = comparator;\n    this.logic = logic;\n  }\n}\nexports.Where = Where;\n\nexports.validateParameter = parameterValidator;\n\n\nexports.mapIsolationLevelStringToTedious = (isolationLevel, tedious) => {\n  if (!tedious) {\n    throw new Error('An instance of tedious lib should be passed to this function');\n  }\n  const tediousIsolationLevel = tedious.ISOLATION_LEVEL;\n  switch (isolationLevel) {\n    case 'READ_UNCOMMITTED':\n      return tediousIsolationLevel.READ_UNCOMMITTED;\n    case 'READ_COMMITTED':\n      return tediousIsolationLevel.READ_COMMITTED;\n    case 'REPEATABLE_READ':\n      return tediousIsolationLevel.REPEATABLE_READ;\n    case 'SERIALIZABLE':\n      return tediousIsolationLevel.SERIALIZABLE;\n    case 'SNAPSHOT':\n      return tediousIsolationLevel.SNAPSHOT;\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/utils.js\n// module id = 1\n// module chunks = 0","'use strict';\n\nconst util = require('util');\nconst inherits = require('./utils/inherits');\nconst _ = require('lodash');\nconst Wkt = require('terraformer-wkt-parser');\nconst sequelizeErrors = require('./errors');\nconst warnings = {};\nconst Validator = require('./utils/validator-extras').validator;\nconst momentTz = require('moment-timezone');\nconst moment = require('moment');\nconst Utils = require('./utils');\n\nfunction ABSTRACT() {}\n\nABSTRACT.prototype.dialectTypes = '';\n\nABSTRACT.prototype.toString = function toString(options) {\n  return this.toSql(options);\n};\nABSTRACT.prototype.toSql = function toSql() {\n  return this.key;\n};\nABSTRACT.warn = function warn(link, text) {\n  if (!warnings[text]) {\n    warnings[text] = true;\n    Utils.warn(`${text}, '\\n>> Check:', ${link}`);\n  }\n};\nABSTRACT.prototype.stringify = function stringify(value, options) {\n  if (this._stringify) {\n    return this._stringify(value, options);\n  }\n  return value;\n};\n\nfunction STRING(length, binary) {\n  const options = typeof length === 'object' && length || {length, binary};\n\n  if (!(this instanceof STRING)) return new STRING(options);\n\n  this.options = options;\n  this._binary = options.binary;\n  this._length = options.length || 255;\n}\ninherits(STRING, ABSTRACT);\n\nSTRING.prototype.key = STRING.key = 'STRING';\nSTRING.prototype.toSql = function toSql() {\n  return 'VARCHAR(' + this._length + ')' + (this._binary ? ' BINARY' : '');\n};\nSTRING.prototype.validate = function validate(value) {\n  if (Object.prototype.toString.call(value) !== '[object String]') {\n    if (this.options.binary && Buffer.isBuffer(value) || _.isNumber(value)) {\n      return true;\n    }\n    throw new sequelizeErrors.ValidationError(util.format('%j is not a valid string', value));\n  }\n\n  return true;\n};\nObject.defineProperty(STRING.prototype, 'BINARY', {\n  get() {\n    this._binary = true;\n    this.options.binary = true;\n    return this;\n  }\n});\n\nfunction CHAR(length, binary) {\n  const options = typeof length === 'object' && length || {length, binary};\n\n  if (!(this instanceof CHAR)) return new CHAR(options);\n  STRING.apply(this, arguments);\n}\ninherits(CHAR, STRING);\n\nCHAR.prototype.key = CHAR.key = 'CHAR';\nCHAR.prototype.toSql = function toSql() {\n  return 'CHAR(' + this._length + ')' + (this._binary ? ' BINARY' : '');\n};\n\nfunction TEXT(length) {\n  const options = typeof length === 'object' && length || {length};\n  if (!(this instanceof TEXT)) return new TEXT(options);\n  this.options = options;\n  this._length = options.length || '';\n}\ninherits(TEXT, ABSTRACT);\n\nTEXT.prototype.key = TEXT.key = 'TEXT';\nTEXT.prototype.toSql = function toSql() {\n  switch (this._length.toLowerCase()) {\n    case 'tiny':\n      return 'TINYTEXT';\n    case 'medium':\n      return 'MEDIUMTEXT';\n    case 'long':\n      return 'LONGTEXT';\n    default:\n      return this.key;\n  }\n};\nTEXT.prototype.validate = function validate(value) {\n  if (!_.isString(value)) {\n    throw new sequelizeErrors.ValidationError(util.format('%j is not a valid string', value));\n  }\n\n  return true;\n};\n\nfunction NUMBER(options) {\n  this.options = options;\n  this._length = options.length;\n  this._zerofill = options.zerofill;\n  this._decimals = options.decimals;\n  this._precision = options.precision;\n  this._scale = options.scale;\n  this._unsigned = options.unsigned;\n}\ninherits(NUMBER, ABSTRACT);\n\nNUMBER.prototype.key = NUMBER.key = 'NUMBER';\nNUMBER.prototype.toSql = function toSql() {\n  let result = this.key;\n  if (this._length) {\n    result += '(' + this._length;\n    if (typeof this._decimals === 'number') {\n      result += ',' + this._decimals;\n    }\n    result += ')';\n  }\n  if (this._unsigned) {\n    result += ' UNSIGNED';\n  }\n  if (this._zerofill) {\n    result += ' ZEROFILL';\n  }\n  return result;\n};\n\nNUMBER.prototype.validate = function(value) {\n  if (!Validator.isFloat(String(value))) {\n    throw new sequelizeErrors.ValidationError(util.format('%j is not a valid number', value));\n  }\n\n  return true;\n};\n\nObject.defineProperty(NUMBER.prototype, 'UNSIGNED', {\n  get() {\n    this._unsigned = true;\n    this.options.unsigned = true;\n    return this;\n  }\n});\nObject.defineProperty(NUMBER.prototype, 'ZEROFILL', {\n  get() {\n    this._zerofill = true;\n    this.options.zerofill = true;\n    return this;\n  }\n});\n\nfunction INTEGER(length) {\n  const options = typeof length === 'object' && length || {length};\n  if (!(this instanceof INTEGER)) return new INTEGER(options);\n  NUMBER.call(this, options);\n}\ninherits(INTEGER, NUMBER);\n\nINTEGER.prototype.key = INTEGER.key = 'INTEGER';\nINTEGER.prototype.validate = function validate(value) {\n  if (!Validator.isInt(String(value))) {\n    throw new sequelizeErrors.ValidationError(util.format('%j is not a valid integer', value));\n  }\n\n  return true;\n};\n\nfunction BIGINT(length) {\n  const options = typeof length === 'object' && length || {length};\n  if (!(this instanceof BIGINT)) return new BIGINT(options);\n  NUMBER.call(this, options);\n}\ninherits(BIGINT, NUMBER);\n\nBIGINT.prototype.key = BIGINT.key = 'BIGINT';\nBIGINT.prototype.validate = function validate(value) {\n  if (!Validator.isInt(String(value))) {\n    throw new sequelizeErrors.ValidationError(util.format('%j is not a valid bigint', value));\n  }\n\n  return true;\n};\n\nfunction FLOAT(length, decimals) {\n  const options = typeof length === 'object' && length || {length, decimals};\n  if (!(this instanceof FLOAT)) return new FLOAT(options);\n  NUMBER.call(this, options);\n}\ninherits(FLOAT, NUMBER);\n\nFLOAT.prototype.key = FLOAT.key = 'FLOAT';\nFLOAT.prototype.validate = function validate(value) {\n  if (!Validator.isFloat(String(value))) {\n    throw new sequelizeErrors.ValidationError(util.format('%j is not a valid float', value));\n  }\n\n  return true;\n};\n\nfunction REAL(length, decimals) {\n  const options = typeof length === 'object' && length || {length, decimals};\n  if (!(this instanceof REAL)) return new REAL(options);\n  NUMBER.call(this, options);\n}\ninherits(REAL, NUMBER);\n\nREAL.prototype.key = REAL.key = 'REAL';\n\nfunction DOUBLE(length, decimals) {\n  const options = typeof length === 'object' && length || {length, decimals};\n  if (!(this instanceof DOUBLE)) return new DOUBLE(options);\n  NUMBER.call(this, options);\n}\ninherits(DOUBLE, NUMBER);\n\nDOUBLE.prototype.key = DOUBLE.key = 'DOUBLE PRECISION';\n\nfunction DECIMAL(precision, scale) {\n  const options = typeof precision === 'object' && precision || {precision, scale};\n  if (!(this instanceof DECIMAL)) return new DECIMAL(options);\n  NUMBER.call(this, options);\n}\ninherits(DECIMAL, NUMBER);\n\nDECIMAL.prototype.key = DECIMAL.key = 'DECIMAL';\nDECIMAL.prototype.toSql = function toSql() {\n\n  if (this._precision || this._scale) {\n    return 'DECIMAL(' + [this._precision, this._scale].filter(_.identity).join(',') + ')';\n  }\n\n  return 'DECIMAL';\n};\nDECIMAL.prototype.validate = function validate(value) {\n  if (!Validator.isDecimal(String(value))) {\n    throw new sequelizeErrors.ValidationError(util.format('%j is not a valid decimal', value));\n  }\n\n  return true;\n};\n\nfor (const floating of [FLOAT, DOUBLE, REAL]) {\n  floating.prototype.escape = false;\n  floating.prototype._stringify = function _stringify(value) {\n    if (isNaN(value)) {\n      return \"'NaN'\";\n    } else if (!isFinite(value)) {\n      const sign = value < 0 ? '-' : '';\n      return \"'\" + sign + \"Infinity'\";\n    }\n\n    return value;\n  };\n}\n\nfunction BOOLEAN() {\n  if (!(this instanceof BOOLEAN)) return new BOOLEAN();\n}\ninherits(BOOLEAN, ABSTRACT);\n\nBOOLEAN.prototype.key = BOOLEAN.key = 'BOOLEAN';\nBOOLEAN.prototype.toSql = function toSql() {\n  return 'TINYINT(1)';\n};\nBOOLEAN.prototype.validate = function validate(value) {\n  if (!Validator.isBoolean(String(value))) {\n    throw new sequelizeErrors.ValidationError(util.format('%j is not a valid boolean', value));\n  }\n\n  return true;\n};\n\nfunction TIME() {\n  if (!(this instanceof TIME)) return new TIME();\n}\ninherits(TIME, ABSTRACT);\n\nTIME.prototype.key = TIME.key = 'TIME';\nTIME.prototype.toSql = function toSql() {\n  return 'TIME';\n};\n\nfunction DATE(length) {\n  const options = typeof length === 'object' && length || {length};\n\n  if (!(this instanceof DATE)) return new DATE(options);\n\n  this.options = options;\n  this._length = options.length || '';\n}\ninherits(DATE, ABSTRACT);\n\nDATE.prototype.key = DATE.key = 'DATE';\nDATE.prototype.toSql = function toSql() {\n  return 'DATETIME';\n};\nDATE.prototype.validate = function validate(value) {\n  if (!Validator.isDate(String(value))) {\n    throw new sequelizeErrors.ValidationError(util.format('%j is not a valid date', value));\n  }\n\n  return true;\n};\n\nDATE.prototype._applyTimezone = function _applyTimezone(date, options) {\n  if (options.timezone) {\n    if (momentTz.tz.zone(options.timezone)) {\n      date = momentTz(date).tz(options.timezone);\n    } else {\n      date = moment(date).utcOffset(options.timezone);\n    }\n  } else {\n    date = momentTz(date);\n  }\n\n  return date;\n};\n\nDATE.prototype._stringify = function _stringify(date, options) {\n  date = this._applyTimezone(date, options);\n\n  // Z here means current timezone, _not_ UTC\n  return date.format('YYYY-MM-DD HH:mm:ss.SSS Z');\n};\n\nfunction DATEONLY() {\n  if (!(this instanceof DATEONLY)) return new DATEONLY();\n}\nutil.inherits(DATEONLY, ABSTRACT);\n\nDATEONLY.prototype.key = DATEONLY.key = 'DATEONLY';\nDATEONLY.prototype.toSql = function() {\n  return 'DATE';\n};\n\nDATEONLY.prototype._stringify = function _stringify(date) {\n  return moment(date).format('YYYY-MM-DD');\n};\n\nfunction HSTORE() {\n  if (!(this instanceof HSTORE)) return new HSTORE();\n}\ninherits(HSTORE, ABSTRACT);\n\nHSTORE.prototype.key = HSTORE.key = 'HSTORE';\nHSTORE.prototype.validate = function validate(value) {\n  if (!_.isPlainObject(value)) {\n    throw new sequelizeErrors.ValidationError(util.format('%j is not a valid hstore', value));\n  }\n\n  return true;\n};\n\nfunction JSONTYPE() {\n  if (!(this instanceof JSONTYPE)) return new JSONTYPE();\n}\ninherits(JSONTYPE, ABSTRACT);\n\nJSONTYPE.prototype.key = JSONTYPE.key = 'JSON';\nJSONTYPE.prototype.validate = function validate() {\n  return true;\n};\n\nJSONTYPE.prototype._stringify = function _stringify(value) {\n  return JSON.stringify(value);\n};\n\nfunction JSONB() {\n  if (!(this instanceof JSONB)) return new JSONB();\n  JSONTYPE.call(this);\n}\ninherits(JSONB, JSONTYPE);\n\nJSONB.prototype.key = JSONB.key = 'JSONB';\n\nfunction NOW() {\n  if (!(this instanceof NOW)) return new NOW();\n}\ninherits(NOW, ABSTRACT);\n\nNOW.prototype.key = NOW.key = 'NOW';\n\nfunction BLOB(length) {\n  const options = typeof length === 'object' && length || {length};\n  if (!(this instanceof BLOB)) return new BLOB(options);\n  this.options = options;\n  this._length = options.length || '';\n}\ninherits(BLOB, ABSTRACT);\n\nBLOB.prototype.key = BLOB.key = 'BLOB';\nBLOB.prototype.toSql = function toSql() {\n  switch (this._length.toLowerCase()) {\n    case 'tiny':\n      return 'TINYBLOB';\n    case 'medium':\n      return 'MEDIUMBLOB';\n    case 'long':\n      return 'LONGBLOB';\n    default:\n      return this.key;\n  }\n};\nBLOB.prototype.validate = function validate(value) {\n  if (!_.isString(value) && !Buffer.isBuffer(value)) {\n    throw new sequelizeErrors.ValidationError(util.format('%j is not a valid blob', value));\n  }\n\n  return true;\n};\n\nBLOB.prototype.escape = false;\nBLOB.prototype._stringify = function _stringify(value) {\n  if (!Buffer.isBuffer(value)) {\n    if (Array.isArray(value)) {\n      value = new Buffer(value);\n    } else {\n      value = new Buffer(value.toString());\n    }\n  }\n  const hex = value.toString('hex');\n\n  return this._hexify(hex);\n};\n\nBLOB.prototype._hexify = function _hexify(hex) {\n  return \"X'\" + hex + \"'\";\n};\n\nfunction RANGE(subtype) {\n  const options = _.isPlainObject(subtype) ? subtype : {subtype};\n\n  if (!options.subtype) options.subtype = new INTEGER();\n\n  if (_.isFunction(options.subtype)) {\n    options.subtype = new options.subtype();\n  }\n\n  if (!(this instanceof RANGE)) return new RANGE(options);\n\n  this._subtype = options.subtype.key;\n  this.options = options;\n}\ninherits(RANGE, ABSTRACT);\n\nconst pgRangeSubtypes = {\n  integer: 'int4range',\n  bigint: 'int8range',\n  decimal: 'numrange',\n  dateonly: 'daterange',\n  date: 'tstzrange',\n  datenotz: 'tsrange'\n};\n\nconst pgRangeCastTypes = {\n  integer: 'integer',\n  bigint: 'bigint',\n  decimal: 'numeric',\n  dateonly: 'date',\n  date: 'timestamptz',\n  datenotz: 'timestamp'\n};\n\nRANGE.prototype.key = RANGE.key = 'RANGE';\nRANGE.prototype.toSql = function toSql() {\n  return pgRangeSubtypes[this._subtype.toLowerCase()];\n};\nRANGE.prototype.toCastType = function toCastType() {\n  return pgRangeCastTypes[this._subtype.toLowerCase()];\n};\nRANGE.prototype.validate = function validate(value) {\n  if (_.isPlainObject(value) && value.inclusive) {\n    value = value.inclusive;\n  }\n\n  if (!_.isArray(value)) {\n    throw new sequelizeErrors.ValidationError(util.format('%j is not a valid range', value));\n  }\n\n  if (value.length !== 2) {\n    throw new sequelizeErrors.ValidationError('A range must be an array with two elements');\n  }\n\n  return true;\n};\n\nfunction UUID() {\n  if (!(this instanceof UUID)) return new UUID();\n}\ninherits(UUID, ABSTRACT);\n\nUUID.prototype.key = UUID.key = 'UUID';\nUUID.prototype.validate = function validate(value, options) {\n  if (!_.isString(value) || !Validator.isUUID(value) && (!options || !options.acceptStrings)) {\n    throw new sequelizeErrors.ValidationError(util.format('%j is not a valid uuid', value));\n  }\n\n  return true;\n};\n\nfunction UUIDV1() {\n  if (!(this instanceof UUIDV1)) return new UUIDV1();\n}\ninherits(UUIDV1, ABSTRACT);\n\nUUIDV1.prototype.key = UUIDV1.key = 'UUIDV1';\nUUIDV1.prototype.validate = function validate(value, options) {\n  if (!_.isString(value) || !Validator.isUUID(value) && (!options || !options.acceptStrings)) {\n    throw new sequelizeErrors.ValidationError(util.format('%j is not a valid uuid', value));\n  }\n\n  return true;\n};\n\nfunction UUIDV4() {\n  if (!(this instanceof UUIDV4)) return new UUIDV4();\n}\ninherits(UUIDV4, ABSTRACT);\n\nUUIDV4.prototype.key = UUIDV4.key = 'UUIDV4';\nUUIDV4.prototype.validate = function validate(value, options) {\n  if (!_.isString(value) || !Validator.isUUID(value, 4) && (!options || !options.acceptStrings)) {\n    throw new sequelizeErrors.ValidationError(util.format('%j is not a valid uuidv4', value));\n  }\n\n  return true;\n};\n\nfunction VIRTUAL(ReturnType, fields) {\n  if (!(this instanceof VIRTUAL)) return new VIRTUAL(ReturnType, fields);\n  if (typeof ReturnType === 'function') ReturnType = new ReturnType();\n\n  this.returnType = ReturnType;\n  this.fields = fields;\n}\ninherits(VIRTUAL, ABSTRACT);\n\nVIRTUAL.prototype.key = VIRTUAL.key = 'VIRTUAL';\n\nfunction ENUM(value) {\n  const options = typeof value === 'object' && !Array.isArray(value) && value || {\n    values: Array.prototype.slice.call(arguments).reduce((result, element) => {\n      return result.concat(Array.isArray(element) ? element : [element]);\n    }, [])\n  };\n  if (!(this instanceof ENUM)) return new ENUM(options);\n  this.values = options.values;\n  this.options = options;\n}\ninherits(ENUM, ABSTRACT);\n\nENUM.prototype.key = ENUM.key = 'ENUM';\nENUM.prototype.validate = function validate(value) {\n  if (!_.includes(this.values, value)) {\n    throw new sequelizeErrors.ValidationError(util.format('%j is not a valid choice in %j', value, this.values));\n  }\n\n  return true;\n};\n\nfunction ARRAY(type) {\n  const options = _.isPlainObject(type) ? type : {type};\n  if (!(this instanceof ARRAY)) return new ARRAY(options);\n  this.type = typeof options.type === 'function' ? new options.type() : options.type;\n}\ninherits(ARRAY, ABSTRACT);\n\nARRAY.prototype.key = ARRAY.key = 'ARRAY';\nARRAY.prototype.toSql = function toSql() {\n  return this.type.toSql() + '[]';\n};\nARRAY.prototype.validate = function validate(value) {\n  if (!_.isArray(value)) {\n    throw new sequelizeErrors.ValidationError(util.format('%j is not a valid array', value));\n  }\n\n  return true;\n};\nARRAY.is = function is(obj, type) {\n  return obj instanceof ARRAY && obj.type instanceof type;\n};\n\nconst helpers = {\n  BINARY: [STRING, CHAR],\n  UNSIGNED: [NUMBER, INTEGER, BIGINT, FLOAT, DOUBLE, REAL, DECIMAL],\n  ZEROFILL: [NUMBER, INTEGER, BIGINT, FLOAT, DOUBLE, REAL, DECIMAL],\n  PRECISION: [DECIMAL],\n  SCALE: [DECIMAL]\n};\n\nfunction GEOMETRY(type, srid) {\n  const options = _.isPlainObject(type) ? type : {type, srid};\n\n  if (!(this instanceof GEOMETRY)) return new GEOMETRY(options);\n\n  this.options = options;\n  this.type = options.type;\n  this.srid = options.srid;\n}\ninherits(GEOMETRY, ABSTRACT);\n\nGEOMETRY.prototype.key = GEOMETRY.key = 'GEOMETRY';\n\nGEOMETRY.prototype.escape = false;\nGEOMETRY.prototype._stringify = function _stringify(value, options) {\n  return 'GeomFromText(' + options.escape(Wkt.convert(value)) + ')';\n};\n\nfunction GEOGRAPHY(type, srid) {\n  const options = _.isPlainObject(type) ? type : {type, srid};\n\n  if (!(this instanceof GEOGRAPHY)) return new GEOGRAPHY(options);\n\n  this.options = options;\n  this.type = options.type;\n  this.srid = options.srid;\n}\ninherits(GEOGRAPHY, ABSTRACT);\n\nGEOGRAPHY.prototype.key = GEOGRAPHY.key = 'GEOGRAPHY';\n\nGEOGRAPHY.prototype.escape = false;\nGEOGRAPHY.prototype._stringify = function _stringify(value, options) {\n  return 'GeomFromText(' + options.escape(Wkt.convert(value)) + ')';\n};\n\nfor (const helper of Object.keys(helpers)) {\n  for (const DataType of helpers[helper]) {\n    if (!DataType[helper]) {\n      Object.defineProperty(DataType, helper, {\n        get() {\n          const dataType = new DataType();\n          if (typeof dataType[helper] === 'object') {\n            return dataType;\n          }\n          return dataType[helper].apply(dataType, arguments);\n        }\n      });\n    }\n  }\n}\n\n/**\n * A convenience class holding commonly used data types. The datatypes are used when defining a new model using `Sequelize.define`, like this:\n * ```js\n * sequelize.define('model', {\n *   column: DataTypes.INTEGER\n * })\n * ```\n * When defining a model you can just as easily pass a string as type, but often using the types defined here is beneficial. For example, using `DataTypes.BLOB`, mean\n * that that column will be returned as an instance of `Buffer` when being fetched by sequelize.\n *\n * To provide a length for the data type, you can invoke it like a function: `INTEGER(2)`\n *\n * Some data types have special properties that can be accessed in order to change the data type.\n * For example, to get an unsigned integer with zerofill you can do `DataTypes.INTEGER.UNSIGNED.ZEROFILL`.\n * The order you access the properties in do not matter, so `DataTypes.INTEGER.ZEROFILL.UNSIGNED` is fine as well.\n *\n * * All number types (`INTEGER`, `BIGINT`, `FLOAT`, `DOUBLE`, `REAL`, `DECIMAL`) expose the properties `UNSIGNED` and `ZEROFILL`\n * * The `CHAR` and `STRING` types expose the `BINARY` property\n *\n *\n * Three of the values provided here (`NOW`, `UUIDV1` and `UUIDV4`) are special default values, that should not be used to define types. Instead they are used as shorthands for\n * defining default values. For example, to get a uuid field with a default value generated following v1 of the UUID standard:\n * ```js`\n * sequelize.define('model',` {\n *   uuid: {\n *     type: DataTypes.UUID,\n *     defaultValue: DataTypes.UUIDV1,\n *     primaryKey: true\n *   }\n * })\n * ```\n * There may be times when you want to generate your own UUID conforming to some other algorithm. This is accomplished\n * using the defaultValue property as well, but instead of specifying one of the supplied UUID types, you return a value\n * from a function.\n * ```js\n * sequelize.define('model', {\n *   uuid: {\n *     type: DataTypes.UUID,\n *     defaultValue: function() {\n *       return generateMyId()\n *     },\n *     primaryKey: true\n *   }\n * })\n * ```\n *\n * @property {function(length=255: integer)} STRING A variable length string\n * @property {function(length=255: integer)} CHAR A fixed length string.\n * @property {function([length]: string)} TEXT An unlimited length text column. Available lengths: `tiny`, `medium`, `long`\n * @property {function(length=255: integer)} INTEGER A 32 bit integer.\n * @property {function(length: integer)} BIGINT A 64 bit integer. Note: an attribute defined as `BIGINT` will be treated like a `string` due this [feature from node-postgres](https://github.com/brianc/node-postgres/pull/353) to prevent precision loss. To have this attribute as a `number`, this is a possible [workaround](https://github.com/sequelize/sequelize/issues/2383#issuecomment-58006083).\n * @property {function(length: integer, decimals: integer)} FLOAT Floating point number (4-byte precision).\n * @property {function(length: integer, decimals: integer)} DOUBLE Floating point number (8-byte precision).\n * @property {function(precision: integer, scale: integer)} DECIMAL Decimal number.\n * @property {function(length: integer, decimals: integer)} REAL Floating point number (4-byte precision).\n * @property {function} BOOLEAN A boolean / tinyint column, depending on dialect\n * @property {function(length: string)} BLOB Binary storage. Available lengths: `tiny`, `medium`, `long`\n * @property {function(values: string[])} ENUM An enumeration. `DataTypes.ENUM('value', 'another value')`.\n * @property {function(length: integer)} DATE A datetime column\n * @property {function} DATEONLY A date only column (no timestamp)\n * @property {function} TIME A time column\n * @property {function} NOW A default value of the current timestamp\n * @property {function} UUID A column storing a unique universal identifier. Use with `UUIDV1` or `UUIDV4` for default values.\n * @property {function} UUIDV1 A default unique universal identifier generated following the UUID v1 standard\n * @property {function} UUIDV4 A default unique universal identifier generated following the UUID v4 standard\n * @property {function} HSTORE A key / value store column. Only available in postgres.\n * @property {function} JSON A JSON string column. Only available in postgres and sqlite.\n * @property {function} JSONB A binary storage JSON column. Only available in postgres.\n * @property {function(type: DataTypes)} ARRAY An array of `type`, e.g. `DataTypes.ARRAY(DataTypes.DECIMAL)`. Only available in postgres.\n * @property {function(type: DataTypes)} RANGE Range types are data types representing a range of values of some element type (called the range's subtype).\n * Only available in postgres. See [the Postgres documentation](http://www.postgresql.org/docs/9.4/static/rangetypes.html) for more details\n * @property {function(type: string, srid: string)} GEOMETRY A column storing Geometry information. It is only available in PostgreSQL (with PostGIS) or MySQL.\n * In MySQL, allowable Geometry types are `POINT`, `LINESTRING`, `POLYGON`.\n *\n * GeoJSON is accepted as input and returned as output.\n * In PostGIS, the GeoJSON is parsed using the PostGIS function `ST_GeomFromGeoJSON`.\n * In MySQL it is parsed using the function `GeomFromText`.\n * Therefore, one can just follow the [GeoJSON spec](http://geojson.org/geojson-spec.html) for handling geometry objects.  See the following examples:\n *\n * ```js\n * // Create a new point:\n * const point = { type: 'Point', coordinates: [39.807222,-76.984722]};\n *\n * User.create({username: 'username', geometry: point });\n *\n * // Create a new linestring:\n * const line = { type: 'LineString', 'coordinates': [ [100.0, 0.0], [101.0, 1.0] ] };\n *\n * User.create({username: 'username', geometry: line });\n *\n * // Create a new polygon:\n * const polygon = { type: 'Polygon', coordinates: [\n *                 [ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0],\n *                   [100.0, 1.0], [100.0, 0.0] ]\n *                 ]};\n *\n * User.create({username: 'username', geometry: polygon });\n\n * // Create a new point with a custom SRID:\n * const point = {\n *   type: 'Point',\n *   coordinates: [39.807222,-76.984722],\n *   crs: { type: 'name', properties: { name: 'EPSG:4326'} }\n * };\n *\n * User.create({username: 'username', geometry: point })\n * ```\n * @property {function(type: string, srid: string)} GEOGRAPHY A geography datatype represents two dimensional spacial objects in an elliptic coord system.\n * @property {function(returnType: DataTypes, fields: string[])} VIRTUAL A virtual value that is not stored in the DB. This could for example be useful if you want to provide a default value in your model that is returned to the user but not stored in the DB.\n *\n * You could also use it to validate a value before permuting and storing it. Checking password length before hashing it for example:\n * ```js\n * sequelize.define('user', {\n *   password_hash: DataTypes.STRING,\n *   password: {\n *     type: DataTypes.VIRTUAL,\n *     set: function (val) {\n *        // Remember to set the data value, otherwise it won't be validated\n *        this.setDataValue('password', val);\n *        this.setDataValue('password_hash', this.salt + val);\n *      },\n *      validate: {\n *         isLongEnough: function (val) {\n *           if (val.length < 7) {\n *             throw new Error(\"Please choose a longer password\")\n *          }\n *       }\n *     }\n *   }\n * })\n * ```\n * In the above code the password is stored plainly in the password field so it can be validated, but is never stored in the DB.\n *\n * VIRTUAL also takes a return type and dependency fields as arguments\n * If a virtual attribute is present in `attributes` it will automatically pull in the extra fields as well.\n * Return type is mostly useful for setups that rely on types like GraphQL.\n * ```js\n * {\n *   active: {\n *     type: new DataTypes.VIRTUAL(DataTypes.BOOLEAN, ['createdAt']),\n *     get: function() {\n *       return this.get('createdAt') > Date.now() - (7 * 24 * 60 * 60 * 1000)\n *     }\n *   }\n * }\n * ```\n */\nconst DataTypes = module.exports = {\n  ABSTRACT,\n  STRING,\n  CHAR,\n  TEXT,\n  NUMBER,\n  INTEGER,\n  BIGINT,\n  FLOAT,\n  TIME,\n  DATE,\n  DATEONLY,\n  BOOLEAN,\n  NOW,\n  BLOB,\n  DECIMAL,\n  NUMERIC: DECIMAL,\n  UUID,\n  UUIDV1,\n  UUIDV4,\n  HSTORE,\n  JSON: JSONTYPE,\n  JSONB,\n  VIRTUAL,\n  ARRAY,\n  NONE: VIRTUAL,\n  ENUM,\n  RANGE,\n  REAL,\n  DOUBLE,\n  'DOUBLE PRECISION': DOUBLE,\n  GEOMETRY,\n  GEOGRAPHY\n};\n\n_.each(DataTypes, dataType => {\n  dataType.types = {};\n});\n\nDataTypes.postgres = require('./dialects/postgres/data-types')(DataTypes);\nDataTypes.mysql = require('./dialects/mysql/data-types')(DataTypes);\nDataTypes.sqlite = require('./dialects/sqlite/data-types')(DataTypes);\nDataTypes.mssql = require('./dialects/mssql/data-types')(DataTypes);\n\nmodule.exports = DataTypes;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/data-types.js\n// module id = 2\n// module chunks = 0","'use strict';\n\nmodule.exports = require('./errors/index.js');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/errors.js\n// module id = 3\n// module chunks = 0","'use strict';\n\nconst Promise = require('bluebird').getNewLibraryCopy();\n\nmodule.exports = Promise;\nmodule.exports.Promise = Promise;\nmodule.exports.default = Promise;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/promise.js\n// module id = 4\n// module chunks = 0","module.exports = require(\"regenerator-runtime\");\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/babel-runtime/regenerator/index.js\n// module id = 5\n// module chunks = 0","require('dotenv').config();\nimport fs from 'fs'\nimport path from 'path'\nimport Sequelize from 'Sequelize'\nimport dbConfig from './db.js';\n\nconst env = process.env.NODE_ENV || \"development\";\nconst config = dbConfig[env];\n\nimport changelog from './changelog'\nimport pages from './pages'\nimport users from './users'\n\nconst params = Object.assign({\n  // 字段以下划线（_）来分割\n  underscored: true,\n  dialectOptions: {\n    ssl: false\n  },\n  define: {\n    timestamps: true,\n    createdAt: 'create_at',\n    updatedAt: 'update_at'\n  },\n  logging: false\n}, config);\n\nlet sequelize\n\nif (config.url) {\n  sequelize = new Sequelize(config.url, params);\n} else {\n  sequelize = new Sequelize(config.database, config.username, config.password, params);\n}\n\nlet db = {};\n\n[changelog, pages, users].forEach(function(md) {\n  var model = md(sequelize, Sequelize);\n  db[model.name] = model;\n});\n\nObject.keys(db).forEach(function(modelName) {\n  if (\"associate\" in db[modelName]) {\n    db[modelName].associate(db);\n  }\n});\n\ndb.sequelize = sequelize;\ndb.Sequelize = Sequelize;\n\nexport default db;\n\n\n\n// WEBPACK FOOTER //\n// ./server/models/index.js","module.exports = require(\"util\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"util\"\n// module id = 7\n// module chunks = 0","'use strict';\nconst AssociationError = require('./../errors').AssociationError;\n\n\n/**\n * Creating associations in sequelize is done by calling one of the belongsTo / hasOne / hasMany / belongsToMany functions on a model (the source), and providing another model as the first argument to the function (the target).\n *\n * * hasOne - adds a foreign key to the target and singular association mixins to the source.\n * * belongsTo - add a foreign key and singular association mixins to the source.\n * * hasMany - adds a foreign key to target and plural association mixins to the source.\n * * belongsToMany - creates an N:M association with a join table and adds plural association mixins to the source. The junction table is created with sourceId and targetId.\n *\n * Creating an association will add a foreign key constraint to the attributes. All associations use `CASCADE` on update and `SET NULL` on delete, except for n:m, which also uses `CASCADE` on delete.\n *\n * When creating associations, you can provide an alias, via the `as` option. This is useful if the same model is associated twice, or you want your association to be called something other than the name of the target model.\n *\n * As an example, consider the case where users have many pictures, one of which is their profile picture. All pictures have a `userId`, but in addition the user model also has a `profilePictureId`, to be able to easily load the user's profile picture.\n *\n * ```js\n * User.hasMany(Picture)\n * User.belongsTo(Picture, { as: 'ProfilePicture', constraints: false })\n *\n * user.getPictures() // gets you all pictures\n * user.getProfilePicture() // gets you only the profile picture\n *\n * User.findAll({\n *   where: ...,\n *   include: [\n *     { model: Picture }, // load all pictures\n *     { model: Picture, as: 'ProfilePicture' }, // load the profile picture.\n *     // Notice that the spelling must be the exact same as the one in the association\n *   ]\n * })\n * ```\n * To get full control over the foreign key column added by sequelize, you can use the `foreignKey` option. It can either be a string, that specifies the name, or and object type definition,\n * equivalent to those passed to `sequelize.define`.\n *\n * ```js\n * User.hasMany(Picture, { foreignKey: 'uid' })\n * ```\n *\n * The foreign key column in Picture will now be called `uid` instead of the default `userId`.\n *\n * ```js\n * User.hasMany(Picture, {\n *   foreignKey: {\n *     name: 'uid',\n *     allowNull: false\n *   }\n * })\n * ```\n *\n * This specifies that the `uid` column cannot be null. In most cases this will already be covered by the foreign key constraints, which sequelize creates automatically, but can be useful in case where the foreign keys are disabled, e.g. due to circular references (see `constraints: false` below).\n *\n * When fetching associated models, you can limit your query to only load some models. These queries are written in the same way as queries to `find`/`findAll`. To only get pictures in JPG, you can do:\n *\n * ```js\n * user.getPictures({\n *   where: {\n *     format: 'jpg'\n *   }\n * })\n * ```\n *\n * There are several ways to update and add new associations. Continuing with our example of users and pictures:\n * ```js\n * user.addPicture(p) // Add a single picture\n * user.setPictures([p1, p2]) // Associate user with ONLY these two picture, all other associations will be deleted\n * user.addPictures([p1, p2]) // Associate user with these two pictures, but don't touch any current associations\n * ```\n *\n * You don't have to pass in a complete object to the association functions, if your associated model has a single primary key:\n *\n * ```js\n * user.addPicture(req.query.pid) // Here pid is just an integer, representing the primary key of the picture\n * ```\n *\n * In the example above we have specified that a user belongs to his profile picture. Conceptually, this might not make sense, but since we want to add the foreign key to the user model this is the way to do it.\n *\n * Note how we also specified `constraints: false` for profile picture. This is because we add a foreign key from user to picture (profilePictureId), and from picture to user (userId). If we were to add foreign keys to both, it would create a cyclic dependency, and sequelize would not know which table to create first, since user depends on picture, and picture depends on user. These kinds of problems are detected by sequelize before the models are synced to the database, and you will get an error along the lines of `Error: Cyclic dependency found. 'users' is dependent of itself`. If you encounter this, you should either disable some constraints, or rethink your associations completely.\n */\nclass Association {\n  constructor(source, target, options) {\n    options = options || {};\n    /**\n     * @type {Model}\n     */\n    this.source = source;\n    /**\n     * @type {Model}\n     */\n    this.target = target;\n    this.options = options;\n    this.scope = options.scope;\n    this.isSelfAssociation = this.source === this.target;\n    this.as = options.as;\n    /**\n     * The type of the association. One of `HasMany`, `BelongsTo`, `HasOne`, `BelongsToMany`\n     * @type {string}\n     */\n    this.associationType = '';\n\n    if (source.hasAlias(options.as)) {\n      throw new AssociationError(`You have used the alias ${options.as} in two separate associations. ` +\n      'Aliased associations must have unique aliases.'\n      );\n    }\n  }\n  // Normalize input - may be array or single obj, instance or primary key - convert it to an array of built objects\n  toInstanceArray(objs) {\n    if (!Array.isArray(objs)) {\n      objs = [objs];\n    }\n    return objs.map(function(obj) {\n      if (!(obj instanceof this.target)) {\n        const tmpInstance = {};\n        tmpInstance[this.target.primaryKeyAttribute] = obj;\n        return this.target.build(tmpInstance, {\n          isNewRecord: false\n        });\n      }\n      return obj;\n    }, this);\n  }\n  inspect() {\n    return this.as;\n  }\n}\n\nmodule.exports = Association;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/associations/base.js\n// module id = 8\n// module chunks = 0","'use strict';\n\n/**\n * An enum of query types used by `sequelize.query`\n *\n * @see {@link Sequelize#query}\n *\n * @property SELECT\n * @property INSERT\n * @property UPDATE\n * @property BULKUPDATE\n * @property BULKDELETE\n * @property DELETE\n * @property UPSERT\n * @property VERSION\n * @property SHOWTABLES\n * @property SHOWINDEXES\n * @property DESCRIBE\n * @property RAW\n * @property FOREIGNKEYS\n * @property SHOWCONSTRAINTS\n */\nconst QueryTypes = module.exports = { // eslint-disable-line\n  SELECT: 'SELECT',\n  INSERT: 'INSERT',\n  UPDATE: 'UPDATE',\n  BULKUPDATE: 'BULKUPDATE',\n  BULKDELETE: 'BULKDELETE',\n  DELETE: 'DELETE',\n  UPSERT: 'UPSERT',\n  VERSION: 'VERSION',\n  SHOWTABLES: 'SHOWTABLES',\n  SHOWINDEXES: 'SHOWINDEXES',\n  DESCRIBE: 'DESCRIBE',\n  RAW: 'RAW',\n  FOREIGNKEYS: 'FOREIGNKEYS',\n  SHOWCONSTRAINTS: 'SHOWCONSTRAINTS'\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/query-types.js\n// module id = 9\n// module chunks = 0","module.exports = require(\"path\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"path\"\n// module id = 10\n// module chunks = 0","'use strict';\n\nconst util = require('util');\nconst _ = require('lodash');\n\n/**\n * like util.inherits, but also copies over static properties\n * @private\n */\nfunction inherits(constructor, superConstructor) {\n  util.inherits(constructor, superConstructor); // Instance (prototype) methods\n  _.extend(constructor, superConstructor); // Static methods\n}\n\nmodule.exports = inherits;\nmodule.exports.inherits = inherits;\nmodule.exports.default = inherits;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/utils/inherits.js\n// module id = 11\n// module chunks = 0","'use strict';\n\nconst Utils = require('./../utils');\nconst Helpers = require('./helpers');\nconst _ = require('lodash');\nconst Transaction = require('../transaction');\nconst Association = require('./base');\n\n/**\n * One-to-one association\n *\n * In the API reference below, add the name of the association to the method, e.g. for `User.belongsTo(Project)` the getter will be `user.getProject()`.\n *\n * @see {@link Model.belongsTo}\n */\nclass BelongsTo extends Association {\n  constructor(source, target, options) {\n    super(source, target, options);\n\n    this.associationType = 'BelongsTo';\n    this.isSingleAssociation = true;\n    this.foreignKeyAttribute = {};\n\n    if (this.as) {\n      this.isAliased = true;\n      this.options.name = {\n        singular: this.as\n      };\n    } else {\n      this.as = this.target.options.name.singular;\n      this.options.name = this.target.options.name;\n    }\n\n    if (_.isObject(this.options.foreignKey)) {\n      this.foreignKeyAttribute = this.options.foreignKey;\n      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n    } else if (this.options.foreignKey) {\n      this.foreignKey = this.options.foreignKey;\n    }\n\n    if (!this.foreignKey) {\n      this.foreignKey = Utils.camelizeIf(\n        [\n          Utils.underscoredIf(this.as, this.source.options.underscored),\n          this.target.primaryKeyAttribute\n        ].join('_'),\n        !this.source.options.underscored\n      );\n    }\n\n    this.identifier = this.foreignKey;\n\n    if (this.source.rawAttributes[this.identifier]) {\n      this.identifierField = this.source.rawAttributes[this.identifier].field || this.identifier;\n    }\n\n    this.targetKey = this.options.targetKey || this.target.primaryKeyAttribute;\n    this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey;\n    this.targetKeyIsPrimary = this.targetKey === this.target.primaryKeyAttribute;\n\n    this.targetIdentifier = this.targetKey;\n    this.associationAccessor = this.as;\n    this.options.useHooks = options.useHooks;\n\n    // Get singular name, trying to uppercase the first letter, unless the model forbids it\n    const singular = Utils.uppercaseFirst(this.options.name.singular);\n\n    this.accessors = {\n      get: 'get' + singular,\n      set: 'set' + singular,\n      create: 'create' + singular\n    };\n  }\n\n  // the id is in the source table\n  injectAttributes() {\n    const newAttributes = {};\n\n    newAttributes[this.foreignKey] = _.defaults({}, this.foreignKeyAttribute, {\n      type: this.options.keyType || this.target.rawAttributes[this.targetKey].type,\n      allowNull : true\n    });\n\n    if (this.options.constraints !== false) {\n      const source = this.source.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];\n      this.options.onDelete = this.options.onDelete || (source.allowNull ? 'SET NULL' : 'NO ACTION');\n      this.options.onUpdate = this.options.onUpdate || 'CASCADE';\n    }\n\n    Helpers.addForeignKeyConstraints(newAttributes[this.foreignKey], this.target, this.source, this.options, this.targetKeyField);\n    Utils.mergeDefaults(this.source.rawAttributes, newAttributes);\n\n    this.identifierField = this.source.rawAttributes[this.foreignKey].field || this.foreignKey;\n\n    this.source.refreshAttributes();\n\n    Helpers.checkNamingCollision(this);\n\n    return this;\n  }\n\n  mixin(obj) {\n    const methods = ['get', 'set', 'create'];\n\n    Helpers.mixinMethods(this, obj, methods);\n  }\n\n  /**\n   * Get the associated instance.\n   *\n   * @param {Object} [options]\n   * @param {String|Boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false.\n   * @param {String} [options.schema] Apply a schema on the related model\n   * @see {@link Model.findOne} for a full explanation of options\n   * @return {Promise<Model>}\n   */\n  get(instances, options) {\n    const association = this;\n    const where = {};\n    let Target = association.target;\n    let instance;\n\n    options = Utils.cloneDeep(options);\n\n    if (options.hasOwnProperty('scope')) {\n      if (!options.scope) {\n        Target = Target.unscoped();\n      } else {\n        Target = Target.scope(options.scope);\n      }\n    }\n\n    if (options.hasOwnProperty('schema')) {\n      Target = Target.schema(options.schema, options.schemaDelimiter);\n    }\n\n    if (!Array.isArray(instances)) {\n      instance = instances;\n      instances = undefined;\n    }\n\n    if (instances) {\n      where[association.targetKey] = {\n        $in: instances.map(instance => instance.get(association.foreignKey))\n      };\n    } else {\n      if (association.targetKeyIsPrimary && !options.where) {\n        return Target.findById(instance.get(association.foreignKey), options);\n      } else {\n        where[association.targetKey] = instance.get(association.foreignKey);\n        options.limit = null;\n      }\n    }\n\n    options.where = options.where ?\n      {$and: [where, options.where]} :\n      where;\n\n    if (instances) {\n      return Target.findAll(options).then(results => {\n        const result = {};\n        for (const instance of instances) {\n          result[instance.get(association.foreignKey, {raw: true})] = null;\n        }\n\n        for (const instance of results) {\n          result[instance.get(association.targetKey, {raw: true})] = instance;\n        }\n\n        return result;\n      });\n    }\n\n    return Target.findOne(options);\n  }\n\n  /**\n   * Set the associated model.\n   *\n   * @param {Model|String|Number} [newAssociation] An persisted instance or the primary key of an instance to associate with this. Pass `null` or `undefined` to remove the association.\n   * @param {Object} [options] Options passed to `this.save`\n   * @param {Boolean} [options.save=true] Skip saving this after setting the foreign key if false.\n   * @return {Promise}\n   */\n  set(sourceInstance, associatedInstance, options) {\n    const association = this;\n\n    options = options || {};\n\n    let value = associatedInstance;\n    if (associatedInstance instanceof association.target) {\n      value = associatedInstance[association.targetKey];\n    }\n\n    sourceInstance.set(association.foreignKey, value);\n\n    if (options.save === false) return;\n\n    options = _.extend({\n      fields: [association.foreignKey],\n      allowNull: [association.foreignKey],\n      association: true\n    }, options);\n\n    // passes the changed field to save, so only that field get updated.\n    return sourceInstance.save(options);\n  }\n\n  /**\n   * Create a new instance of the associated model and associate it with this.\n   *\n   * @param {Object} [values]\n   * @param {Object} [options] Options passed to `target.create` and setAssociation.\n   * @see {@link Model#create}  for a full explanation of options\n   * @return {Promise}\n   */\n  create(sourceInstance, values, fieldsOrOptions) {\n    const association = this;\n\n    const options = {};\n\n    if ((fieldsOrOptions || {}).transaction instanceof Transaction) {\n      options.transaction = fieldsOrOptions.transaction;\n    }\n    options.logging = (fieldsOrOptions || {}).logging;\n\n    return association.target.create(values, fieldsOrOptions).then(newAssociatedObject =>\n      sourceInstance[association.accessors.set](newAssociatedObject, options)\n    );\n  }\n}\n\nmodule.exports = BelongsTo;\nmodule.exports.BelongsTo = BelongsTo;\nmodule.exports.default = BelongsTo;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/associations/belongs-to.js\n// module id = 12\n// module chunks = 0","'use strict';\n\nconst Utils = require('./../utils');\nconst Helpers = require('./helpers');\nconst _ = require('lodash');\nconst Association = require('./base');\n\n/**\n * One-to-many association\n *\n * In the API reference below, add the name of the association to the method, e.g. for `User.hasMany(Project)` the getter will be `user.getProjects()`.\n * If the association is aliased, use the alias instead, e.g. `User.hasMany(Project, { as: 'jobs' })` will be `user.getJobs()`.\n *\n * @see {@link Model.hasMany}\n */\nclass HasMany extends Association {\n  constructor(source, target, options) {\n    super(source, target, options);\n\n    this.associationType = 'HasMany';\n    this.targetAssociation = null;\n    this.sequelize = source.sequelize;\n    this.through = options.through;\n    this.isMultiAssociation = true;\n    this.foreignKeyAttribute = {};\n\n    if (this.options.through) {\n      throw new Error('N:M associations are not supported with hasMany. Use belongsToMany instead');\n    }\n\n    /*\n    * If self association, this is the target association\n    */\n    if (this.isSelfAssociation) {\n      this.targetAssociation = this;\n    }\n\n    if (this.as) {\n      this.isAliased = true;\n\n      if (_.isPlainObject(this.as)) {\n        this.options.name = this.as;\n        this.as = this.as.plural;\n      } else {\n        this.options.name = {\n          plural: this.as,\n          singular: Utils.singularize(this.as)\n        };\n      }\n    } else {\n      this.as = this.target.options.name.plural;\n      this.options.name = this.target.options.name;\n    }\n\n    /*\n    * Foreign key setup\n    */\n    if (_.isObject(this.options.foreignKey)) {\n      this.foreignKeyAttribute = this.options.foreignKey;\n      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n    } else if (this.options.foreignKey) {\n      this.foreignKey = this.options.foreignKey;\n    }\n\n    if (!this.foreignKey) {\n      this.foreignKey = Utils.camelizeIf(\n        [\n          Utils.underscoredIf(this.source.options.name.singular, this.source.options.underscored),\n          this.source.primaryKeyAttribute\n        ].join('_'),\n        !this.source.options.underscored\n      );\n    }\n\n    if (this.target.rawAttributes[this.foreignKey]) {\n      this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n      this.foreignKeyField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    }\n\n    this.sourceKey = this.options.sourceKey || this.source.primaryKeyAttribute;\n    if (this.target.rawAttributes[this.sourceKey]) {\n      this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;\n    } else {\n      this.sourceKeyField = this.sourceKey;\n    }\n\n    if (this.source.fieldRawAttributesMap[this.sourceKey]) {\n      this.sourceKeyAttribute = this.source.fieldRawAttributesMap[this.sourceKey].fieldName;\n    } else {\n      this.sourceKeyAttribute = this.source.primaryKeyAttribute;\n    }\n    this.sourceIdentifier = this.sourceKey;\n    this.associationAccessor = this.as;\n\n    // Get singular and plural names, trying to uppercase the first letter, unless the model forbids it\n    const plural = Utils.uppercaseFirst(this.options.name.plural);\n    const singular = Utils.uppercaseFirst(this.options.name.singular);\n\n    this.accessors = {\n      get: 'get' + plural,\n      set: 'set' + plural,\n      addMultiple: 'add' + plural,\n      add: 'add' + singular,\n      create: 'create' + singular,\n      remove: 'remove' + singular,\n      removeMultiple: 'remove' + plural,\n      hasSingle: 'has' + singular,\n      hasAll: 'has' + plural,\n      count: 'count' + plural\n    };\n  }\n\n  // the id is in the target table\n  // or in an extra table which connects two tables\n  injectAttributes() {\n    const newAttributes = {};\n    const constraintOptions = _.clone(this.options); // Create a new options object for use with addForeignKeyConstraints, to avoid polluting this.options in case it is later used for a n:m\n    newAttributes[this.foreignKey] = _.defaults({}, this.foreignKeyAttribute, {\n      type: this.options.keyType || this.source.rawAttributes[this.sourceKeyAttribute].type,\n      allowNull : true\n    });\n\n    if (this.options.constraints !== false) {\n      const target = this.target.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];\n      constraintOptions.onDelete = constraintOptions.onDelete || (target.allowNull ? 'SET NULL' : 'CASCADE');\n      constraintOptions.onUpdate = constraintOptions.onUpdate || 'CASCADE';\n    }\n    Helpers.addForeignKeyConstraints(newAttributes[this.foreignKey], this.source, this.target, constraintOptions, this.sourceKeyField);\n    Utils.mergeDefaults(this.target.rawAttributes, newAttributes);\n\n    this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    this.foreignKeyField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n\n    this.target.refreshAttributes();\n    this.source.refreshAttributes();\n\n    Helpers.checkNamingCollision(this);\n\n    return this;\n  }\n\n  mixin(obj) {\n    const methods = ['get', 'count', 'hasSingle', 'hasAll', 'set', 'add', 'addMultiple', 'remove', 'removeMultiple', 'create'];\n    const aliases = {\n      hasSingle: 'has',\n      hasAll: 'has',\n      addMultiple: 'add',\n      removeMultiple: 'remove'\n    };\n\n    Helpers.mixinMethods(this, obj, methods, aliases);\n  }\n\n  /**\n   * Get everything currently associated with this, using an optional where clause.\n   *\n   * @param {Object} [options]\n   * @param {Object} [options.where] An optional where clause to limit the associated models\n   * @param {String|Boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n   * @param {String} [options.schema] Apply a schema on the related model\n   * @see {@link Model.findAll}  for a full explanation of options\n   * @return {Promise<Array<Model>>}\n   */\n  get(instances, options) {\n    const association = this;\n    const where = {};\n    let Model = association.target;\n    let instance;\n    let values;\n\n    if (!Array.isArray(instances)) {\n      instance = instances;\n      instances = undefined;\n    }\n\n    options = Utils.cloneDeep(options) || {};\n\n    if (association.scope) {\n      _.assign(where, association.scope);\n    }\n\n    if (instances) {\n      values = instances.map(instance => instance.get(association.sourceKey, {raw: true}));\n\n      if (options.limit && instances.length > 1) {\n        options.groupedLimit = {\n          limit: options.limit,\n          on: association,\n          values\n        };\n\n        delete options.limit;\n      } else {\n        where[association.foreignKey] = {\n          $in: values\n        };\n        delete options.groupedLimit;\n      }\n    } else {\n      where[association.foreignKey] = instance.get(association.sourceKey, {raw: true});\n    }\n\n\n    options.where = options.where ?\n      {$and: [where, options.where]} :\n      where;\n\n    if (options.hasOwnProperty('scope')) {\n      if (!options.scope) {\n        Model = Model.unscoped();\n      } else {\n        Model = Model.scope(options.scope);\n      }\n    }\n\n    if (options.hasOwnProperty('schema')) {\n      Model = Model.schema(options.schema, options.schemaDelimiter);\n    }\n\n\n    return Model.findAll(options).then(results => {\n      if (instance) return results;\n\n      const result = {};\n      for (const instance of instances) {\n        result[instance.get(association.sourceKey, {raw: true})] = [];\n      }\n\n      for (const instance of results) {\n        result[instance.get(association.foreignKey, {raw: true})].push(instance);\n      }\n\n      return result;\n    });\n  }\n\n  /**\n   * Count everything currently associated with this, using an optional where clause.\n   *\n   * @param {Object} [options]\n   * @param {Object} [options.where] An optional where clause to limit the associated models\n   * @param {String|Boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n   * @return {Promise<Integer>}\n   */\n  count(instance, options) {\n    const association = this;\n    const model = association.target;\n    const sequelize = model.sequelize;\n\n    options = Utils.cloneDeep(options);\n    options.attributes = [\n      [sequelize.fn('COUNT', sequelize.col(model.primaryKeyField)), 'count']\n    ];\n    options.raw = true;\n    options.plain = true;\n\n    return association.get(instance, options).then(result => parseInt(result.count, 10));\n  }\n\n  /**\n   * Check if one or more rows are associated with `this`.\n   *\n   * @param {Model[]|Model|string[]|String|number[]|Number} [instance(s)]\n   * @param {Object} [options] Options passed to getAssociations\n   * @return {Promise}\n   */\n  has(sourceInstance, targetInstances, options) {\n    const association = this;\n    const where = {};\n\n    if (!Array.isArray(targetInstances)) {\n      targetInstances = [targetInstances];\n    }\n\n    options = _.assign({}, options, {\n      scope: false,\n      raw: true\n    });\n\n    where.$or = targetInstances.map(instance => {\n      if (instance instanceof association.target) {\n        return instance.where();\n      } else {\n        const _where = {};\n        _where[association.target.primaryKeyAttribute] = instance;\n        return _where;\n      }\n    });\n\n    options.where = {\n      $and: [\n        where,\n        options.where\n      ]\n    };\n\n    return association.get(sourceInstance, options).then(associatedObjects => associatedObjects.length === targetInstances.length);\n  }\n\n  /**\n   * Set the associated models by passing an array of persisted instances or their primary keys. Everything that is not in the passed array will be un-associated\n   *\n   * @param {Array<Model|String|Number>} [newAssociations] An array of persisted instances or primary key of instances to associate with this. Pass `null` or `undefined` to remove all associations.\n   * @param {Object} [options] Options passed to `target.findAll` and `update`.\n   * @param {Object} [options.validate] Run validation for the join model\n   * @return {Promise}\n   */\n  set(sourceInstance, targetInstances, options) {\n    const association = this;\n\n    if (targetInstances === null) {\n      targetInstances = [];\n    } else {\n      targetInstances = association.toInstanceArray(targetInstances);\n    }\n\n    return association.get(sourceInstance, _.defaults({scope: false, raw: true}, options)).then(oldAssociations => {\n      const promises = [];\n      const obsoleteAssociations = oldAssociations.filter(old =>\n        !_.find(targetInstances, obj =>\n          obj[association.target.primaryKeyAttribute] === old[association.target.primaryKeyAttribute]\n        )\n      );\n      const unassociatedObjects = targetInstances.filter(obj =>\n        !_.find(oldAssociations, old =>\n          obj[association.target.primaryKeyAttribute] === old[association.target.primaryKeyAttribute]\n        )\n      );\n      let updateWhere;\n      let update;\n\n      if (obsoleteAssociations.length > 0) {\n        update = {};\n        update[association.foreignKey] = null;\n\n        updateWhere = {};\n\n        updateWhere[association.target.primaryKeyAttribute] = obsoleteAssociations.map(associatedObject =>\n          associatedObject[association.target.primaryKeyAttribute]\n        );\n\n        promises.push(association.target.unscoped().update(\n          update,\n          _.defaults({\n            where: updateWhere\n          }, options)\n        ));\n      }\n\n      if (unassociatedObjects.length > 0) {\n        updateWhere = {};\n\n        update = {};\n        update[association.foreignKey] = sourceInstance.get(association.sourceKey);\n\n        _.assign(update, association.scope);\n        updateWhere[association.target.primaryKeyAttribute] = unassociatedObjects.map(unassociatedObject =>\n          unassociatedObject[association.target.primaryKeyAttribute]\n        );\n\n        promises.push(association.target.unscoped().update(\n          update,\n          _.defaults({\n            where: updateWhere\n          }, options)\n        ));\n      }\n\n      return Utils.Promise.all(promises).return(sourceInstance);\n    });\n  }\n\n  /**\n   * Associate one or more target rows with `this`. This method accepts a Model / string / number to associate a single row,\n   * or a mixed array of Model / string / numbers to associate multiple rows.\n   *\n   * @param {Model[]|Model|string[]|string|number[]|number} [newAssociation(s)]\n   * @param {Object} [options] Options passed to `target.update`.\n   * @return {Promise}\n   */\n  add(sourceInstance, targetInstances, options) {\n    if (!targetInstances) return Utils.Promise.resolve();\n\n    const association = this;\n    const update = {};\n    const where = {};\n\n    options = options || {};\n\n    targetInstances = association.toInstanceArray(targetInstances);\n\n    update[association.foreignKey] = sourceInstance.get(association.sourceKey);\n    _.assign(update, association.scope);\n\n    where[association.target.primaryKeyAttribute] = targetInstances.map(unassociatedObject =>\n      unassociatedObject.get(association.target.primaryKeyAttribute)\n    );\n\n    return association.target.unscoped().update(update, _.defaults({where}, options)).return(sourceInstance);\n  }\n\n  /**\n   * Un-associate one or several target rows.\n   *\n   * @param {Model[]|Model|String[]|string|Number[]|number} [oldAssociatedInstance(s)]\n   * @param {Object} [options] Options passed to `target.update`\n   * @return {Promise}\n   */\n  remove(sourceInstance, targetInstances, options) {\n    const association = this;\n    const update = {};\n    const where = {};\n\n    options = options || {};\n    targetInstances = association.toInstanceArray(targetInstances);\n\n    update[association.foreignKey] = null;\n\n    where[association.foreignKey] = sourceInstance.get(association.sourceKey);\n    where[association.target.primaryKeyAttribute] = targetInstances.map(targetInstance =>\n      targetInstance.get(association.target.primaryKeyAttribute)\n    );\n\n    return association.target.unscoped().update(update, _.defaults({where}, options)).return(this);\n  }\n\n  /**\n   * Create a new instance of the associated model and associate it with this.\n   *\n   * @param {Object} [values]\n   * @param {Object} [options] Options passed to `target.create`.\n   * @return {Promise}\n   */\n  create(sourceInstance, values, options) {\n    const association = this;\n\n    options = options || {};\n\n    if (Array.isArray(options)) {\n      options = {\n        fields: options\n      };\n    }\n\n    if (values === undefined) {\n      values = {};\n    }\n\n    if (association.scope) {\n      for (const attribute of Object.keys(association.scope)) {\n        values[attribute] = association.scope[attribute];\n        if (options.fields) options.fields.push(attribute);\n      }\n    }\n\n    values[association.foreignKey] = sourceInstance.get(association.sourceKey);\n    if (options.fields) options.fields.push(association.foreignKey);\n    return association.target.create(values, options);\n  }\n}\n\nmodule.exports = HasMany;\nmodule.exports.HasMany = HasMany;\nmodule.exports.default = HasMany;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/associations/has-many.js\n// module id = 13\n// module chunks = 0","module.exports = require(\"semver\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"semver\"\n// module id = 14\n// module chunks = 0","module.exports = require(\"dotenv\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"dotenv\"\n// module id = 15\n// module chunks = 0","'use strict';\n\nconst _ = require('lodash');\nconst validator = _.cloneDeep(require('validator'));\nconst moment = require('moment');\n\nconst extensions = {\n  extend(name, fn) {\n    this[name] = fn;\n\n    return this;\n  },\n  notEmpty(str) {\n    return !str.match(/^[\\s\\t\\r\\n]*$/);\n  },\n  len(str, min, max) {\n    return this.isLength(str, min, max);\n  },\n  isUrl(str) {\n    return this.isURL(str);\n  },\n  isIPv6(str) {\n    return this.isIP(str, 6);\n  },\n  isIPv4(str) {\n    return this.isIP(str, 4);\n  },\n  notIn(str, values) {\n    return !this.isIn(str, values);\n  },\n  regex(str, pattern, modifiers) {\n    str += '';\n    if (Object.prototype.toString.call(pattern).slice(8, -1) !== 'RegExp') {\n      pattern = new RegExp(pattern, modifiers);\n    }\n    return str.match(pattern);\n  },\n  notRegex(str, pattern, modifiers) {\n    return !this.regex(str, pattern, modifiers);\n  },\n  isDecimal(str) {\n    return str !== '' && !!str.match(/^(?:-?(?:[0-9]+))?(?:\\.[0-9]*)?(?:[eE][\\+\\-]?(?:[0-9]+))?$/);\n  },\n  min(str, val) {\n    const number = parseFloat(str);\n    return isNaN(number) || number >= val;\n  },\n  max(str, val) {\n    const number = parseFloat(str);\n    return isNaN(number) || number <= val;\n  },\n  not(str, pattern, modifiers) {\n    return this.notRegex(str, pattern, modifiers);\n  },\n  contains(str, elem) {\n    return str.indexOf(elem) >= 0 && !!elem;\n  },\n  notContains(str, elem) {\n    return !this.contains(str, elem);\n  },\n  is(str, pattern, modifiers) {\n    return this.regex(str, pattern, modifiers);\n  }\n};\nexports.extensions = extensions;\n\nfunction extendModelValidations(modelInstance) {\n  const extensions = {\n    isImmutable(str, param, field) {\n      return modelInstance.isNewRecord || modelInstance.dataValues[field] === modelInstance._previousDataValues[field];\n    }\n  };\n\n  _.forEach(extensions, (extend, key) => {\n    validator[key] = extend;\n  });\n}\nexports.extendModelValidations = extendModelValidations;\n\n// Deprecate this.\nvalidator.notNull = function() {\n  throw new Error('Warning \"notNull\" validation has been deprecated in favor of Schema based \"allowNull\"');\n};\n\n// https://github.com/chriso/validator.js/blob/6.2.0/validator.js\n_.forEach(extensions, (extend, key) => {\n  validator[key] = extend;\n});\n\n// map isNull to isEmpty\n// https://github.com/chriso/validator.js/commit/e33d38a26ee2f9666b319adb67c7fc0d3dea7125\nvalidator.isNull = validator.isEmpty;\n\n// isDate removed in 7.0.0\n// https://github.com/chriso/validator.js/commit/095509fc707a4dc0e99f85131df1176ad6389fc9\nvalidator.isDate = function(dateString) {\n  // avoid http://momentjs.com/guides/#/warnings/js-date/\n  // by doing a preliminary check on `dateString`\n  const parsed = Date.parse(dateString);\n  if (isNaN(parsed)) {\n    // fail if we can't parse it\n    return false;\n  } else {\n    // otherwise convert to ISO 8601 as moment prefers\n    // http://momentjs.com/docs/#/parsing/string/\n    const date = new Date(parsed);\n    return moment(date.toISOString()).isValid();\n  }\n};\n\nexports.validator = validator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/utils/validator-extras.js\n// module id = 16\n// module chunks = 0","module.exports = require(\"moment\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"moment\"\n// module id = 17\n// module chunks = 0","module.exports = require(\"moment-timezone\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"moment-timezone\"\n// module id = 18\n// module chunks = 0","'use strict';\n\nconst Utils = require('./../utils');\n\nfunction checkNamingCollision(association) {\n  if (association.source.rawAttributes.hasOwnProperty(association.as)) {\n    throw new Error(\n      'Naming collision between attribute \\'' + association.as +\n      '\\' and association \\'' + association.as + '\\' on model ' + association.source.name +\n      '. To remedy this, change either foreignKey or as in your association definition'\n    );\n  }\n}\nexports.checkNamingCollision = checkNamingCollision;\n\nfunction addForeignKeyConstraints(newAttribute, source, target, options, key) {\n  // FK constraints are opt-in: users must either set `foreignKeyConstraints`\n  // on the association, or request an `onDelete` or `onUpdate` behaviour\n\n  if (options.foreignKeyConstraint || options.onDelete || options.onUpdate) {\n\n    // Find primary keys: composite keys not supported with this approach\n    const primaryKeys = Utils._.chain(source.rawAttributes).keys()\n      .filter(key => source.rawAttributes[key].primaryKey)\n      .map(key => source.rawAttributes[key].field || key).value();\n\n    if (primaryKeys.length === 1) {\n      if (source._schema) {\n        newAttribute.references = {\n          model: source.sequelize.getQueryInterface().QueryGenerator.addSchema({\n            tableName: source.tableName,\n            _schema: source._schema,\n            _schemaDelimiter: source._schemaDelimiter\n          })\n        };\n      } else {\n        newAttribute.references = { model: source.tableName };\n      }\n\n      newAttribute.references.key = key || primaryKeys[0];\n      newAttribute.onDelete = options.onDelete;\n      newAttribute.onUpdate = options.onUpdate;\n    }\n  }\n}\nexports.addForeignKeyConstraints = addForeignKeyConstraints;\n\n/**\n * Mixin (inject) association methods to model prototype\n *\n * @private\n * @param {Object} Association instance\n * @param {Object} Model prototype\n * @param {Array} Method names to inject\n * @param {Object} Mapping between model and association method names\n */\nfunction mixinMethods(association, obj, methods, aliases) {\n  aliases = aliases || {};\n\n  for (const method of methods) {\n    // don't override custom methods\n    if (!obj[association.accessors[method]]) {\n      const realMethod = aliases[method] || method;\n\n      obj[association.accessors[method]] = function() {\n        const instance = this;\n        const args = [instance].concat(Array.from(arguments));\n\n        return association[realMethod].apply(association, args);\n      };\n    }\n  }\n}\nexports.mixinMethods = mixinMethods;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/associations/helpers.js\n// module id = 19\n// module chunks = 0","'use strict';\n\nconst Utils = require('./utils');\n\n/**\n * The transaction object is used to identify a running transaction. It is created by calling `Sequelize.transaction()`.\n *\n * To run a query under a transaction, you should pass the transaction in the options object.\n *\n * @see {@link Sequelize.transaction}\n */\nclass Transaction {\n  /**\n   * @param {Sequelize} sequelize A configured sequelize Instance\n   * @param {Object} options An object with options\n   * @param {Boolean} options.autocommit Sets the autocommit property of the transaction.\n   * @param {String} options.type=true Sets the type of the transaction.\n   * @param {String} options.isolationLevel=true Sets the isolation level of the transaction.\n   * @param {String} options.deferrable Sets the constraints to be deferred or immediately checked.\n   */\n  constructor(sequelize, options) {\n    this.sequelize = sequelize;\n    this.savepoints = [];\n\n    // get dialect specific transaction options\n    const transactionOptions = sequelize.dialect.supports.transactionOptions || {};\n    const generateTransactionId = this.sequelize.dialect.QueryGenerator.generateTransactionId;\n\n    this.options = Utils._.extend({\n      autocommit: transactionOptions.autocommit || null,\n      type: sequelize.options.transactionType,\n      isolationLevel: sequelize.options.isolationLevel,\n      readOnly: false\n    }, options || {});\n\n    this.parent = this.options.transaction;\n    this.id = this.parent ? this.parent.id : generateTransactionId();\n\n    if (this.parent) {\n      this.id = this.parent.id;\n      this.parent.savepoints.push(this);\n      this.name = this.id + '-savepoint-' + this.parent.savepoints.length;\n    } else {\n      this.id = this.name = generateTransactionId();\n    }\n\n    delete this.options.transaction;\n  }\n\n  /**\n   * Commit the transaction\n   *\n   * @return {Promise}\n   */\n  commit() {\n\n    if (this.finished) {\n      return Utils.Promise.reject(new Error('Transaction cannot be committed because it has been finished with state: ' + this.finished));\n    }\n\n    this._clearCls();\n\n    return this\n      .sequelize\n      .getQueryInterface()\n      .commitTransaction(this, this.options)\n      .finally(() => {\n        this.finished = 'commit';\n        if (!this.parent) {\n          return this.cleanup();\n        }\n        return null;\n      });\n  }\n\n  /**\n   * Rollback (abort) the transaction\n   *\n   * @return {Promise}\n   */\n  rollback() {\n\n    if (this.finished) {\n      return Utils.Promise.reject(new Error('Transaction cannot be rolled back because it has been finished with state: ' + this.finished));\n    }\n\n    this._clearCls();\n\n    return this\n      .sequelize\n      .getQueryInterface()\n      .rollbackTransaction(this, this.options)\n      .finally(() => {\n        if (!this.parent) {\n          return this.cleanup();\n        }\n        return this;\n      });\n  }\n\n  prepareEnvironment() {\n    let connectionPromise;\n\n    if (this.parent) {\n      connectionPromise = Utils.Promise.resolve(this.parent.connection);\n    } else {\n      const acquireOptions = { uuid: this.id };\n      if (this.options.readOnly) {\n        acquireOptions.type = 'SELECT';\n      }\n      connectionPromise = this.sequelize.connectionManager.getConnection(acquireOptions);\n    }\n\n    return connectionPromise\n      .then(connection => {\n        this.connection = connection;\n        this.connection.uuid = this.id;\n      })\n      .then(() => this.begin())\n      .then(() => this.setDeferrable())\n      .then(() => this.setIsolationLevel())\n      .then(() => this.setAutocommit())\n      .catch(setupErr => this.rollback().finally(() => {\n        throw setupErr;\n      }))\n      .tap(() => {\n        if (this.sequelize.constructor._cls) {\n          this.sequelize.constructor._cls.set('transaction', this);\n        }\n        return null;\n      });\n  }\n\n  begin() {\n    return this\n      .sequelize\n      .getQueryInterface()\n      .startTransaction(this, this.options);\n  }\n\n  setDeferrable() {\n    if (this.options.deferrable) {\n      return this\n        .sequelize\n        .getQueryInterface()\n        .deferConstraints(this, this.options);\n    }\n  }\n\n  setAutocommit() {\n    return this\n      .sequelize\n      .getQueryInterface()\n      .setAutocommit(this, this.options.autocommit, this.options);\n  }\n\n  setIsolationLevel() {\n    return this\n      .sequelize\n      .getQueryInterface()\n      .setIsolationLevel(this, this.options.isolationLevel, this.options);\n  }\n\n  cleanup() {\n    const res = this.sequelize.connectionManager.releaseConnection(this.connection);\n    this.connection.uuid = undefined;\n    return res;\n  }\n\n  _clearCls() {\n    const cls = this.sequelize.constructor._cls;\n\n    if (cls) {\n      if (cls.get('transaction') === this) {\n        cls.set('transaction', null);\n      }\n    }\n  }\n\n  /**\n   * Types can be set per-transaction by passing `options.type` to `sequelize.transaction`.\n   * Default to `DEFERRED` but you can override the default type by passing `options.transactionType` in `new Sequelize`.\n   * Sqlite only.\n   *\n   * Pass in the desired level as the first argument:\n   *\n   * ```js\n   * return sequelize.transaction({type: Sequelize.Transaction.TYPES.EXCLUSIVE}, transaction => {\n   *\n   *  // your transactions\n   *\n   * }).then(result => {\n   *   // transaction has been committed. Do something after the commit if required.\n   * }).catch(err => {\n   *   // do something with the err.\n   * });\n   * ```\n   * @property DEFERRED\n   * @property IMMEDIATE\n   * @property EXCLUSIVE\n   */\n  static get TYPES() {\n    return {\n      DEFERRED: 'DEFERRED',\n      IMMEDIATE: 'IMMEDIATE',\n      EXCLUSIVE: 'EXCLUSIVE'\n    };\n  }\n\n  /**\n   * Isolations levels can be set per-transaction by passing `options.isolationLevel` to `sequelize.transaction`.\n   * Default to `REPEATABLE_READ` but you can override the default isolation level by passing `options.isolationLevel` in `new Sequelize`.\n   *\n   * Pass in the desired level as the first argument:\n   *\n   * ```js\n   * return sequelize.transaction({isolationLevel: Sequelize.Transaction.ISOLATION_LEVELS.SERIALIZABLE}, transaction => {\n *\n *  // your transactions\n *\n * }).then(result => {\n *   // transaction has been committed. Do something after the commit if required.\n * }).catch(err => {\n *   // do something with the err.\n * });\n   * ```\n   * @property READ_UNCOMMITTED\n   * @property READ_COMMITTED\n   * @property REPEATABLE_READ\n   * @property SERIALIZABLE\n   */\n  static get ISOLATION_LEVELS() {\n    return {\n      READ_UNCOMMITTED: 'READ UNCOMMITTED',\n      READ_COMMITTED: 'READ COMMITTED',\n      REPEATABLE_READ: 'REPEATABLE READ',\n      SERIALIZABLE: 'SERIALIZABLE'\n    };\n  }\n\n\n  /**\n   * Possible options for row locking. Used in conjunction with `find` calls:\n   *\n   * ```js\n   * t1 // is a transaction\n   * Model.findAll({\n   *   where: ...,\n   *   transaction: t1,\n   *   lock: t1.LOCK...\n   * });\n   * ```\n   *\n   * Postgres also supports specific locks while eager loading by using OF:\n   * ```js\n   * UserModel.findAll({\n   *   where: ...,\n   *   include: [TaskModel, ...],\n   *   transaction: t1,\n   *   lock: {\n   *     level: t1.LOCK...,\n   *     of: UserModel\n   *   }\n   * });\n   * ```\n   * UserModel will be locked but TaskModel won't!\n   *\n   * @return {Object}\n   * @property UPDATE\n   * @property SHARE\n   * @property KEY_SHARE Postgres 9.3+ only\n   * @property NO_KEY_UPDATE Postgres 9.3+ only\n   */\n  static get LOCK() {\n    return {\n      UPDATE: 'UPDATE',\n      SHARE: 'SHARE',\n      KEY_SHARE: 'KEY SHARE',\n      NO_KEY_UPDATE: 'NO KEY UPDATE'\n    };\n  }\n\n  /**\n   * @see {@link Transaction.LOCK}\n   */\n  get LOCK() {\n    return Transaction.LOCK;\n  }\n}\n\nmodule.exports = Transaction;\nmodule.exports.Transaction = Transaction;\nmodule.exports.default = Transaction;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/transaction.js\n// module id = 20\n// module chunks = 0","'use strict';\n\nconst Utils = require('./../utils');\nconst Helpers = require('./helpers');\nconst _ = require('lodash');\nconst Association = require('./base');\nconst BelongsTo = require('./belongs-to');\nconst HasMany = require('./has-many');\nconst HasOne = require('./has-one');\nconst AssociationError = require('../errors').AssociationError;\n\n/**\n * Many-to-many association with a join table.\n *\n * When the join table has additional attributes, these can be passed in the options object:\n *\n * ```js\n * UserProject = sequelize.define('user_project', {\n *   role: Sequelize.STRING\n * });\n * User.belongsToMany(Project, { through: UserProject });\n * Project.belongsToMany(User, { through: UserProject });\n * // through is required!\n *\n * user.addProject(project, { through: { role: 'manager' }});\n * ```\n *\n * All methods allow you to pass either a persisted instance, its primary key, or a mixture:\n *\n * ```js\n * Project.create({ id: 11 }).then(function (project) {\n *   user.addProjects([project, 12]);\n * });\n * ```\n *\n * If you want to set several target instances, but with different attributes you have to set the attributes on the instance, using a property with the name of the through model:\n *\n * ```js\n * p1.UserProjects = {\n *   started: true\n * }\n * user.setProjects([p1, p2], { through: { started: false }}) // The default value is false, but p1 overrides that.\n * ```\n *\n * Similarly, when fetching through a join table with custom attributes, these attributes will be available as an object with the name of the through model.\n * ```js\n * user.getProjects().then(function (projects) {\n   *   let p1 = projects[0]\n   *   p1.UserProjects.started // Is this project started yet?\n   * })\n * ```\n *\n * In the API reference below, add the name of the association to the method, e.g. for `User.belongsToMany(Project)` the getter will be `user.getProjects()`.\n *\n * @see {@link Model.belongsToMany}\n */\nclass BelongsToMany extends Association {\n  constructor(source, target, options) {\n    super(source, target, options);\n\n    if (this.options.through === undefined || this.options.through === true || this.options.through === null) {\n      throw new AssociationError('belongsToMany must be given a through option, either a string or a model');\n    }\n\n    if (!this.options.through.model) {\n      this.options.through = {\n        model: options.through\n      };\n    }\n\n    this.associationType = 'BelongsToMany';\n    this.targetAssociation = null;\n    this.sequelize = source.sequelize;\n    this.through = _.assign({}, this.options.through);\n    this.isMultiAssociation = true;\n    this.doubleLinked = false;\n\n    if (!this.as && this.isSelfAssociation) {\n      throw new AssociationError('\\'as\\' must be defined for many-to-many self-associations');\n    }\n\n    if (this.as) {\n      this.isAliased = true;\n\n      if (Utils._.isPlainObject(this.as)) {\n        this.options.name = this.as;\n        this.as = this.as.plural;\n      } else {\n        this.options.name = {\n          plural: this.as,\n          singular: Utils.singularize(this.as)\n        };\n      }\n    } else {\n      this.as = this.target.options.name.plural;\n      this.options.name = this.target.options.name;\n    }\n\n    this.combinedTableName = Utils.combineTableNames(\n      this.source.tableName,\n      this.isSelfAssociation ? this.as || this.target.tableName : this.target.tableName\n    );\n\n    /*\n    * If self association, this is the target association - Unless we find a pairing association\n    */\n    if (this.isSelfAssociation) {\n      this.targetAssociation = this;\n    }\n\n    /*\n    * Default/generated foreign/other keys\n    */\n    if (_.isObject(this.options.foreignKey)) {\n      this.foreignKeyAttribute = this.options.foreignKey;\n      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n    } else {\n      if (!this.options.foreignKey) {\n        this.foreignKeyDefault = true;\n      }\n\n      this.foreignKeyAttribute = {};\n      this.foreignKey = this.options.foreignKey || Utils.camelizeIf(\n        [\n          Utils.underscoredIf(this.source.options.name.singular, this.source.options.underscored),\n          this.source.primaryKeyAttribute\n        ].join('_'),\n        !this.source.options.underscored\n      );\n    }\n\n    if (_.isObject(this.options.otherKey)) {\n      this.otherKeyAttribute = this.options.otherKey;\n      this.otherKey = this.otherKeyAttribute.name || this.otherKeyAttribute.fieldName;\n    } else {\n      if (!this.options.otherKey) {\n        this.otherKeyDefault = true;\n      }\n\n      this.otherKeyAttribute = {};\n      this.otherKey = this.options.otherKey || Utils.camelizeIf(\n        [\n          Utils.underscoredIf(\n            this.isSelfAssociation ?\n              Utils.singularize(this.as) :\n              this.target.options.name.singular,\n            this.target.options.underscored\n          ),\n          this.target.primaryKeyAttribute\n        ].join('_'),\n        !this.target.options.underscored\n      );\n    }\n\n    /*\n    * Find paired association (if exists)\n    */\n    _.each(this.target.associations, association => {\n      if (association.associationType !== 'BelongsToMany') return;\n      if (association.target !== this.source) return;\n\n      if (this.options.through.model === association.options.through.model) {\n        this.paired = association;\n        association.paired = this;\n      }\n    });\n\n    if (typeof this.through.model === 'string') {\n      if (!this.sequelize.isDefined(this.through.model)) {\n        this.through.model = this.sequelize.define(this.through.model, {}, _.extend(this.options, {\n          tableName: this.through.model,\n          indexes: [], //we don't want indexes here (as referenced in #2416)\n          paranoid: false,  // A paranoid join table does not make sense\n          validate: {} // Don't propagate model-level validations\n        }));\n      } else {\n        this.through.model = this.sequelize.model(this.through.model);\n      }\n    }\n\n    this.options = Object.assign(this.options, _.pick(this.through.model.options, [\n      'timestamps', 'createdAt', 'updatedAt', 'deletedAt', 'paranoid'\n    ]));\n\n    if (this.paired) {\n      if (this.otherKeyDefault) {\n        this.otherKey = this.paired.foreignKey;\n      }\n      if (this.paired.otherKeyDefault) {\n        // If paired otherKey was inferred we should make sure to clean it up before adding a new one that matches the foreignKey\n        if (this.paired.otherKey !== this.foreignKey) {\n          delete this.through.model.rawAttributes[this.paired.otherKey];\n        }\n        this.paired.otherKey = this.foreignKey;\n        this.paired.foreignIdentifier = this.foreignKey;\n        delete this.paired.foreignIdentifierField;\n      }\n    }\n\n    if (this.through) {\n      this.throughModel = this.through.model;\n    }\n\n    this.options.tableName = this.combinedName = this.through.model === Object(this.through.model) ? this.through.model.tableName : this.through.model;\n\n    this.associationAccessor = this.as;\n\n    // Get singular and plural names, trying to uppercase the first letter, unless the model forbids it\n    const plural = Utils.uppercaseFirst(this.options.name.plural);\n    const singular = Utils.uppercaseFirst(this.options.name.singular);\n\n    this.accessors = {\n      get: 'get' + plural,\n      set: 'set' + plural,\n      addMultiple: 'add' + plural,\n      add: 'add' + singular,\n      create: 'create' + singular,\n      remove: 'remove' + singular,\n      removeMultiple: 'remove' + plural,\n      hasSingle: 'has' + singular,\n      hasAll: 'has' + plural,\n      count: 'count' + plural\n    };\n  }\n\n  // the id is in the target table\n  // or in an extra table which connects two tables\n  injectAttributes() {\n\n    this.identifier = this.foreignKey;\n    this.foreignIdentifier = this.otherKey;\n\n    // remove any PKs previously defined by sequelize\n    // but ignore any keys that are part of this association (#5865)\n    _.each(this.through.model.rawAttributes, (attribute, attributeName) => {\n      if (attribute.primaryKey === true && attribute._autoGenerated === true) {\n        if (attributeName === this.foreignKey || attributeName === this.otherKey) {\n          // this key is still needed as it's part of the association\n          // so just set primaryKey to false\n          attribute.primaryKey = false;\n        }\n        else {\n          delete this.through.model.rawAttributes[attributeName];\n        }\n        this.primaryKeyDeleted = true;\n      }\n    });\n\n    const sourceKey = this.source.rawAttributes[this.source.primaryKeyAttribute];\n    const sourceKeyType = sourceKey.type;\n    const sourceKeyField = sourceKey.field || this.source.primaryKeyAttribute;\n    const targetKey = this.target.rawAttributes[this.target.primaryKeyAttribute];\n    const targetKeyType = targetKey.type;\n    const targetKeyField = targetKey.field || this.target.primaryKeyAttribute;\n    const sourceAttribute = _.defaults({}, this.foreignKeyAttribute, { type: sourceKeyType });\n    const targetAttribute = _.defaults({}, this.otherKeyAttribute, { type: targetKeyType });\n\n    if (this.primaryKeyDeleted === true) {\n      targetAttribute.primaryKey = sourceAttribute.primaryKey = true;\n    } else if (this.through.unique !== false) {\n      const uniqueKey = [this.through.model.tableName, this.foreignKey, this.otherKey, 'unique'].join('_');\n      targetAttribute.unique = sourceAttribute.unique = uniqueKey;\n    }\n\n    if (!this.through.model.rawAttributes[this.foreignKey]) {\n      this.through.model.rawAttributes[this.foreignKey] = {\n        _autoGenerated: true\n      };\n    }\n\n    if (!this.through.model.rawAttributes[this.otherKey]) {\n      this.through.model.rawAttributes[this.otherKey] = {\n        _autoGenerated: true\n      };\n    }\n\n    if (this.options.constraints !== false) {\n      sourceAttribute.references = {\n        model: this.source.getTableName(),\n        key:   sourceKeyField\n      };\n      // For the source attribute the passed option is the priority\n      sourceAttribute.onDelete = this.options.onDelete || this.through.model.rawAttributes[this.foreignKey].onDelete;\n      sourceAttribute.onUpdate = this.options.onUpdate || this.through.model.rawAttributes[this.foreignKey].onUpdate;\n\n      if (!sourceAttribute.onDelete) sourceAttribute.onDelete = 'CASCADE';\n      if (!sourceAttribute.onUpdate) sourceAttribute.onUpdate = 'CASCADE';\n\n      targetAttribute.references = {\n        model: this.target.getTableName(),\n        key:   targetKeyField\n      };\n      // But the for target attribute the previously defined option is the priority (since it could've been set by another belongsToMany call)\n      targetAttribute.onDelete = this.through.model.rawAttributes[this.otherKey].onDelete || this.options.onDelete;\n      targetAttribute.onUpdate = this.through.model.rawAttributes[this.otherKey].onUpdate || this.options.onUpdate;\n\n      if (!targetAttribute.onDelete) targetAttribute.onDelete = 'CASCADE';\n      if (!targetAttribute.onUpdate) targetAttribute.onUpdate = 'CASCADE';\n    }\n\n    this.through.model.rawAttributes[this.foreignKey] = _.extend(this.through.model.rawAttributes[this.foreignKey], sourceAttribute);\n    this.through.model.rawAttributes[this.otherKey] = _.extend(this.through.model.rawAttributes[this.otherKey], targetAttribute);\n\n    this.identifierField = this.through.model.rawAttributes[this.foreignKey].field || this.foreignKey;\n    this.foreignIdentifierField = this.through.model.rawAttributes[this.otherKey].field || this.otherKey;\n\n    if (this.paired && !this.paired.foreignIdentifierField) {\n      this.paired.foreignIdentifierField = this.through.model.rawAttributes[this.paired.otherKey].field || this.paired.otherKey;\n    }\n\n    this.through.model.refreshAttributes();\n\n    this.toSource = new BelongsTo(this.through.model, this.source, {\n      foreignKey: this.foreignKey\n    });\n    this.manyFromSource = new HasMany(this.source, this.through.model, {\n      foreignKey: this.foreignKey\n    });\n    this.oneFromSource = new HasOne(this.source, this.through.model, {\n      foreignKey: this.foreignKey,\n      as: this.through.model.name\n    });\n\n    this.toTarget = new BelongsTo(this.through.model, this.target, {\n      foreignKey: this.otherKey\n    });\n    this.manyFromTarget = new HasMany(this.target, this.through.model, {\n      foreignKey: this.otherKey\n    });\n    this.oneFromTarget = new HasOne(this.target, this.through.model, {\n      foreignKey: this.otherKey,\n      as: this.through.model.name\n    });\n\n    if (this.paired && this.paired.otherKeyDefault) {\n      this.paired.toTarget = new BelongsTo(this.paired.through.model, this.paired.target, {\n        foreignKey: this.paired.otherKey\n      });\n\n      this.paired.oneFromTarget = new HasOne(this.paired.target, this.paired.through.model, {\n        foreignKey: this.paired.otherKey,\n        as: this.paired.through.model.name\n      });\n    }\n\n    Helpers.checkNamingCollision(this);\n\n    return this;\n  }\n\n  mixin(obj) {\n    const methods = ['get', 'count', 'hasSingle', 'hasAll', 'set', 'add', 'addMultiple', 'remove', 'removeMultiple', 'create'];\n    const aliases = {\n      hasSingle: 'has',\n      hasAll: 'has',\n      addMultiple: 'add',\n      removeMultiple: 'remove'\n    };\n\n    Helpers.mixinMethods(this, obj, methods, aliases);\n  }\n\n  /**\n   * Get everything currently associated with this, using an optional where clause.\n   *\n   * @param {Object} [options]\n   * @param {Object} [options.where] An optional where clause to limit the associated models\n   * @param {String|Boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n   * @param {String} [options.schema] Apply a schema on the related model\n   * @see {@link Model.findAll}  for a full explanation of options\n   * @return {Promise<Array<Model>>}\n   */\n  get(instance, options) {\n    options = Utils.cloneDeep(options) || {};\n\n    const association = this;\n    const through = association.through;\n    let scopeWhere;\n    let throughWhere;\n\n    if (association.scope) {\n      scopeWhere = _.clone(association.scope);\n    }\n\n    options.where = {\n      $and: [\n        scopeWhere,\n        options.where\n      ]\n    };\n\n    if (Object(through.model) === through.model) {\n      throughWhere = {};\n      throughWhere[association.foreignKey] = instance.get(association.source.primaryKeyAttribute);\n\n      if (through.scope) {\n        _.assign(throughWhere, through.scope);\n      }\n\n      //If a user pass a where on the options through options, make an \"and\" with the current throughWhere\n      if (options.through && options.through.where) {\n        throughWhere = {\n          $and: [throughWhere, options.through.where]\n        };\n      }\n\n      options.include = options.include || [];\n      options.include.push({\n        association: association.oneFromTarget,\n        attributes: options.joinTableAttributes,\n        required: true,\n        where: throughWhere\n      });\n    }\n\n    let model = association.target;\n    if (options.hasOwnProperty('scope')) {\n      if (!options.scope) {\n        model = model.unscoped();\n      } else {\n        model = model.scope(options.scope);\n      }\n    }\n\n    if (options.hasOwnProperty('schema')) {\n      model = model.schema(options.schema, options.schemaDelimiter);\n    }\n\n    return model.findAll(options);\n  }\n\n  /**\n   * Count everything currently associated with this, using an optional where clause.\n   *\n   * @param {Object} [options]\n   * @param {Object} [options.where] An optional where clause to limit the associated models\n   * @param {String|Boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n   * @return {Promise<Integer>}\n   */\n  count(instance, options) {\n    const association = this;\n    const model = association.target;\n    const sequelize = model.sequelize;\n\n    options = Utils.cloneDeep(options);\n    options.attributes = [\n      [sequelize.fn('COUNT', sequelize.col([association.target.name, model.primaryKeyField].join('.'))), 'count']\n    ];\n    options.joinTableAttributes = [];\n    options.raw = true;\n    options.plain = true;\n\n    return association.get(instance, options).then(result => parseInt(result.count, 10));\n  }\n\n  /**\n   * Check if one or more instance(s) are associated with this. If a list of instances is passed, the function returns true if _all_ instances are associated\n   *\n   * @param {Model[]|Model|string[]|String|number[]|Number} [instance(s)] Can be an array of instances or their primary keys\n   * @param {Object} [options] Options passed to getAssociations\n   * @return {Promise<boolean>}\n   */\n  has(sourceInstance, instances, options) {\n    const association = this;\n    const where = {};\n\n    if (!Array.isArray(instances)) {\n      instances = [instances];\n    }\n\n    options = _.assign({\n      raw: true\n    }, options, {\n      scope: false\n    });\n\n    where.$or = instances.map(instance => {\n      if (instance instanceof association.target) {\n        return instance.where();\n      } else {\n        const where = {};\n        where[association.target.primaryKeyAttribute] = instance;\n        return where;\n      }\n    });\n\n    options.where = {\n      $and: [\n        where,\n        options.where\n      ]\n    };\n\n    return association.get(sourceInstance, options).then(associatedObjects => associatedObjects.length === instances.length);\n  }\n\n  /**\n   * Set the associated models by passing an array of instances or their primary keys. Everything that it not in the passed array will be un-associated.\n   *\n   * @param {Array<Model|String|Number>} [newAssociations] An array of persisted instances or primary key of instances to associate with this. Pass `null` or `undefined` to remove all associations.\n   * @param {Object} [options] Options passed to `through.findAll`, `bulkCreate`, `update` and `destroy`\n   * @param {Object} [options.validate] Run validation for the join model\n   * @param {Object} [options.through] Additional attributes for the join table.\n   * @return {Promise}\n   */\n  set(sourceInstance, newAssociatedObjects, options) {\n    options = options || {};\n\n    const association = this;\n    const sourceKey = association.source.primaryKeyAttribute;\n    const targetKey = association.target.primaryKeyAttribute;\n    const identifier = association.identifier;\n    const foreignIdentifier = association.foreignIdentifier;\n    let where = {};\n\n    if (newAssociatedObjects === null) {\n      newAssociatedObjects = [];\n    } else {\n      newAssociatedObjects = association.toInstanceArray(newAssociatedObjects);\n    }\n\n    where[identifier] = sourceInstance.get(sourceKey);\n    where = Object.assign(where, association.through.scope);\n\n    return association.through.model.findAll(_.defaults({where, raw: true}, options)).then(currentRows => {\n      const obsoleteAssociations = [];\n      const promises = [];\n      let defaultAttributes = options.through || {};\n\n      // Don't try to insert the transaction as an attribute in the through table\n      defaultAttributes = _.omit(defaultAttributes, ['transaction', 'hooks', 'individualHooks', 'ignoreDuplicates', 'validate', 'fields', 'logging']);\n\n      const unassociatedObjects = newAssociatedObjects.filter(obj =>\n        !_.find(currentRows, currentRow => currentRow[foreignIdentifier] === obj.get(targetKey))\n      );\n\n      for (const currentRow of currentRows) {\n        const newObj = _.find(newAssociatedObjects, obj => currentRow[foreignIdentifier] === obj.get(targetKey));\n\n        if (!newObj) {\n          obsoleteAssociations.push(currentRow);\n        } else {\n          let throughAttributes = newObj[association.through.model.name];\n          // Quick-fix for subtle bug when using existing objects that might have the through model attached (not as an attribute object)\n          if (throughAttributes instanceof association.through.model) {\n            throughAttributes = {};\n          }\n\n          const where = {};\n          const attributes = _.defaults({}, throughAttributes, defaultAttributes);\n\n          where[identifier] = sourceInstance.get(sourceKey);\n          where[foreignIdentifier] = newObj.get(targetKey);\n\n          if (Object.keys(attributes).length) {\n            promises.push(association.through.model.update(attributes, _.extend(options, {where})));\n          }\n        }\n      }\n\n      if (obsoleteAssociations.length > 0) {\n        let where = {};\n        where[identifier] = sourceInstance.get(sourceKey);\n        where[foreignIdentifier] = obsoleteAssociations.map(obsoleteAssociation => obsoleteAssociation[foreignIdentifier]);\n        where = Object.assign(where, association.through.scope);\n        promises.push(association.through.model.destroy(_.defaults({where}, options)));\n      }\n\n      if (unassociatedObjects.length > 0) {\n        const bulk = unassociatedObjects.map(unassociatedObject => {\n          let attributes = {};\n\n          attributes[identifier] = sourceInstance.get(sourceKey);\n          attributes[foreignIdentifier] = unassociatedObject.get(targetKey);\n\n          attributes = _.defaults(attributes, unassociatedObject[association.through.model.name], defaultAttributes);\n\n          _.assign(attributes, association.through.scope);\n          attributes = Object.assign(attributes, association.through.scope);\n\n          return attributes;\n        });\n\n        promises.push(association.through.model.bulkCreate(bulk, _.assign({ validate: true }, options)));\n      }\n\n      return Utils.Promise.all(promises);\n    });\n  }\n\n  /**\n   * Associate one ore several rows with `this`.\n   *\n   * @param {Model[]|Model|string[]|string|number[]|Number} [newAssociation(s)] A single instance or primary key, or a mixed array of persisted instances or primary keys\n   * @param {Object} [options] Options passed to `through.findAll`, `bulkCreate` and `update`\n   * @param {Object} [options.validate] Run validation for the join model.\n   * @param {Object} [options.through] Additional attributes for the join table.\n   * @return {Promise}\n   */\n  add(sourceInstance, newInstances, options) {\n    // If newInstances is null or undefined, no-op\n    if (!newInstances) return Utils.Promise.resolve();\n\n    options = _.clone(options) || {};\n\n    const association = this;\n    const sourceKey = association.source.primaryKeyAttribute;\n    const targetKey = association.target.primaryKeyAttribute;\n    const identifier = association.identifier;\n    const foreignIdentifier = association.foreignIdentifier;\n    const defaultAttributes = _.omit(options.through || {}, ['transaction', 'hooks', 'individualHooks', 'ignoreDuplicates', 'validate', 'fields', 'logging']);\n\n    newInstances = association.toInstanceArray(newInstances);\n\n    const where = {};\n    where[identifier] = sourceInstance.get(sourceKey);\n    where[foreignIdentifier] = newInstances.map(newInstance => newInstance.get(targetKey));\n\n    _.assign(where, association.through.scope);\n\n    return association.through.model.findAll(_.defaults({where, raw: true}, options)).then(currentRows => {\n      const promises = [];\n      const unassociatedObjects = [];\n      const changedAssociations = [];\n      for (const obj of newInstances) {\n        const existingAssociation = _.find(currentRows, current => current[foreignIdentifier] === obj.get(targetKey));\n\n        if (!existingAssociation) {\n          unassociatedObjects.push(obj);\n        } else {\n          const throughAttributes = obj[association.through.model.name];\n          const attributes = _.defaults({}, throughAttributes, defaultAttributes);\n\n          if (_.some(Object.keys(attributes), attribute => attributes[attribute] !== existingAssociation[attribute])) {\n            changedAssociations.push(obj);\n          }\n        }\n      }\n\n      if (unassociatedObjects.length > 0) {\n        const bulk = unassociatedObjects.map(unassociatedObject => {\n          const throughAttributes = unassociatedObject[association.through.model.name];\n          const attributes = _.defaults({}, throughAttributes, defaultAttributes);\n\n          attributes[identifier] = sourceInstance.get(sourceKey);\n          attributes[foreignIdentifier] = unassociatedObject.get(targetKey);\n\n          _.assign(attributes, association.through.scope);\n\n          return attributes;\n        });\n\n        promises.push(association.through.model.bulkCreate(bulk, _.assign({ validate: true }, options)));\n      }\n\n      for (const assoc of changedAssociations) {\n        let throughAttributes = assoc[association.through.model.name];\n        const attributes = _.defaults({}, throughAttributes, defaultAttributes);\n        const where = {};\n        // Quick-fix for subtle bug when using existing objects that might have the through model attached (not as an attribute object)\n        if (throughAttributes instanceof association.through.model) {\n          throughAttributes = {};\n        }\n\n        where[identifier] = sourceInstance.get(sourceKey);\n        where[foreignIdentifier] = assoc.get(targetKey);\n\n        promises.push(association.through.model.update(attributes, _.extend(options, {where})));\n      }\n\n      return Utils.Promise.all(promises);\n    });\n  }\n\n  /**\n   * Un-associate one or more instance(s).\n   *\n   * @param {Model|String|Number} [oldAssociated] Can be an Instance or its primary key, or a mixed array of instances and primary keys\n   * @param {Object} [options] Options passed to `through.destroy`\n   * @return {Promise}\n   */\n  remove(sourceInstance, oldAssociatedObjects, options) {\n    const association = this;\n\n    options = options || {};\n\n    oldAssociatedObjects = association.toInstanceArray(oldAssociatedObjects);\n\n    const where = {};\n    where[association.identifier] = sourceInstance.get(association.source.primaryKeyAttribute);\n    where[association.foreignIdentifier] = oldAssociatedObjects.map(newInstance => newInstance.get(association.target.primaryKeyAttribute));\n\n    return association.through.model.destroy(_.defaults({where}, options));\n  }\n\n  /**\n   * Create a new instance of the associated model and associate it with this.\n   *\n   * @param {Object} [values]\n   * @param {Object} [options] Options passed to create and add\n   * @param {Object} [options.through] Additional attributes for the join table\n   * @return {Promise}\n   */\n  create(sourceInstance, values, options) {\n    const association = this;\n\n    options = options || {};\n    values = values || {};\n\n    if (Array.isArray(options)) {\n      options = {\n        fields: options\n      };\n    }\n\n    if (association.scope) {\n      _.assign(values, association.scope);\n      if (options.fields) {\n        options.fields = options.fields.concat(Object.keys(association.scope));\n      }\n    }\n\n    // Create the related model instance\n    return association.target.create(values, options).then(newAssociatedObject =>\n      sourceInstance[association.accessors.add](newAssociatedObject, _.omit(options, ['fields'])).return(newAssociatedObject)\n    );\n  }\n}\n\nmodule.exports = BelongsToMany;\nmodule.exports.BelongsToMany = BelongsToMany;\nmodule.exports.default = BelongsToMany;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/associations/belongs-to-many.js\n// module id = 21\n// module chunks = 0","'use strict';\n\nclass AbstractDialect {}\n\nAbstractDialect.prototype.supports = {\n  'DEFAULT': true,\n  'DEFAULT VALUES': false,\n  'VALUES ()': false,\n  'LIMIT ON UPDATE': false,\n  'ON DUPLICATE KEY': true,\n  'ORDER NULLS': false,\n  'UNION': true,\n  'UNION ALL': true,\n  /* What is the dialect's keyword for INSERT IGNORE */\n  'IGNORE': '',\n\n  /* does the dialect support returning values for inserted/updated fields */\n  returnValues: false,\n\n  /* features specific to autoIncrement values */\n  autoIncrement: {\n    /* does the dialect require modification of insert queries when inserting auto increment fields */\n    identityInsert: false,\n\n    /* does the dialect support inserting default/null values for autoincrement fields */\n    defaultValue: true,\n\n    /* does the dialect support updating autoincrement fields */\n    update: true\n  },\n  /* Do we need to say DEFAULT for bulk insert */\n  bulkDefault: false,\n  /* The dialect's words for INSERT IGNORE */\n  ignoreDuplicates: '',\n  /* Does the dialect support ON DUPLICATE KEY UPDATE */\n  updateOnDuplicate: false,\n  schemas: false,\n  transactions: true,\n  transactionOptions: {\n    type: false\n  },\n  migrations: true,\n  upserts: true,\n  constraints: {\n    restrict: true,\n    addConstraint: true,\n    dropConstraint: true,\n    unique: true,\n    default: false,\n    check: true,\n    foreignKey: true,\n    primaryKey: true\n  },\n  index: {\n    collate: true,\n    length: false,\n    parser: false,\n    concurrently: false,\n    type: false,\n    using: true\n  },\n  joinTableDependent: true,\n  groupedLimit: true,\n  indexViaAlter: false,\n  JSON: false,\n  deferrableConstraints: false\n};\n\nmodule.exports = AbstractDialect;\nmodule.exports.AbstractDialect = AbstractDialect;\nmodule.exports.default = AbstractDialect;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/dialects/abstract/index.js\n// module id = 22\n// module chunks = 0","'use strict';\n\nconst Pooling = require('generic-pool');\nconst Promise = require('../../promise');\nconst _ = require('lodash');\nconst Utils = require('../../utils');\nconst debug = Utils.getLogger().debugContext('pool');\nconst semver = require('semver');\nconst timers = require('timers');\n\nconst defaultPoolingConfig = {\n  max: 5,\n  min: 0,\n  idle: 10000,\n  acquire: 10000,\n  evict: 60000,\n  handleDisconnects: true\n};\n\nclass ConnectionManager {\n  constructor(dialect, sequelize) {\n    const config = _.cloneDeep(sequelize.config);\n\n    this.sequelize = sequelize;\n    this.config = config;\n    this.dialect = dialect;\n    this.versionPromise = null;\n    this.poolError = null;\n    this.dialectName = this.sequelize.options.dialect;\n\n    if (config.pool === false) {\n      throw new Error('Support for pool:false was removed in v4.0');\n    }\n\n    config.pool =_.defaults(config.pool || {}, defaultPoolingConfig, {\n      validate: this._validate.bind(this),\n      Promise\n    }) ;\n\n    // Save a reference to the bound version so we can remove it with removeListener\n    this.onProcessExit = this.onProcessExit.bind(this);\n\n    process.on('exit', this.onProcessExit);\n\n    this.initPools();\n  }\n\n  refreshTypeParser(dataTypes) {\n    _.each(dataTypes, dataType => {\n      if (dataType.hasOwnProperty('parse')) {\n        if (dataType.types[this.dialectName]) {\n          this._refreshTypeParser(dataType);\n        } else {\n          throw new Error('Parse function not supported for type ' + dataType.key + ' in dialect ' + this.dialectName);\n        }\n      }\n    });\n  }\n\n  onProcessExit() {\n    if (!this.pool) {\n      return Promise.resolve();\n    }\n\n    return this.pool.drain().then(() => {\n      debug('connection drain due to process exit');\n      return this.pool.clear();\n    });\n  }\n\n  close() {\n    // Remove the listener, so all references to this instance can be garbage collected.\n    process.removeListener('exit', this.onProcessExit);\n\n    // Mark close of pool\n    this.getConnection = function getConnection() {\n      return Promise.reject(new Error('ConnectionManager.getConnection was called after the connection manager was closed!'));\n    };\n\n    return this.onProcessExit();\n  }\n\n  initPools() {\n    const config = this.config;\n\n    if (!config.replication) {\n      this.pool = Pooling.createPool({\n        create: () => new Promise(resolve => {\n          this\n            ._connect(config)\n            .tap(() => {\n              this.poolError = null;\n            })\n            .then(resolve)\n            .catch(e => {\n              // dont throw otherwise pool will release _dispense call\n              // which will call _connect even if error is fatal\n              // https://github.com/coopernurse/node-pool/issues/161\n              this.poolError = e;\n            });\n        }),\n        destroy: connection => {\n          return this._disconnect(connection).tap(() => {\n            debug('connection destroy');\n          });\n        },\n        validate: config.pool.validate\n      }, {\n        Promise: config.pool.Promise,\n        max: config.pool.max,\n        min: config.pool.min,\n        testOnBorrow: true,\n        autostart: false,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        evictionRunIntervalMillis: config.pool.evict\n      });\n\n      this.pool.on('factoryCreateError', error => {\n        this.poolError = error;\n      });\n\n      debug(`pool created max/min: ${config.pool.max}/${config.pool.min} with no replication`);\n      return;\n    }\n\n    let reads = 0;\n\n    if (!Array.isArray(config.replication.read)) {\n      config.replication.read = [config.replication.read];\n    }\n\n    // Map main connection config\n    config.replication.write = _.defaults(config.replication.write, _.omit(config, 'replication'));\n\n    // Apply defaults to each read config\n    config.replication.read = _.map(config.replication.read, readConfig =>\n      _.defaults(readConfig, _.omit(this.config, 'replication'))\n    );\n\n    // custom pooling for replication (original author @janmeier)\n    this.pool = {\n      release: client => {\n        if (client.queryType === 'read') {\n          return this.pool.read.release(client);\n        } else {\n          return this.pool.write.release(client);\n        }\n      },\n      acquire: (priority, queryType, useMaster) => {\n        useMaster = _.isUndefined(useMaster) ? false : useMaster;\n        if (queryType === 'SELECT' && !useMaster) {\n          return this.pool.read.acquire(priority);\n        } else {\n          return this.pool.write.acquire(priority);\n        }\n      },\n      destroy: connection => {\n        debug('connection destroy');\n        return this.pool[connection.queryType].destroy(connection);\n      },\n      clear: () => {\n        debug('all connection clear');\n        return Promise.join(\n          this.pool.read.clear(),\n          this.pool.write.clear()\n        );\n      },\n      drain: () => {\n        return Promise.join(\n          this.pool.write.drain(),\n          this.pool.read.drain()\n        );\n      },\n      read: Pooling.createPool({\n        create: () => {\n          const nextRead = reads++ % config.replication.read.length; // round robin config\n          return new Promise(resolve => {\n            this\n              ._connect(config.replication.read[nextRead])\n              .tap(connection => {\n                connection.queryType = 'read';\n                this.poolError = null;\n                resolve(connection);\n              })\n              .catch(e => {\n                this.poolError = e;\n              });\n          });\n        },\n        destroy: connection => {\n          return this._disconnect(connection);\n        },\n        validate: config.pool.validate\n      }, {\n        Promise: config.pool.Promise,\n        max: config.pool.max,\n        min: config.pool.min,\n        testOnBorrow: true,\n        autostart: false,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        evictionRunIntervalMillis: config.pool.evict\n      }),\n      write: Pooling.createPool({\n        create: () => new Promise(resolve => {\n          this\n            ._connect(config.replication.write)\n            .then(connection => {\n              connection.queryType = 'write';\n              this.poolError = null;\n              return resolve(connection);\n            })\n            .catch(e => {\n              this.poolError = e;\n            });\n        }),\n        destroy: connection => {\n          return this._disconnect(connection);\n        },\n        validate: config.pool.validate\n      }, {\n        Promise: config.pool.Promise,\n        max: config.pool.max,\n        min: config.pool.min,\n        testOnBorrow: true,\n        autostart: false,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        evictionRunIntervalMillis: config.pool.evict\n      })\n    };\n\n    this.pool.read.on('factoryCreateError', error => {\n      this.poolError = error;\n    });\n\n    this.pool.write.on('factoryCreateError', error => {\n      this.poolError = error;\n    });\n  }\n\n  getConnection(options) {\n    options = options || {};\n\n    let promise;\n    if (this.sequelize.options.databaseVersion === 0) {\n      if (this.versionPromise) {\n        promise = this.versionPromise;\n      } else {\n        promise = this.versionPromise = this._connect(this.config.replication.write || this.config).then(connection => {\n          const _options = {};\n          _options.transaction = {connection}; // Cheat .query to use our private connection\n          _options.logging = () => {};\n          _options.logging.__testLoggingFn = true;\n\n          return this.sequelize.databaseVersion(_options).then(version => {\n            this.sequelize.options.databaseVersion = semver.valid(version) ? version : this.defaultVersion;\n            this.versionPromise = null;\n\n            return this._disconnect(connection);\n          });\n        }).catch(err => {\n          this.versionPromise = null;\n          throw err;\n        });\n      }\n    } else {\n      promise = Promise.resolve();\n    }\n\n    return promise.then(() => {\n      return Promise.race([\n        this.pool.acquire(options.priority, options.type, options.useMaster),\n        new Promise((resolve, reject) =>\n          timers.setTimeout(() => {\n            if (this.poolError) {\n              reject(this.poolError);\n            }\n          }, 0))\n      ])\n        .tap(() => { debug('connection acquired'); })\n        .catch(e => {\n          e = this.poolError || e;\n          this.poolError = null;\n          throw e;\n        });\n    });\n  }\n\n  releaseConnection(connection) {\n    return this.pool.release(connection).tap(() => {\n      debug('connection released');\n    });\n  }\n\n  _connect(config) {\n    return this.sequelize.runHooks('beforeConnect', config)\n      .then(() => this.dialect.connectionManager.connect(config))\n      .then(connection => this.sequelize.runHooks('afterConnect', connection, config).return(connection));\n  }\n\n  _disconnect(connection) {\n    return this.dialect.connectionManager.disconnect(connection);\n  }\n\n  _validate(connection) {\n    if (!this.dialect.connectionManager.validate) return true;\n    return this.dialect.connectionManager.validate(connection);\n  }\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/dialects/abstract/connection-manager.js\n// module id = 23\n// module chunks = 0","'use strict';\n\nconst stores = new Map();\n\nmodule.exports = dialect => {\n\n  if (!stores.has(dialect)) {\n    stores.set(dialect, new Map());\n  }\n\n  return {\n    clear() {\n      stores.get(dialect).clear();\n    },\n    refresh(dataType) {\n      for (const type of dataType.types[dialect]) {\n        stores.get(dialect).set(type, dataType.parse);\n      }\n    },\n    get(type) {\n      return stores.get(dialect).get(type);\n    }\n  };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/dialects/parserStore.js\n// module id = 24\n// module chunks = 0","'use strict';\n\nconst Utils = require('../../utils');\nconst SqlString = require('../../sql-string');\nconst Dot = require('dottie');\nconst QueryTypes = require('../../query-types');\n\nclass AbstractQuery {\n\n  /**\n   * rewrite query with parameters\n   *\n   * Examples:\n   *\n   *   query.formatBindParameters('select $1 as foo', ['fooval']);\n   *\n   *   query.formatBindParameters('select $foo as foo', { foo: 'fooval' });\n   *\n   * Options\n   *   skipUnescape: bool, skip unescaping $$\n   *   skipValueReplace: bool, do not replace (but do unescape $$). Check correct syntax and if all values are available\n   * @private\n   */\n  static formatBindParameters(sql, values, dialect, replacementFunc, options) {\n    if (!values) {\n      return [sql, []];\n    }\n\n    options = options || {};\n    if (typeof replacementFunc !== 'function') {\n      options = replacementFunc || {};\n      replacementFunc = undefined;\n    }\n\n    if (!replacementFunc) {\n      if (options.skipValueReplace) {\n        replacementFunc = (match, key, values) => {\n          if (values[key] !== undefined) {\n            return match;\n          }\n          return undefined;\n        };\n      } else {\n        replacementFunc = (match, key, values, timeZone, dialect) => {\n          if (values[key] !== undefined) {\n            return SqlString.escape(values[key], false, timeZone, dialect);\n          }\n          return undefined;\n        };\n      }\n    } else {\n      if (options.skipValueReplace) {\n        const origReplacementFunc = replacementFunc;\n        replacementFunc = (match, key, values, timeZone, dialect, options) => {\n          if (origReplacementFunc(match, key, values, timeZone, dialect, options) !== undefined) {\n            return match;\n          }\n          return undefined;\n        };\n      }\n    }\n\n    const timeZone = null;\n    const list = Array.isArray(values);\n\n    sql = sql.replace(/\\$(\\$|\\w+)/g, (match, key) => {\n      if ('$' === key) {\n        return options.skipUnescape ? match : key;\n      }\n\n      let replVal;\n      if (list) {\n        if (key.match(/^[1-9]\\d*$/)) {\n          key = key - 1;\n          replVal = replacementFunc(match, key, values, timeZone, dialect, options);\n        }\n      } else {\n        if (!key.match(/^\\d*$/)) {\n          replVal = replacementFunc(match, key, values, timeZone, dialect, options);\n        }\n      }\n      if (replVal === undefined) {\n        throw new Error('Named bind parameter \"' + match + '\" has no value in the given object.');\n      }\n      return replVal;\n    });\n    return [sql, []];\n  }\n\n  /**\n   * Execute the passed sql query.\n   *\n   * Examples:\n   *\n   *     query.run('SELECT 1')\n   *\n   * @param {String} sql - The SQL query which should be executed.\n   * @private\n   */\n  run() {\n    throw new Error('The run method wasn\\'t overwritten!');\n  }\n\n  /**\n   * Check the logging option of the instance and print deprecation warnings.\n   *\n   * @return {void}\n   * @private\n   */\n  checkLoggingOption() {\n    if (this.options.logging === true) {\n      Utils.deprecate('The logging-option should be either a function or false. Default: console.log');\n      this.options.logging = console.log;\n    }\n  }\n\n  /**\n   * Get the attributes of an insert query, which contains the just inserted id.\n   *\n   * @return {String} The field name.\n   * @private\n   */\n  getInsertIdField() {\n    return 'insertId';\n  }\n\n  /**\n   * Iterate over all known tables and search their names inside the sql query.\n   * This method will also check association aliases ('as' option).\n   *\n   * @param  {String} attribute An attribute of a SQL query. (?)\n   * @return {String}           The found tableName / alias.\n   * @private\n   */\n  findTableNameInAttribute(attribute) {\n    if (!this.options.include) {\n      return null;\n    }\n    if (!this.options.includeNames) {\n      this.options.includeNames = this.options.include.map(include => include.as);\n    }\n\n    const tableNames = this.options.includeNames.filter(include => attribute.indexOf(include + '.') === 0);\n\n    if (tableNames.length === 1) {\n      return tableNames[0];\n    } else {\n      return null;\n    }\n  }\n\n  getUniqueConstraintErrorMessage(field) {\n    let message = field + ' must be unique';\n\n    if (this.model) {\n      for (const key of Object.keys(this.model.uniqueKeys)) {\n        if (this.model.uniqueKeys[key].fields.indexOf(field.replace(/\"/g, '')) >= 0) {\n          if (this.model.uniqueKeys[key].msg) {\n            message = this.model.uniqueKeys[key].msg;\n          }\n        }\n      }\n    }\n    return message;\n  }\n\n  isRawQuery() {\n    return this.options.type === QueryTypes.RAW;\n  }\n\n  isVersionQuery() {\n    return this.options.type === QueryTypes.VERSION;\n  }\n\n  isUpsertQuery() {\n    return this.options.type === QueryTypes.UPSERT;\n  }\n\n  isInsertQuery(results, metaData) {\n    let result = true;\n\n    if (this.options.type === QueryTypes.INSERT) {\n      return true;\n    }\n\n    // is insert query if sql contains insert into\n    result = result && this.sql.toLowerCase().indexOf('insert into') === 0;\n\n    // is insert query if no results are passed or if the result has the inserted id\n    result = result && (!results || results.hasOwnProperty(this.getInsertIdField()));\n\n    // is insert query if no metadata are passed or if the metadata has the inserted id\n    result = result && (!metaData || metaData.hasOwnProperty(this.getInsertIdField()));\n\n    return result;\n  }\n\n  handleInsertQuery(results, metaData) {\n    if (this.instance) {\n      // add the inserted row id to the instance\n      const autoIncrementAttribute = this.model.autoIncrementAttribute;\n      let id = null;\n\n      id = id || results && results[this.getInsertIdField()];\n      id = id || metaData && metaData[this.getInsertIdField()];\n\n      this.instance[autoIncrementAttribute] = id;\n    }\n  }\n\n  isShowTablesQuery() {\n    return this.options.type === QueryTypes.SHOWTABLES;\n  }\n\n  handleShowTablesQuery(results) {\n    return Utils._.flatten(results.map(resultSet => Utils._.values(resultSet)));\n  }\n\n  isShowIndexesQuery() {\n    return this.options.type === QueryTypes.SHOWINDEXES;\n  }\n\n  isShowConstraintsQuery() {\n    return this.options.type === QueryTypes.SHOWCONSTRAINTS;\n  }\n\n  isDescribeQuery() {\n    return this.options.type === QueryTypes.DESCRIBE;\n  }\n\n  isSelectQuery() {\n    return this.options.type === QueryTypes.SELECT;\n  }\n\n  isBulkUpdateQuery() {\n    return this.options.type === QueryTypes.BULKUPDATE;\n  }\n\n  isBulkDeleteQuery() {\n    return this.options.type === QueryTypes.BULKDELETE;\n  }\n\n  isForeignKeysQuery() {\n    return this.options.type === QueryTypes.FOREIGNKEYS;\n  }\n\n  isUpdateQuery() {\n    return this.options.type === QueryTypes.UPDATE;\n  }\n\n  handleSelectQuery(results) {\n    let result = null;\n    // Map raw fields to names if a mapping is provided\n    if (this.options.fieldMap) {\n      const fieldMap = this.options.fieldMap;\n      results = Utils._.map(results, result => Utils._.reduce(fieldMap, (result, name, field) => {\n        if (result[field] !== undefined) {\n          result[name] = result[field];\n          delete result[field];\n        }\n        return result;\n      }, result));\n    }\n    // Raw queries\n    if (this.options.raw) {\n      result = results.map(result => {\n        let o = {};\n\n        for (const key in result) {\n          if (result.hasOwnProperty(key)) {\n            o[key] = result[key];\n          }\n        }\n\n        if (this.options.nest) {\n          o = Dot.transform(o);\n        }\n\n        return o;\n      });\n    // Queries with include\n    } else if (this.options.hasJoin === true) {\n      results = AbstractQuery._groupJoinData(results, {\n        model: this.model,\n        includeMap: this.options.includeMap,\n        includeNames: this.options.includeNames\n      }, {\n        checkExisting: this.options.hasMultiAssociation\n      });\n\n      result = this.model.bulkBuild(results, {\n        isNewRecord: false,\n        include: this.options.include,\n        includeNames: this.options.includeNames,\n        includeMap: this.options.includeMap,\n        includeValidated: true,\n        attributes: this.options.originalAttributes || this.options.attributes,\n        raw: true\n      });\n    // Regular queries\n    } else {\n      result = this.model.bulkBuild(results, {\n        isNewRecord: false,\n        raw: true,\n        attributes: this.options.attributes\n      });\n    }\n\n    // return the first real model instance if options.plain is set (e.g. Model.find)\n    if (this.options.plain) {\n      result = result.length === 0 ? null : result[0];\n    }\n    return result;\n  }\n\n  isShowOrDescribeQuery() {\n    let result = false;\n\n    result = result || this.sql.toLowerCase().indexOf('show') === 0;\n    result = result || this.sql.toLowerCase().indexOf('describe') === 0;\n\n    return result;\n  }\n\n  isCallQuery() {\n    return this.sql.toLowerCase().indexOf('call') === 0;\n  }\n\n  /**\n   * The function takes the result of the query execution and groups\n   * the associated data by the callee.\n   *\n   * Example:\n   *   groupJoinData([\n   *     {\n   *       some: 'data',\n   *       id: 1,\n   *       association: { foo: 'bar', id: 1 }\n   *     }, {\n   *       some: 'data',\n   *       id: 1,\n   *       association: { foo: 'bar', id: 2 }\n   *     }, {\n   *       some: 'data',\n   *       id: 1,\n   *       association: { foo: 'bar', id: 3 }\n   *     }\n   *   ])\n   *\n   * Result:\n   *   Something like this:\n   *\n   *   [\n   *     {\n   *       some: 'data',\n   *       id: 1,\n   *       association: [\n   *         { foo: 'bar', id: 1 },\n   *         { foo: 'bar', id: 2 },\n   *         { foo: 'bar', id: 3 }\n   *       ]\n   *     }\n   *   ]\n   * @private\n   */\n  static _groupJoinData(rows, includeOptions, options) {\n\n    /*\n     * Assumptions\n     * ID is not necessarily the first field\n     * All fields for a level is grouped in the same set (i.e. Panel.id, Task.id, Panel.title is not possible)\n     * Parent keys will be seen before any include/child keys\n     * Previous set won't necessarily be parent set (one parent could have two children, one child would then be previous set for the other)\n     */\n\n    /*\n     * Author (MH) comment: This code is an unreadable mess, but its performant.\n     * groupJoinData is a performance critical function so we prioritize perf over readability.\n     */\n    if (!rows.length) {\n      return [];\n    }\n\n    // Generic looping\n    let i;\n    let length;\n    let $i;\n    let $length;\n    // Row specific looping\n    let rowsI;\n    let row;\n    const rowsLength = rows.length;\n    // Key specific looping\n    let keys;\n    let key;\n    let keyI;\n    let keyLength;\n    let prevKey;\n    let values;\n    let topValues;\n    let topExists;\n    const checkExisting = options.checkExisting;\n    // If we don't have to deduplicate we can pre-allocate the resulting array\n    let itemHash;\n    let parentHash;\n    let topHash;\n    const results = checkExisting ? [] : new Array(rowsLength);\n    const resultMap = {};\n    const includeMap = {};\n    // Result variables for the respective functions\n    let $keyPrefix;\n    let $keyPrefixString;\n    let $prevKeyPrefixString; // eslint-disable-line\n    let $prevKeyPrefix;\n    let $lastKeyPrefix;\n    let $current;\n    let $parent;\n    // Map each key to an include option\n    let previousPiece;\n    const buildIncludeMap = piece => {\n      if ($current.includeMap[piece]) {\n        includeMap[key] = $current = $current.includeMap[piece];\n        if (previousPiece) {\n          previousPiece = previousPiece+'.'+piece;\n        } else {\n          previousPiece = piece;\n        }\n        includeMap[previousPiece] = $current;\n      }\n    };\n    // Calculate the string prefix of a key ('User.Results' for 'User.Results.id')\n    const keyPrefixStringMemo = {};\n    const keyPrefixString = (key, memo) => {\n      if (!memo[key]) {\n        memo[key] = key.substr(0, key.lastIndexOf('.'));\n      }\n      return memo[key];\n    };\n    // Removes the prefix from a key ('id' for 'User.Results.id')\n    const removeKeyPrefixMemo = {};\n    const removeKeyPrefix = key => {\n      if (!removeKeyPrefixMemo[key]) {\n        const index = key.lastIndexOf('.');\n        removeKeyPrefixMemo[key] = key.substr(index === -1 ? 0 : index + 1);\n      }\n      return removeKeyPrefixMemo[key];\n    };\n    // Calculates the array prefix of a key (['User', 'Results'] for 'User.Results.id')\n    const keyPrefixMemo = {};\n    const keyPrefix = key => {\n      // We use a double memo and keyPrefixString so that different keys with the same prefix will receive the same array instead of differnet arrays with equal values\n      if (!keyPrefixMemo[key]) {\n        const prefixString = keyPrefixString(key, keyPrefixStringMemo);\n        if (!keyPrefixMemo[prefixString]) {\n          keyPrefixMemo[prefixString] = prefixString ? prefixString.split('.') : [];\n        }\n        keyPrefixMemo[key] = keyPrefixMemo[prefixString];\n      }\n      return keyPrefixMemo[key];\n    };\n    // Calcuate the last item in the array prefix ('Results' for 'User.Results.id')\n    const lastKeyPrefixMemo = {};\n    const lastKeyPrefix = key => {\n      if (!lastKeyPrefixMemo[key]) {\n        const prefix = keyPrefix(key);\n        const length = prefix.length;\n\n        lastKeyPrefixMemo[key] = !length ? '' : prefix[length - 1];\n      }\n      return lastKeyPrefixMemo[key];\n    };\n    const getUniqueKeyAttributes = model => {\n      let uniqueKeyAttributes = Utils._.chain(model.uniqueKeys);\n      uniqueKeyAttributes = uniqueKeyAttributes\n        .result(uniqueKeyAttributes.findKey() + '.fields')\n        .map(field => Utils._.findKey(model.attributes, chr => chr.field === field))\n        .value();\n\n      return uniqueKeyAttributes;\n    };\n    let primaryKeyAttributes;\n    let uniqueKeyAttributes;\n    let prefix;\n\n    for (rowsI = 0; rowsI < rowsLength; rowsI++) {\n      row = rows[rowsI];\n\n      // Keys are the same for all rows, so only need to compute them on the first row\n      if (rowsI === 0) {\n        keys = Object.keys(row);\n        keyLength = keys.length;\n      }\n\n      if (checkExisting) {\n        topExists = false;\n\n        // Compute top level hash key (this is usually just the primary key values)\n        $length = includeOptions.model.primaryKeyAttributes.length;\n        topHash = '';\n        if ($length === 1) {\n          topHash = row[includeOptions.model.primaryKeyAttributes[0]];\n        }\n        else if ($length > 1) {\n          for ($i = 0; $i < $length; $i++) {\n            topHash += row[includeOptions.model.primaryKeyAttributes[$i]];\n          }\n        }\n        else if (!Utils._.isEmpty(includeOptions.model.uniqueKeys)) {\n          uniqueKeyAttributes = getUniqueKeyAttributes(includeOptions.model);\n          for ($i = 0; $i < uniqueKeyAttributes.length; $i++) {\n            topHash += row[uniqueKeyAttributes[$i]];\n          }\n        }\n      }\n\n      topValues = values = {};\n      $prevKeyPrefix = undefined;\n      for (keyI = 0; keyI < keyLength; keyI++) {\n        key = keys[keyI];\n\n        // The string prefix isn't actualy needed\n        // We use it so keyPrefix for different keys will resolve to the same array if they have the same prefix\n        // TODO: Find a better way?\n        $keyPrefixString = keyPrefixString(key, keyPrefixStringMemo);\n        $keyPrefix = keyPrefix(key);\n\n        // On the first row we compute the includeMap\n        if (rowsI === 0 && includeMap[key] === undefined) {\n          if (!$keyPrefix.length) {\n            includeMap[key] = includeMap[''] = includeOptions;\n          } else {\n            $current = includeOptions;\n            previousPiece = undefined;\n            $keyPrefix.forEach(buildIncludeMap);\n          }\n        }\n        // End of key set\n        if ($prevKeyPrefix !== undefined && $prevKeyPrefix !== $keyPrefix) {\n          if (checkExisting) {\n            // Compute hash key for this set instance\n            // TODO: Optimize\n            length = $prevKeyPrefix.length;\n            $parent = null;\n            parentHash = null;\n\n            if (length) {\n              for (i = 0; i < length; i++) {\n                prefix = $parent ? $parent+'.'+$prevKeyPrefix[i] : $prevKeyPrefix[i];\n                primaryKeyAttributes = includeMap[prefix].model.primaryKeyAttributes;\n                $length = primaryKeyAttributes.length;\n                itemHash = prefix;\n                if ($length === 1) {\n                  itemHash += row[prefix+'.'+primaryKeyAttributes[0]];\n                }\n                else if ($length > 1) {\n                  for ($i = 0; $i < $length; $i++) {\n                    itemHash += row[prefix+'.'+primaryKeyAttributes[$i]];\n                  }\n                }\n                else if (!Utils._.isEmpty(includeMap[prefix].model.uniqueKeys)) {\n                  uniqueKeyAttributes = getUniqueKeyAttributes(includeMap[prefix].model);\n                  for ($i = 0; $i < uniqueKeyAttributes.length; $i++) {\n                    itemHash += row[prefix+'.'+uniqueKeyAttributes[$i]];\n                  }\n                }\n                if (!parentHash) {\n                  parentHash = topHash;\n                }\n\n                itemHash = parentHash + itemHash;\n                $parent = prefix;\n                if (i < length - 1) {\n                  parentHash = itemHash;\n                }\n              }\n            } else {\n              itemHash = topHash;\n            }\n\n            if (itemHash === topHash) {\n              if (!resultMap[itemHash]) {\n                resultMap[itemHash] = values;\n              } else {\n                topExists = true;\n              }\n            } else {\n              if (!resultMap[itemHash]) {\n                $parent = resultMap[parentHash];\n                $lastKeyPrefix = lastKeyPrefix(prevKey);\n\n                if (includeMap[prevKey].association.isSingleAssociation) {\n                  if ($parent) {\n                    $parent[$lastKeyPrefix] = resultMap[itemHash] = values;\n                  }\n                } else {\n                  if (!$parent[$lastKeyPrefix]) {\n                    $parent[$lastKeyPrefix] = [];\n                  }\n                  $parent[$lastKeyPrefix].push(resultMap[itemHash] = values);\n                }\n              }\n            }\n\n            // Reset values\n            values = {};\n          } else {\n            // If checkExisting is false it's because there's only 1:1 associations in this query\n            // However we still need to map onto the appropriate parent\n            // For 1:1 we map forward, initializing the value object on the parent to be filled in the next iterations of the loop\n            $current = topValues;\n            length = $keyPrefix.length;\n            if (length) {\n              for (i = 0; i < length; i++) {\n                if (i === length -1) {\n                  values = $current[$keyPrefix[i]] = {};\n                }\n                $current = $current[$keyPrefix[i]];\n              }\n            }\n          }\n        }\n\n        // End of iteration, set value and set prev values (for next iteration)\n        values[removeKeyPrefix(key)] = row[key];\n        prevKey = key;\n        $prevKeyPrefix = $keyPrefix;\n        $prevKeyPrefixString = $keyPrefixString;\n      }\n\n      if (checkExisting) {\n        length = $prevKeyPrefix.length;\n        $parent = null;\n        parentHash = null;\n\n        if (length) {\n          for (i = 0; i < length; i++) {\n            prefix = $parent ? $parent+'.'+$prevKeyPrefix[i] : $prevKeyPrefix[i];\n            primaryKeyAttributes = includeMap[prefix].model.primaryKeyAttributes;\n            $length = primaryKeyAttributes.length;\n            itemHash = prefix;\n            if ($length === 1) {\n              itemHash += row[prefix+'.'+primaryKeyAttributes[0]];\n            }\n            else if ($length > 0) {\n              for ($i = 0; $i < $length; $i++) {\n                itemHash += row[prefix+'.'+primaryKeyAttributes[$i]];\n              }\n            }\n            else if (!Utils._.isEmpty(includeMap[prefix].model.uniqueKeys)) {\n              uniqueKeyAttributes = getUniqueKeyAttributes(includeMap[prefix].model);\n              for ($i = 0; $i < uniqueKeyAttributes.length; $i++) {\n                itemHash += row[prefix+'.'+uniqueKeyAttributes[$i]];\n              }\n            }\n            if (!parentHash) {\n              parentHash = topHash;\n            }\n\n            itemHash = parentHash + itemHash;\n            $parent = prefix;\n            if (i < length - 1) {\n              parentHash = itemHash;\n            }\n          }\n        } else {\n          itemHash = topHash;\n        }\n\n        if (itemHash === topHash) {\n          if (!resultMap[itemHash]) {\n            resultMap[itemHash] = values;\n          } else {\n            topExists = true;\n          }\n        } else {\n          if (!resultMap[itemHash]) {\n            $parent = resultMap[parentHash];\n            $lastKeyPrefix = lastKeyPrefix(prevKey);\n\n            if (includeMap[prevKey].association.isSingleAssociation) {\n              if ($parent) {\n                $parent[$lastKeyPrefix] = resultMap[itemHash] = values;\n              }\n            } else {\n              if (!$parent[$lastKeyPrefix]) {\n                $parent[$lastKeyPrefix] = [];\n              }\n              $parent[$lastKeyPrefix].push(resultMap[itemHash] = values);\n            }\n          }\n        }\n        if (!topExists) {\n          results.push(topValues);\n        }\n      } else {\n        results[rowsI] = topValues;\n      }\n    }\n\n    return results;\n  }\n}\n\nmodule.exports = AbstractQuery;\nmodule.exports.AbstractQuery = AbstractQuery;\nmodule.exports.default = AbstractQuery;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/dialects/abstract/query.js\n// module id = 25\n// module chunks = 0","'use strict';\n\nconst Utils = require('../../utils');\nconst SqlString = require('../../sql-string');\nconst Model = require('../../model');\nconst DataTypes = require('../../data-types');\nconst util = require('util');\nconst _ = require('lodash');\nconst Dottie = require('dottie');\nconst Association = require('../../associations/base');\nconst BelongsTo = require('../../associations/belongs-to');\nconst BelongsToMany = require('../../associations/belongs-to-many');\nconst HasMany = require('../../associations/has-many');\nconst uuid = require('uuid');\nconst semver = require('semver');\n\nconst QueryGenerator = {\n  options: {},\n\n  extractTableDetails(tableName, options) {\n    options = options || {};\n    tableName = tableName || {};\n    return {\n      schema: tableName.schema || options.schema || 'public',\n      tableName: _.isPlainObject(tableName) ? tableName.tableName : tableName,\n      delimiter: tableName.delimiter || options.delimiter || '.'\n    };\n  },\n\n  addSchema(param) {\n    const self = this;\n\n    if (!param._schema) return param.tableName || param;\n\n    return {\n      tableName: param.tableName || param,\n      table: param.tableName || param,\n      name: param.name || param,\n      schema: param._schema,\n      delimiter: param._schemaDelimiter || '.',\n      toString() {\n        return self.quoteTable(this);\n      }\n    };\n  },\n\n  dropSchema(tableName, options) {\n    return this.dropTableQuery(tableName, options);\n  },\n\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = this.quoteTable(\n      this.addSchema({\n        tableName,\n        _schema: schema,\n        _schemaDelimiter: schemaDelimiter\n      })\n    );\n\n    return 'DESCRIBE ' + table + ';';\n  },\n\n  dropTableQuery(tableName) {\n    return `DROP TABLE IF EXISTS ${this.quoteTable(tableName)};`;\n  },\n\n  renameTableQuery(before, after) {\n    return `ALTER TABLE ${this.quoteTable(before)} RENAME TO ${this.quoteTable(after)};`;\n  },\n\n  /*\n    Returns an insert into command. Parameters: table name + hash of attribute-value-pairs.\n   @private\n  */\n  insertQuery(table, valueHash, modelAttributes, options) {\n    options = options || {};\n    _.defaults(options, this.options);\n\n    const modelAttributeMap = {};\n    const fields = [];\n    const values = [];\n    let query;\n    let valueQuery = '<%= tmpTable %>INSERT<%= ignoreDuplicates %> INTO <%= table %> (<%= attributes %>)<%= output %> VALUES (<%= values %>)';\n    let emptyQuery = '<%= tmpTable %>INSERT<%= ignoreDuplicates %> INTO <%= table %><%= output %>';\n    let outputFragment;\n    let identityWrapperRequired = false;\n    let tmpTable = '';         //tmpTable declaration for trigger\n\n    if (modelAttributes) {\n      _.each(modelAttributes, (attribute, key) => {\n        modelAttributeMap[key] = attribute;\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n\n    if (this._dialect.supports['DEFAULT VALUES']) {\n      emptyQuery += ' DEFAULT VALUES';\n    } else if (this._dialect.supports['VALUES ()']) {\n      emptyQuery += ' VALUES ()';\n    }\n\n    if (this._dialect.supports.returnValues && options.returning) {\n      if (this._dialect.supports.returnValues.returning) {\n        valueQuery += ' RETURNING *';\n        emptyQuery += ' RETURNING *';\n      } else if (this._dialect.supports.returnValues.output) {\n        outputFragment = ' OUTPUT INSERTED.*';\n\n        //To capture output rows when there is a trigger on MSSQL DB\n        if (modelAttributes && options.hasTrigger && this._dialect.supports.tmpTableTrigger) {\n\n          let tmpColumns = '';\n          let outputColumns = '';\n          tmpTable = 'declare @tmp table (<%= columns %>); ';\n\n          for (const modelKey in modelAttributes) {\n            const attribute = modelAttributes[modelKey];\n            if (!(attribute.type instanceof DataTypes.VIRTUAL)) {\n              if (tmpColumns.length > 0) {\n                tmpColumns += ',';\n                outputColumns += ',';\n              }\n\n              tmpColumns += this.quoteIdentifier(attribute.field) + ' ' + attribute.type.toSql();\n              outputColumns += 'INSERTED.' + this.quoteIdentifier(attribute.field);\n            }\n          }\n\n          const replacement = {\n            columns: tmpColumns\n          };\n\n          tmpTable = _.template(tmpTable)(replacement).trim();\n          outputFragment = ' OUTPUT ' + outputColumns + ' into @tmp';\n          const selectFromTmp = ';select * from @tmp';\n\n          valueQuery += selectFromTmp;\n          emptyQuery += selectFromTmp;\n        }\n      }\n    }\n\n    if (this._dialect.supports.EXCEPTION && options.exception) {\n      // Mostly for internal use, so we expect the user to know what he's doing!\n      // pg_temp functions are private per connection, so we never risk this function interfering with another one.\n      if (semver.gte(this.sequelize.options.databaseVersion, '9.2.0')) {\n        // >= 9.2 - Use a UUID but prefix with 'func_' (numbers first not allowed)\n        const delimiter = '$func_' + uuid.v4().replace(/-/g, '') + '$';\n\n        options.exception = 'WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL;';\n        valueQuery = 'CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response <%= table %>, OUT sequelize_caught_exception text) RETURNS RECORD AS ' + delimiter +\n          ' BEGIN ' + valueQuery + ' INTO response; EXCEPTION ' + options.exception + ' END ' + delimiter +\n          ' LANGUAGE plpgsql; SELECT (testfunc.response).*, testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc()';\n      } else {\n        options.exception = 'WHEN unique_violation THEN NULL;';\n        valueQuery = 'CREATE OR REPLACE FUNCTION pg_temp.testfunc() RETURNS SETOF <%= table %> AS $body$ BEGIN RETURN QUERY ' + valueQuery + '; EXCEPTION ' + options.exception + ' END; $body$ LANGUAGE plpgsql; SELECT * FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc();';\n      }\n    }\n\n    if (this._dialect.supports['ON DUPLICATE KEY'] && options.onDuplicate) {\n      valueQuery += ' ON DUPLICATE KEY ' + options.onDuplicate;\n      emptyQuery += ' ON DUPLICATE KEY ' + options.onDuplicate;\n    }\n\n    valueHash = Utils.removeNullValuesFromHash(valueHash, this.options.omitNull);\n    for (const key in valueHash) {\n      if (valueHash.hasOwnProperty(key)) {\n        const value = valueHash[key];\n        fields.push(this.quoteIdentifier(key));\n\n        // SERIALS' can't be NULL in postgresql, use DEFAULT where supported\n        if (modelAttributeMap && modelAttributeMap[key] && modelAttributeMap[key].autoIncrement === true && !value) {\n          if (!this._dialect.supports.autoIncrement.defaultValue) {\n            fields.splice(-1, 1);\n          } else if (this._dialect.supports.DEFAULT) {\n            values.push('DEFAULT');\n          } else {\n            values.push(this.escape(null));\n          }\n        } else {\n          if (modelAttributeMap && modelAttributeMap[key] && modelAttributeMap[key].autoIncrement === true) {\n            identityWrapperRequired = true;\n          }\n\n          values.push(this.escape(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'INSERT' }));\n        }\n      }\n    }\n\n    const replacements = {\n      ignoreDuplicates: options.ignoreDuplicates ? this._dialect.supports.IGNORE : '',\n      table: this.quoteTable(table),\n      attributes: fields.join(','),\n      output: outputFragment,\n      values: values.join(','),\n      tmpTable\n    };\n\n    query = (replacements.attributes.length ? valueQuery : emptyQuery) + ';';\n    if (identityWrapperRequired && this._dialect.supports.autoIncrement.identityInsert) {\n      query = [\n        'SET IDENTITY_INSERT', this.quoteTable(table), 'ON;',\n        query,\n        'SET IDENTITY_INSERT', this.quoteTable(table), 'OFF;'\n      ].join(' ');\n    }\n\n    return _.template(query)(replacements);\n  },\n\n  /*\n    Returns an insert into command for multiple values.\n    Parameters: table name + list of hashes of attribute-value-pairs.\n   @private\n  */\n  bulkInsertQuery(tableName, attrValueHashes, options, rawAttributes) {\n    options = options || {};\n    rawAttributes = rawAttributes || {};\n\n    const query = 'INSERT<%= ignoreDuplicates %> INTO <%= table %> (<%= attributes %>) VALUES <%= tuples %><%= onDuplicateKeyUpdate %><%= returning %>;';\n    const tuples = [];\n    const serials = {};\n    const allAttributes = [];\n    let onDuplicateKeyUpdate = '';\n\n    for (const attrValueHash of attrValueHashes) {\n      _.forOwn(attrValueHash, (value, key) => {\n        if (allAttributes.indexOf(key) === -1) {\n          allAttributes.push(key);\n        }\n\n        if (rawAttributes[key] && rawAttributes[key].autoIncrement === true) {\n          serials[key] = true;\n        }\n      });\n    }\n\n    for (const attrValueHash of attrValueHashes) {\n      tuples.push('(' + allAttributes.map(key => {\n        if (this._dialect.supports.bulkDefault && serials[key] === true) {\n          return attrValueHash[key] || 'DEFAULT';\n        }\n        return this.escape(attrValueHash[key], rawAttributes[key], { context: 'INSERT' });\n      }).join(',') + ')');\n    }\n\n    if (this._dialect.supports.updateOnDuplicate && options.updateOnDuplicate) {\n      onDuplicateKeyUpdate += ' ON DUPLICATE KEY UPDATE ' + options.updateOnDuplicate.map(attr => {\n        const field = rawAttributes && rawAttributes[attr] && rawAttributes[attr].field || attr;\n        const key = this.quoteIdentifier(field);\n        return key + '=VALUES(' + key + ')';\n      }).join(',');\n    }\n\n    const replacements = {\n      ignoreDuplicates: options.ignoreDuplicates ? this._dialect.supports.ignoreDuplicates : '',\n      table: this.quoteTable(tableName),\n      attributes: allAttributes.map(attr => this.quoteIdentifier(attr)).join(','),\n      tuples: tuples.join(','),\n      onDuplicateKeyUpdate,\n      returning: this._dialect.supports.returnValues && options.returning ? ' RETURNING *' : ''\n    };\n\n    return _.template(query)(replacements);\n  },\n\n  /*\n    Returns an update query.\n    Parameters:\n      - tableName -> Name of the table\n      - values -> A hash with attribute-value-pairs\n      - where -> A hash with conditions (e.g. {name: 'foo'})\n                 OR an ID as integer\n                 OR a string with conditions (e.g. 'name=\"foo\"').\n                 If you use a string, you have to escape it on your own.\n   @private\n  */\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    options = options || {};\n    _.defaults(options, this.options);\n\n    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);\n\n    const values = [];\n    const modelAttributeMap = {};\n    let query = '<%= tmpTable %>UPDATE <%= table %> SET <%= values %><%= output %> <%= where %>';\n    let outputFragment;\n    let tmpTable = '';        // tmpTable declaration for trigger\n    let selectFromTmp = '';   // Select statement for trigger\n\n    if (this._dialect.supports['LIMIT ON UPDATE'] && options.limit) {\n      if (this.dialect !== 'mssql') {\n        query += ' LIMIT ' + this.escape(options.limit) + ' ';\n      }\n    }\n\n    if (this._dialect.supports.returnValues) {\n      if (this._dialect.supports.returnValues.output) {\n        // we always need this for mssql\n        outputFragment = ' OUTPUT INSERTED.*';\n\n        //To capture output rows when there is a trigger on MSSQL DB\n        if (attributes && options.hasTrigger && this._dialect.supports.tmpTableTrigger) {\n          tmpTable = 'declare @tmp table (<%= columns %>); ';\n          let tmpColumns = '';\n          let outputColumns = '';\n\n          for (const modelKey in attributes) {\n            const attribute = attributes[modelKey];\n            if (!(attribute.type instanceof DataTypes.VIRTUAL)) {\n              if (tmpColumns.length > 0) {\n                tmpColumns += ',';\n                outputColumns += ',';\n              }\n\n              tmpColumns += this.quoteIdentifier(attribute.field) + ' ' + attribute.type.toSql();\n              outputColumns += 'INSERTED.' + this.quoteIdentifier(attribute.field);\n            }\n          }\n\n          const replacement ={\n            columns : tmpColumns\n          };\n\n          tmpTable = _.template(tmpTable)(replacement).trim();\n          outputFragment = ' OUTPUT ' + outputColumns + ' into @tmp';\n          selectFromTmp = ';select * from @tmp';\n\n          query += selectFromTmp;\n        }\n      } else if (this._dialect.supports.returnValues && options.returning) {\n        // ensure that the return output is properly mapped to model fields.\n        options.mapToModel = true;\n        query += ' RETURNING *';\n      }\n    }\n\n    if (attributes) {\n      _.each(attributes, (attribute, key) => {\n        modelAttributeMap[key] = attribute;\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n\n    for (const key in attrValueHash) {\n      if (modelAttributeMap && modelAttributeMap[key] &&\n          modelAttributeMap[key].autoIncrement === true &&\n          !this._dialect.supports.autoIncrement.update) {\n        // not allowed to update identity column\n        continue;\n      }\n\n      const value = attrValueHash[key];\n      values.push(this.quoteIdentifier(key) + '=' + this.escape(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'UPDATE' }));\n    }\n\n    const replacements = {\n      table: this.quoteTable(tableName),\n      values: values.join(','),\n      output: outputFragment,\n      where: this.whereQuery(where, options),\n      tmpTable\n    };\n\n    if (values.length === 0) {\n      return '';\n    }\n\n    return _.template(query)(replacements).trim();\n  },\n\n  /*\n    Returns an update query.\n    Parameters:\n      - operator -> String with the arithmetic operator (e.g. '+' or '-')\n      - tableName -> Name of the table\n      - values -> A hash with attribute-value-pairs\n      - where -> A hash with conditions (e.g. {name: 'foo'})\n                 OR an ID as integer\n                 OR a string with conditions (e.g. 'name=\"foo\"').\n                 If you use a string, you have to escape it on your own.\n   @private\n  */\n  arithmeticQuery(operator, tableName, attrValueHash, where, options, attributes) {\n    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, this.options.omitNull);\n\n    const values = [];\n    let query = 'UPDATE <%= table %> SET <%= values %><%= output %> <%= where %>';\n    let outputFragment;\n\n    if (this._dialect.supports.returnValues) {\n      if (this._dialect.supports.returnValues.returning) {\n        options.mapToModel = true;\n        query += ' RETURNING *';\n      } else if (this._dialect.supports.returnValues.output) {\n        outputFragment = ' OUTPUT INSERTED.*';\n      }\n    }\n\n    for (const key in attrValueHash) {\n      const value = attrValueHash[key];\n      values.push(this.quoteIdentifier(key) + '=' + this.quoteIdentifier(key) + operator + this.escape(value));\n    }\n\n    attributes = attributes || {};\n    for (const key in attributes) {\n      const value = attributes[key];\n      values.push(this.quoteIdentifier(key) + '=' + this.escape(value));\n    }\n\n    const replacements = {\n      table: this.quoteTable(tableName),\n      values: values.join(','),\n      output: outputFragment,\n      where: this.whereQuery(where)\n    };\n\n    return _.template(query)(replacements);\n  },\n\n  nameIndexes(indexes, rawTablename) {\n    return _.map(indexes, index => {\n      if (!index.hasOwnProperty('name')) {\n        const onlyAttributeNames = index.fields.map(field => typeof field === 'string' ? field : field.name || field.attribute);\n        index.name = Utils.underscore(rawTablename + '_' + onlyAttributeNames.join('_'));\n      }\n\n      return index;\n    });\n  },\n\n  /*\n    Returns an add index query.\n    Parameters:\n      - tableName -> Name of an existing table, possibly with schema.\n      - options:\n        - type: UNIQUE|FULLTEXT|SPATIAL\n        - name: The name of the index. Default is <table>_<attr1>_<attr2>\n        - fields: An array of attributes as string or as hash.\n                  If the attribute is a hash, it must have the following content:\n                  - name: The name of the attribute/column\n                  - length: An integer. Optional\n                  - order: 'ASC' or 'DESC'. Optional\n        - parser\n      - rawTablename, the name of the table, without schema. Used to create the name of the index\n   @private\n  */\n  addIndexQuery(tableName, attributes, options, rawTablename) {\n    options = options || {};\n\n    if (!Array.isArray(attributes)) {\n      options = attributes;\n      attributes = undefined;\n    } else {\n      options.fields = attributes;\n    }\n\n    // Backwards compatability\n    if (options.indexName) {\n      options.name = options.indexName;\n    }\n    if (options.indicesType) {\n      options.type = options.indicesType;\n    }\n    if (options.indexType || options.method) {\n      options.using = options.indexType || options.method;\n    }\n\n    options.prefix = options.prefix || rawTablename || tableName;\n    if (options.prefix && _.isString(options.prefix)) {\n      options.prefix = options.prefix.replace(/\\./g, '_');\n      options.prefix = options.prefix.replace(/(\\\"|\\')/g, '');\n    }\n\n    const fieldsSql = options.fields.map(field => {\n      if (typeof field === 'string') {\n        return this.quoteIdentifier(field);\n      } else if (field instanceof Utils.SequelizeMethod) {\n        return this.handleSequelizeMethod(field);\n      } else {\n        let result = '';\n\n        if (field.attribute) {\n          field.name = field.attribute;\n        }\n\n        if (!field.name) {\n          throw new Error('The following index field has no name: ' + util.inspect(field));\n        }\n\n        result += this.quoteIdentifier(field.name);\n\n        if (this._dialect.supports.index.collate && field.collate) {\n          result += ' COLLATE ' + this.quoteIdentifier(field.collate);\n        }\n\n        if (this._dialect.supports.index.length && field.length) {\n          result += '(' + field.length + ')';\n        }\n\n        if (field.order) {\n          result += ' ' + field.order;\n        }\n\n        return result;\n      }\n    });\n\n    if (!options.name) {\n      // Mostly for cases where addIndex is called directly by the user without an options object (for example in migrations)\n      // All calls that go through sequelize should already have a name\n      options = this.nameIndexes([options], options.prefix)[0];\n    }\n\n    options = Model._conformIndex(options);\n\n    if (!this._dialect.supports.index.type) {\n      delete options.type;\n    }\n\n    if (options.where) {\n      options.where = this.whereQuery(options.where);\n    }\n\n    if (_.isString(tableName)) {\n      tableName = this.quoteIdentifiers(tableName);\n    } else {\n      tableName = this.quoteTable(tableName);\n    }\n\n    const concurrently = this._dialect.supports.index.concurrently && options.concurrently ? 'CONCURRENTLY' : undefined;\n    let ind;\n    if (this._dialect.supports.indexViaAlter) {\n      ind = [\n        'ALTER TABLE',\n        tableName,\n        concurrently,\n        'ADD'\n      ];\n    } else {\n      ind = ['CREATE'];\n    }\n\n    ind = ind.concat(\n      options.unique ? 'UNIQUE' : '',\n      options.type, 'INDEX',\n      !this._dialect.supports.indexViaAlter ? concurrently : undefined,\n      this.quoteIdentifiers(options.name),\n      this._dialect.supports.index.using === 1 && options.using ? 'USING ' + options.using : '',\n      !this._dialect.supports.indexViaAlter ? 'ON ' + tableName : undefined,\n      this._dialect.supports.index.using === 2 && options.using ? 'USING ' + options.using : '',\n      '(' + fieldsSql.join(', ') + (options.operator ? ' '+options.operator : '') + ')',\n      this._dialect.supports.index.parser && options.parser ? 'WITH PARSER ' + options.parser : undefined,\n      this._dialect.supports.index.where && options.where ? options.where : undefined\n    );\n\n    return _.compact(ind).join(' ');\n  },\n\n  addConstraintQuery(tableName, options) {\n    options = options || {};\n    const constraintSnippet = this.getConstraintSnippet(tableName, options);\n\n    if (typeof tableName === 'string') {\n      tableName = this.quoteIdentifiers(tableName);\n    } else {\n      tableName = this.quoteTable(tableName);\n    }\n\n    return `ALTER TABLE ${tableName} ADD ${constraintSnippet};`;\n  },\n\n  getConstraintSnippet(tableName, options) {\n    let constraintSnippet, constraintName;\n\n    const fieldsSql = options.fields.map(field => {\n      if (typeof field === 'string') {\n        return this.quoteIdentifier(field);\n      } else if (field._isSequelizeMethod) {\n        return this.handleSequelizeMethod(field);\n      } else {\n        let result = '';\n\n        if (field.attribute) {\n          field.name = field.attribute;\n        }\n\n        if (!field.name) {\n          throw new Error('The following index field has no name: ' + field);\n        }\n\n        result += this.quoteIdentifier(field.name);\n        return result;\n      }\n    });\n\n    const fieldsSqlQuotedString = fieldsSql.join(', ');\n    const fieldsSqlString = fieldsSql.join('_');\n\n    switch (options.type.toUpperCase()) {\n      case 'UNIQUE':\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_uk`);\n        constraintSnippet = `CONSTRAINT ${constraintName} UNIQUE (${fieldsSqlQuotedString})`;\n        break;\n      case 'CHECK':\n        options.where = this.whereItemsQuery(options.where);\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_ck`);\n        constraintSnippet = `CONSTRAINT ${constraintName} CHECK (${options.where})`;\n        break;\n      case 'DEFAULT':\n        if (options.defaultValue === undefined) {\n          throw new Error('Default value must be specifed for DEFAULT CONSTRAINT');\n        }\n\n        if (this._dialect.name !== 'mssql') {\n          throw new Error('Default constraints are supported only for MSSQL dialect.');\n        }\n\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_df`);\n        constraintSnippet = `CONSTRAINT ${constraintName} DEFAULT (${this.escape(options.defaultValue)}) FOR ${fieldsSql[0]}`;\n        break;\n      case 'PRIMARY KEY':\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_pk`);\n        constraintSnippet = `CONSTRAINT ${constraintName} PRIMARY KEY (${fieldsSqlQuotedString})`;\n        break;\n      case 'FOREIGN KEY':\n        const references = options.references;\n        if (!references || !references.table || !references.field) {\n          throw new Error('references object with table and field must be specified');\n        }\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_${references.table}_fk`);\n        const referencesSnippet = `${this.quoteTable(references.table)} (${this.quoteIdentifier(references.field)})`;\n        constraintSnippet = `CONSTRAINT ${constraintName} `;\n        constraintSnippet += `FOREIGN KEY (${fieldsSqlQuotedString}) REFERENCES ${referencesSnippet}`;\n        if (options.onUpdate) {\n          constraintSnippet += ` ON UPDATE ${options.onUpdate.toUpperCase()}`;\n        }\n        if (options.onDelete) {\n          constraintSnippet += ` ON DELETE ${options.onDelete.toUpperCase()}`;\n        }\n        break;\n      default: throw new Error(`${options.type} is invalid.`);\n    }\n    return constraintSnippet;\n  },\n\n  removeConstraintQuery(tableName, constraintName) {\n    return `ALTER TABLE ${this.quoteIdentifiers(tableName)} DROP CONSTRAINT ${this.quoteIdentifiers(constraintName)}`;\n  },\n\n  quoteTable(param, as) {\n    let table = '';\n\n    if (as === true) {\n      as = param.as || param.name || param;\n    }\n\n    if (_.isObject(param)) {\n      if (this._dialect.supports.schemas) {\n        if (param.schema) {\n          table += this.quoteIdentifier(param.schema) + '.';\n        }\n\n        table += this.quoteIdentifier(param.tableName);\n      } else {\n        if (param.schema) {\n          table += param.schema + (param.delimiter || '.');\n        }\n\n        table += param.tableName;\n        table = this.quoteIdentifier(table);\n      }\n\n\n    } else {\n      table = this.quoteIdentifier(param);\n    }\n\n    if (as) {\n      table += ' AS ' + this.quoteIdentifier(as);\n    }\n    return table;\n  },\n\n  /*\n    Quote an object based on its type. This is a more general version of quoteIdentifiers\n    Strings: should proxy to quoteIdentifiers\n    Arrays:\n      * Expects array in the form: [<model> (optional), <model> (optional),... String, String (optional)]\n        Each <model> can be a model, or an object {model: Model, as: String}, matching include, or an\n        association object, or the name of an association.\n      * Zero or more models can be included in the array and are used to trace a path through the tree of\n        included nested associations. This produces the correct table name for the ORDER BY/GROUP BY SQL\n        and quotes it.\n      * If a single string is appended to end of array, it is quoted.\n        If two strings appended, the 1st string is quoted, the 2nd string unquoted.\n    Objects:\n      * If raw is set, that value should be returned verbatim, without quoting\n      * If fn is set, the string should start with the value of fn, starting paren, followed by\n        the values of cols (which is assumed to be an array), quoted and joined with ', ',\n        unless they are themselves objects\n      * If direction is set, should be prepended\n\n    Currently this function is only used for ordering / grouping columns and Sequelize.col(), but it could\n    potentially also be used for other places where we want to be able to call SQL functions (e.g. as default values)\n   @private\n  */\n  quote(collection, parent, connector) {\n    // init\n    const validOrderOptions = [\n      'ASC',\n      'DESC',\n      'ASC NULLS LAST',\n      'DESC NULLS LAST',\n      'ASC NULLS FIRST',\n      'DESC NULLS FIRST',\n      'NULLS FIRST',\n      'NULLS LAST'\n    ];\n\n    // default\n    connector = connector || '.';\n\n    // just quote as identifiers if string\n    if (typeof collection === 'string') {\n      return this.quoteIdentifiers(collection);\n    } else if (Array.isArray(collection)) {\n      // iterate through the collection and mutate objects into associations\n      collection.forEach((item, index) => {\n        const previous = collection[index - 1];\n        let previousAssociation;\n        let previousModel;\n\n        // set the previous as the parent when previous is undefined or the target of the association\n        if (!previous && parent !== undefined) {\n          previousModel = parent;\n        } else if (previous && previous instanceof Association) {\n          previousAssociation = previous;\n          previousModel = previous.target;\n        }\n\n        // if the previous item is a model, then attempt getting an association\n        if (previousModel && previousModel.prototype instanceof Model) {\n          let model;\n          let as;\n\n          if (typeof item === 'function' && item.prototype instanceof Model) {\n            // set\n            model = item;\n          } else if (_.isPlainObject(item) && item.model && item.model.prototype instanceof Model) {\n            // set\n            model = item.model;\n            as = item.as;\n          }\n\n          if (model) {\n            // set the as to either the through name or the model name\n            if (!as && previousAssociation && previousAssociation instanceof Association && previousAssociation.through && previousAssociation.through.model === model) {\n              // get from previous association\n              item = new Association(previousModel, model, {\n                as: model.name\n              });\n            } else {\n              // get association from previous model\n              item = previousModel.getAssociationForAlias(model, as);\n\n              // attempt to use the model name if the item is still null\n              if (!item) {\n                item = previousModel.getAssociationForAlias(model, model.name);\n              }\n            }\n\n            // make sure we have an association\n            if (!(item instanceof Association)) {\n              throw new Error(util.format('Unable to find a valid association for model, \\'%s\\'', model.name));\n            }\n          }\n        }\n\n        if (typeof item === 'string') {\n          // get order index\n          const orderIndex = validOrderOptions.indexOf(item.toUpperCase());\n\n          // see if this is an order\n          if (index > 0 && orderIndex !== -1) {\n            item = this.sequelize.literal(' ' + validOrderOptions[orderIndex]);\n          } else if (previousModel && previousModel.prototype instanceof Model) {\n            // only go down this path if we have preivous model and check only once\n            if (previousModel.associations !== undefined && previousModel.associations[item]) {\n              // convert the item to an association\n              item = previousModel.associations[item];\n            } else if (previousModel.rawAttributes !== undefined && previousModel.rawAttributes[item] && item !== previousModel.rawAttributes[item].field) {\n              // convert the item attribute from it's alias\n              item = previousModel.rawAttributes[item].field;\n            } else if (\n              item.indexOf('.') !== -1\n              && previousModel.rawAttributes !== undefined\n            ) {\n              const itemSplit = item.split('.');\n\n              if (previousModel.rawAttributes[itemSplit[0]].type instanceof DataTypes.JSON) {\n                // just quote identifiers for now\n                const identifier = this.quoteIdentifiers(previousModel.name  + '.' + previousModel.rawAttributes[itemSplit[0]].field);\n\n                // get path\n                const path = itemSplit.slice(1);\n\n                // extract path\n                item = this.jsonPathExtractionQuery(identifier, path);\n\n                // literal because we don't want to append the model name when string\n                item = this.sequelize.literal(item);\n              }\n            }\n          }\n        }\n\n        collection[index] = item;\n      }, this);\n\n      // loop through array, adding table names of models to quoted\n      const collectionLength = collection.length;\n      const tableNames = [];\n      let item;\n      let i = 0;\n\n      for (i = 0; i < collectionLength - 1; i++) {\n        item = collection[i];\n        if (typeof item === 'string' || item._modelAttribute || item instanceof Utils.SequelizeMethod) {\n          break;\n        } else if (item instanceof Association) {\n          tableNames[i] = item.as;\n        }\n      }\n\n      // start building sql\n      let sql = '';\n\n      if (i > 0) {\n        sql += this.quoteIdentifier(tableNames.join(connector)) + '.';\n      } else if (typeof collection[0] === 'string' && parent) {\n        sql += this.quoteIdentifier(parent.name) + '.';\n      }\n\n      // loop through everything past i and append to the sql\n      collection.slice(i).forEach(collectionItem => {\n        sql += this.quote(collectionItem, parent, connector);\n      }, this);\n\n      return sql;\n    } else if (collection._modelAttribute) {\n      return this.quoteTable(collection.Model.name) + '.' + this.quoteIdentifier(collection.fieldName);\n    } else if (collection instanceof Utils.SequelizeMethod) {\n      return this.handleSequelizeMethod(collection);\n    } else if (_.isPlainObject(collection) && collection.raw) {\n      // simple objects with raw is no longer supported\n      throw new Error('The `{raw: \"...\"}` syntax is no longer supported.  Use `sequelize.literal` instead.');\n    } else {\n      throw new Error('Unknown structure passed to order / group: ' + util.inspect(collection));\n    }\n  },\n\n  /*\n    Split an identifier into .-separated tokens and quote each part\n   @private\n  */\n  quoteIdentifiers(identifiers) {\n    if (identifiers.indexOf('.') !== -1) {\n      identifiers = identifiers.split('.');\n      return this.quoteIdentifier(identifiers.slice(0, identifiers.length - 1).join('.')) + '.' + this.quoteIdentifier(identifiers[identifiers.length - 1]);\n    } else {\n      return this.quoteIdentifier(identifiers);\n    }\n  },\n\n  /*\n    Escape a value (e.g. a string, number or date)\n   @private\n  */\n  escape(value, field, options) {\n    options = options || {};\n\n    if (value !== null && value !== undefined) {\n      if (value instanceof Utils.SequelizeMethod) {\n        return this.handleSequelizeMethod(value);\n      } else {\n        if (field && field.type) {\n          if (this.typeValidation && field.type.validate && value) {\n            if (options.isList && Array.isArray(value)) {\n              for (const item of value) {\n                field.type.validate(item, options);\n              }\n            } else {\n              field.type.validate(value, options);\n            }\n          }\n\n          if (field.type.stringify) {\n            // Users shouldn't have to worry about these args - just give them a function that takes a single arg\n            const simpleEscape = _.partialRight(SqlString.escape, this.options.timezone, this.dialect);\n\n            value = field.type.stringify(value, { escape: simpleEscape, field, timezone: this.options.timezone });\n\n            if (field.type.escape === false) {\n              // The data-type already did the required escaping\n              return value;\n            }\n          }\n        }\n      }\n    }\n\n    return SqlString.escape(value, this.options.timezone, this.dialect);\n  },\n\n  /*\n    Returns a query for selecting elements in the table <tableName>.\n    Options:\n      - attributes -> An array of attributes (e.g. ['name', 'birthday']). Default: *\n      - where -> A hash with conditions (e.g. {name: 'foo'})\n                 OR an ID as integer\n                 OR a string with conditions (e.g. 'name=\"foo\"').\n                 If you use a string, you have to escape it on your own.\n      - order -> e.g. 'id DESC'\n      - group\n      - limit -> The maximum count you want to get.\n      - offset -> An offset value to start from. Only useable with limit!\n   @private\n  */\n  selectQuery(tableName, options, model) {\n    options = options || {};\n    const limit = options.limit;\n    const mainQueryItems = [];\n    const subQueryItems = [];\n    const subQuery = options.subQuery === undefined ? limit && options.hasMultiAssociation : options.subQuery;\n    const attributes = {\n      main: options.attributes && options.attributes.slice(),\n      subQuery: null\n    };\n    const mainTable = {\n      name: tableName,\n      quotedName: null,\n      as: null,\n      model\n    };\n    const topLevelInfo = {\n      names: mainTable,\n      options,\n      subQuery\n    };\n    let mainJoinQueries = [];\n    let subJoinQueries = [];\n    let query;\n\n    // resolve table name options\n    if (options.tableAs) {\n      mainTable.as = this.quoteIdentifier(options.tableAs);\n    } else if (!Array.isArray(mainTable.name) && mainTable.model) {\n      mainTable.as = this.quoteIdentifier(mainTable.model.name);\n    }\n\n    mainTable.quotedName = !Array.isArray(mainTable.name) ? this.quoteTable(mainTable.name) : tableName.map(t => {\n      return Array.isArray(t) ? this.quoteTable(t[0], t[1]) : this.quoteTable(t, true);\n    }).join(', ');\n\n    if (subQuery && attributes.main) {\n      for (const keyAtt of mainTable.model.primaryKeyAttributes) {\n        // Check if mainAttributes contain the primary key of the model either as a field or an aliased field\n        if (!_.find(attributes.main, attr => keyAtt === attr || keyAtt === attr[0] || keyAtt === attr[1])) {\n          attributes.main.push(mainTable.model.rawAttributes[keyAtt].field ? [keyAtt, mainTable.model.rawAttributes[keyAtt].field] : keyAtt);\n        }\n      }\n    }\n\n    attributes.main = this.escapeAttributes(attributes.main, options, mainTable.as);\n    attributes.main = attributes.main || (options.include ? [`${mainTable.as}.*`] : ['*']);\n\n    // If subquery, we ad the mainAttributes to the subQuery and set the mainAttributes to select * from subquery\n    if (subQuery || options.groupedLimit) {\n      // We need primary keys\n      attributes.subQuery = attributes.main;\n      attributes.main = [(mainTable.as || mainTable.quotedName) + '.*'];\n    }\n\n    if (options.include) {\n      for (const include of options.include) {\n        if (include.separate) {\n          continue;\n        }\n        const joinQueries = this.generateInclude(include, { externalAs: mainTable.as, internalAs: mainTable.as }, topLevelInfo);\n\n        subJoinQueries = subJoinQueries.concat(joinQueries.subQuery);\n        mainJoinQueries = mainJoinQueries.concat(joinQueries.mainQuery);\n\n        if (joinQueries.attributes.main.length > 0) {\n          attributes.main = attributes.main.concat(joinQueries.attributes.main);\n        }\n        if (joinQueries.attributes.subQuery.length > 0) {\n          attributes.subQuery = attributes.subQuery.concat(joinQueries.attributes.subQuery);\n        }\n      }\n    }\n\n    if (subQuery) {\n      subQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.subQuery, mainTable.quotedName, mainTable.as));\n      subQueryItems.push(subJoinQueries.join(''));\n    } else {\n      if (options.groupedLimit) {\n        if (!mainTable.as) {\n          mainTable.as = mainTable.quotedName;\n        }\n        const where = Object.assign({}, options.where);\n        let groupedLimitOrder,\n          whereKey,\n          include,\n          groupedTableName = mainTable.as;\n\n        if (typeof options.groupedLimit.on === 'string') {\n          whereKey = options.groupedLimit.on;\n        } else if (options.groupedLimit.on instanceof HasMany) {\n          whereKey = options.groupedLimit.on.foreignKeyField;\n        }\n\n        if (options.groupedLimit.on instanceof BelongsToMany) {\n          // BTM includes needs to join the through table on to check ID\n          groupedTableName = options.groupedLimit.on.manyFromSource.as;\n          const groupedLimitOptions = Model._validateIncludedElements({\n            include: [{\n              association: options.groupedLimit.on.manyFromSource,\n              duplicating: false, // The UNION'ed query may contain duplicates, but each sub-query cannot\n              required: true,\n              where: Object.assign({\n                '$$PLACEHOLDER$$': true\n              }, options.groupedLimit.through && options.groupedLimit.through.where)\n            }],\n            model\n          });\n\n          // Make sure attributes from the join table are mapped back to models\n          options.hasJoin = true;\n          options.hasMultiAssociation = true;\n          options.includeMap = Object.assign(groupedLimitOptions.includeMap, options.includeMap);\n          options.includeNames = groupedLimitOptions.includeNames.concat(options.includeNames || []);\n          include = groupedLimitOptions.include;\n\n          if (Array.isArray(options.order)) {\n            // We need to make sure the order by attributes are available to the parent query\n            options.order.forEach((order, i) => {\n              if (Array.isArray(order)) {\n                order = order[0];\n              }\n\n              let alias = `subquery_order_${i}`;\n              options.attributes.push([order, alias]);\n\n              // We don't want to prepend model name when we alias the attributes, so quote them here\n              alias = this.sequelize.literal(this.quote(alias));\n\n              if (Array.isArray(options.order[i])) {\n                options.order[i][0] = alias;\n              } else {\n                options.order[i] = alias;\n              }\n            });\n            groupedLimitOrder = options.order;\n          }\n        } else {\n          // Ordering is handled by the subqueries, so ordering the UNION'ed result is not needed\n          groupedLimitOrder = options.order;\n          delete options.order;\n          where.$$PLACEHOLDER$$ = true;\n        }\n\n        // Caching the base query and splicing the where part into it is consistently > twice\n        // as fast than generating from scratch each time for values.length >= 5\n        const baseQuery = '(' + this.selectQuery(\n          tableName,\n          {\n            attributes: options.attributes,\n            limit: options.groupedLimit.limit,\n            order: groupedLimitOrder,\n            where,\n            include,\n            model\n          },\n          model\n        ).replace(/;$/, '') + ')';\n        const placeHolder = this.whereItemQuery('$$PLACEHOLDER$$', true, { model });\n        const splicePos = baseQuery.indexOf(placeHolder);\n\n        mainQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.main, '(' +\n          options.groupedLimit.values.map(value => {\n            let groupWhere;\n            if (whereKey) {\n              groupWhere = {\n                [whereKey]: value\n              };\n            }\n            if (include) {\n              groupWhere = {\n                [options.groupedLimit.on.foreignIdentifierField]: value\n              };\n            }\n\n            return Utils.spliceStr(baseQuery, splicePos, placeHolder.length, this.getWhereConditions(groupWhere, groupedTableName));\n          }).join(\n            this._dialect.supports['UNION ALL'] ? ' UNION ALL ' : ' UNION '\n          )\n          + ')', mainTable.as));\n      } else {\n        mainQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.main, mainTable.quotedName, mainTable.as));\n      }\n\n      mainQueryItems.push(mainJoinQueries.join(''));\n    }\n\n    // Add WHERE to sub or main query\n    if (options.hasOwnProperty('where') && !options.groupedLimit) {\n      options.where = this.getWhereConditions(options.where, mainTable.as || tableName, model, options);\n      if (options.where) {\n        if (subQuery) {\n          subQueryItems.push(' WHERE ' + options.where);\n        } else {\n          mainQueryItems.push(' WHERE ' + options.where);\n          // Walk the main query to update all selects\n          _.each(mainQueryItems, (value, key) => {\n            if (value.match(/^SELECT/)) {\n              mainQueryItems[key] = this.selectFromTableFragment(options, model, attributes.main, mainTable.quotedName, mainTable.as, options.where);\n            }\n          });\n        }\n      }\n    }\n\n    // Add GROUP BY to sub or main query\n    if (options.group) {\n      options.group = Array.isArray(options.group) ? options.group.map(t => this.quote(t, model)).join(', ') : options.group;\n      if (subQuery) {\n        subQueryItems.push(' GROUP BY ' + options.group);\n      } else {\n        mainQueryItems.push(' GROUP BY ' + options.group);\n      }\n    }\n\n    // Add HAVING to sub or main query\n    if (options.hasOwnProperty('having')) {\n      options.having = this.getWhereConditions(options.having, tableName, model, options, false);\n      if (subQuery) {\n        subQueryItems.push(' HAVING ' + options.having);\n      } else {\n        mainQueryItems.push(' HAVING ' + options.having);\n      }\n    }\n\n    // Add ORDER to sub or main query\n    if (options.order) {\n      const orders = this.getQueryOrders(options, model, subQuery);\n      if (orders.mainQueryOrder.length) {\n        mainQueryItems.push(' ORDER BY ' + orders.mainQueryOrder.join(', '));\n      }\n      if (orders.subQueryOrder.length) {\n        subQueryItems.push(' ORDER BY ' + orders.subQueryOrder.join(', '));\n      }\n    }\n\n    // Add LIMIT, OFFSET to sub or main query\n    const limitOrder = this.addLimitAndOffset(options, mainTable.model);\n    if (limitOrder && !options.groupedLimit) {\n      if (subQuery) {\n        subQueryItems.push(limitOrder);\n      } else {\n        mainQueryItems.push(limitOrder);\n      }\n    }\n\n    if (subQuery) {\n      query = `SELECT ${attributes.main.join(', ')} FROM (${subQueryItems.join('')}) AS ${mainTable.as}${mainJoinQueries.join('')}${mainQueryItems.join('')}`;\n    } else {\n      query = mainQueryItems.join('');\n    }\n\n    if (options.lock && this._dialect.supports.lock) {\n      let lock = options.lock;\n      if (typeof options.lock === 'object') {\n        lock = options.lock.level;\n      }\n      if (this._dialect.supports.lockKey && (lock === 'KEY SHARE' || lock === 'NO KEY UPDATE')) {\n        query += ' FOR ' + lock;\n      } else if (lock === 'SHARE') {\n        query += ' ' + this._dialect.supports.forShare;\n      } else {\n        query += ' FOR UPDATE';\n      }\n      if (this._dialect.supports.lockOf && options.lock.of && options.lock.of.prototype instanceof Model) {\n        query += ' OF ' + this.quoteTable(options.lock.of.name);\n      }\n    }\n\n    return `${query};`;\n  },\n\n  escapeAttributes(attributes, options, mainTableAs) {\n    return attributes && attributes.map(attr => {\n      let addTable = true;\n\n      if (attr instanceof Utils.SequelizeMethod) {\n        return this.handleSequelizeMethod(attr);\n      }\n      if (Array.isArray(attr)) {\n        if (attr.length !== 2) {\n          throw new Error(JSON.stringify(attr) + ' is not a valid attribute definition. Please use the following format: [\\'attribute definition\\', \\'alias\\']');\n        }\n        attr = attr.slice();\n\n        if (attr[0] instanceof Utils.SequelizeMethod) {\n          attr[0] = this.handleSequelizeMethod(attr[0]);\n          addTable = false;\n        } else if (attr[0].indexOf('(') === -1 && attr[0].indexOf(')') === -1) {\n          attr[0] = this.quoteIdentifier(attr[0]);\n        }\n        attr = [attr[0], this.quoteIdentifier(attr[1])].join(' AS ');\n      } else {\n        attr = attr.indexOf(Utils.TICK_CHAR) < 0 && attr.indexOf('\"') < 0 ? this.quoteIdentifiers(attr) : attr;\n      }\n      if (options.include && attr.indexOf('.') === -1 && addTable) {\n        attr = mainTableAs + '.' + attr;\n      }\n\n      return attr;\n    });\n  },\n\n  generateInclude(include, parentTableName, topLevelInfo) {\n    const association = include.association;\n    const joinQueries = {\n      mainQuery: [],\n      subQuery: []\n    };\n    const mainChildIncludes = [];\n    const subChildIncludes = [];\n    let requiredMismatch = false;\n    const includeAs = {\n      internalAs: include.as,\n      externalAs: include.as\n    };\n    const attributes = {\n      main: [],\n      subQuery: []\n    };\n    let joinQuery;\n\n    topLevelInfo.options.keysEscaped = true;\n\n    if (topLevelInfo.names.name !== parentTableName.externalAs && topLevelInfo.names.as !== parentTableName.externalAs) {\n      includeAs.internalAs = `${parentTableName.internalAs}->${include.as}`;\n      includeAs.externalAs = `${parentTableName.externalAs}.${include.as}`;\n    }\n\n    // includeIgnoreAttributes is used by aggregate functions\n    if (topLevelInfo.options.includeIgnoreAttributes !== false) {\n      const includeAttributes = include.attributes.map(attr => {\n        let attrAs = attr;\n        let verbatim = false;\n\n        if (Array.isArray(attr) && attr.length === 2) {\n          if (attr[0] instanceof Utils.SequelizeMethod && (\n            attr[0] instanceof Utils.Literal ||\n            attr[0] instanceof Utils.Cast ||\n            attr[0] instanceof Utils.Fn\n          )) {\n            verbatim = true;\n          }\n\n          attr = attr.map(attr => attr instanceof Utils.SequelizeMethod ? this.handleSequelizeMethod(attr) : attr);\n\n          attrAs = attr[1];\n          attr = attr[0];\n        } else if (attr instanceof Utils.Literal) {\n          return attr.val; // We trust the user to rename the field correctly\n        } else if (attr instanceof Utils.Cast || attr instanceof Utils.Fn) {\n          throw new Error(\n            'Tried to select attributes using Sequelize.cast or Sequelize.fn without specifying an alias for the result, during eager loading. ' +\n            'This means the attribute will not be added to the returned instance'\n          );\n        }\n\n        let prefix;\n        if (verbatim === true) {\n          prefix = attr;\n        } else {\n          prefix = `${this.quoteIdentifier(includeAs.internalAs)}.${this.quoteIdentifier(attr)}`;\n        }\n        return `${prefix} AS ${this.quoteIdentifier(`${includeAs.externalAs}.${attrAs}`, true)}`;\n      });\n      if (include.subQuery && topLevelInfo.subQuery) {\n        for (const attr of includeAttributes) {\n          attributes.subQuery.push(attr);\n        }\n      } else {\n        for (const attr of includeAttributes) {\n          attributes.main.push(attr);\n        }\n      }\n    }\n\n    //through\n    if (include.through) {\n      joinQuery = this.generateThroughJoin(include, includeAs, parentTableName.internalAs, topLevelInfo);\n    } else {\n      if (topLevelInfo.subQuery && include.subQueryFilter) {\n        const associationWhere = {};\n\n        associationWhere[association.identifierField] = {\n          $eq: this.sequelize.literal(`${this.quoteTable(parentTableName.internalAs)}.${this.quoteIdentifier(association.sourceKeyField || association.source.primaryKeyField)}`)\n        };\n\n        if (!topLevelInfo.options.where) {\n          topLevelInfo.options.where = {};\n        }\n\n        // Creating the as-is where for the subQuery, checks that the required association exists\n        const $query = this.selectQuery(include.model.getTableName(), {\n          attributes: [association.identifierField],\n          where: {\n            $and: [\n              associationWhere,\n              include.where || {}\n            ]\n          },\n          limit: 1,\n          tableAs: include.as\n        }, include.model);\n\n        const subQueryWhere = this.sequelize.asIs([\n          '(',\n          $query.replace(/\\;$/, ''),\n          ')',\n          'IS NOT NULL'\n        ].join(' '));\n\n        if (_.isPlainObject(topLevelInfo.options.where)) {\n          topLevelInfo.options.where['__' + includeAs.internalAs] = subQueryWhere;\n        } else {\n          topLevelInfo.options.where = { $and: [topLevelInfo.options.where, subQueryWhere] };\n        }\n      }\n      joinQuery = this.generateJoin(include, topLevelInfo);\n    }\n\n    // handle possible new attributes created in join\n    if (joinQuery.attributes.main.length > 0) {\n      attributes.main = attributes.main.concat(joinQuery.attributes.main);\n    }\n\n    if (joinQuery.attributes.subQuery.length > 0) {\n      attributes.subQuery = attributes.subQuery.concat(joinQuery.attributes.subQuery);\n    }\n\n    if (include.include) {\n      for (const childInclude of include.include) {\n        if (childInclude.separate || childInclude._pseudo) {\n          continue;\n        }\n\n        const childJoinQueries = this.generateInclude(childInclude, includeAs, topLevelInfo);\n\n        if (include.required === false && childInclude.required === true) {\n          requiredMismatch = true;\n        }\n        // if the child is a sub query we just give it to the\n        if (childInclude.subQuery && topLevelInfo.subQuery) {\n          subChildIncludes.push(childJoinQueries.subQuery);\n        }\n        if (childJoinQueries.mainQuery) {\n          mainChildIncludes.push(childJoinQueries.mainQuery);\n        }\n        if (childJoinQueries.attributes.main.length > 0) {\n          attributes.main = attributes.main.concat(childJoinQueries.attributes.main);\n        }\n        if (childJoinQueries.attributes.subQuery.length > 0) {\n          attributes.subQuery = attributes.subQuery.concat(childJoinQueries.attributes.subQuery);\n        }\n      }\n    }\n\n    if (include.subQuery && topLevelInfo.subQuery) {\n      if (requiredMismatch && subChildIncludes.length > 0) {\n        joinQueries.subQuery.push(` ${joinQuery.join} ( ${joinQuery.body}${subChildIncludes.join('')} ) ON ${joinQuery.condition}`);\n      } else {\n        joinQueries.subQuery.push(` ${joinQuery.join} ${joinQuery.body} ON ${joinQuery.condition}`);\n        if (subChildIncludes.length > 0) {\n          joinQueries.subQuery.push(subChildIncludes.join(''));\n        }\n      }\n      joinQueries.mainQuery.push(mainChildIncludes.join(''));\n    } else {\n      if (requiredMismatch && mainChildIncludes.length > 0) {\n        joinQueries.mainQuery.push(` ${joinQuery.join} ( ${joinQuery.body}${mainChildIncludes.join('')} ) ON ${joinQuery.condition}`);\n      } else {\n        joinQueries.mainQuery.push(` ${joinQuery.join} ${joinQuery.body} ON ${joinQuery.condition}`);\n        if (mainChildIncludes.length > 0) {\n          joinQueries.mainQuery.push(mainChildIncludes.join(''));\n        }\n      }\n      joinQueries.subQuery.push(subChildIncludes.join(''));\n    }\n\n    return {\n      mainQuery: joinQueries.mainQuery.join(''),\n      subQuery: joinQueries.subQuery.join(''),\n      attributes\n    };\n  },\n\n  generateJoin(include, topLevelInfo) {\n    const association = include.association;\n    const parent = include.parent;\n    const parentIsTop = !!parent && !include.parent.association && include.parent.model.name === topLevelInfo.options.model.name;\n    let $parent;\n    let joinWhere;\n    /* Attributes for the left side */\n    const left = association.source;\n    const attrLeft = association instanceof BelongsTo ?\n      association.identifier :\n      association.sourceKeyAttribute || left.primaryKeyAttribute;\n    const fieldLeft = association instanceof BelongsTo ?\n      association.identifierField :\n      left.rawAttributes[association.sourceKeyAttribute || left.primaryKeyAttribute].field;\n    let asLeft;\n    /* Attributes for the right side */\n    const right = include.model;\n    const tableRight = right.getTableName();\n    const fieldRight = association instanceof BelongsTo ?\n      right.rawAttributes[association.targetIdentifier || right.primaryKeyAttribute].field :\n      association.identifierField;\n    let asRight = include.as;\n\n    while (($parent = $parent && $parent.parent || include.parent) && $parent.association) {\n      if (asLeft) {\n        asLeft = `${$parent.as}->${asLeft}`;\n      } else {\n        asLeft = $parent.as;\n      }\n    }\n\n    if (!asLeft) asLeft = parent.as || parent.model.name;\n    else asRight = `${asLeft}->${asRight}`;\n\n    let joinOn = `${this.quoteTable(asLeft)}.${this.quoteIdentifier(fieldLeft)}`;\n\n    if (topLevelInfo.options.groupedLimit && parentIsTop || topLevelInfo.subQuery && include.parent.subQuery && !include.subQuery) {\n      if (parentIsTop) {\n        // The main model attributes is not aliased to a prefix\n        joinOn = `${this.quoteTable(parent.as || parent.model.name)}.${this.quoteIdentifier(attrLeft)}`;\n      } else {\n        joinOn = this.quoteIdentifier(`${asLeft.replace(/->/g, '.')}.${attrLeft}`);\n      }\n    }\n\n    joinOn += ` = ${this.quoteIdentifier(asRight)}.${this.quoteIdentifier(fieldRight)}`;\n\n    if (include.on) {\n      joinOn = this.whereItemsQuery(include.on, {\n        prefix: this.sequelize.literal(this.quoteIdentifier(asRight)),\n        model: include.model\n      });\n    }\n\n    if (include.where) {\n      joinWhere = this.whereItemsQuery(include.where, {\n        prefix: this.sequelize.literal(this.quoteIdentifier(asRight)),\n        model: include.model\n      });\n      if (joinWhere) {\n        if (include.or) {\n          joinOn += ` OR ${joinWhere}`;\n        } else {\n          joinOn += ` AND ${joinWhere}`;\n        }\n      }\n    }\n\n    return {\n      join: include.required ? 'INNER JOIN' : 'LEFT OUTER JOIN',\n      body: this.quoteTable(tableRight, asRight),\n      condition: joinOn,\n      attributes: {\n        main: [],\n        subQuery: []\n      }\n    };\n  },\n\n  generateThroughJoin(include, includeAs, parentTableName, topLevelInfo) {\n    const through = include.through;\n    const throughTable = through.model.getTableName();\n    const throughAs = `${includeAs.internalAs}->${through.as}`;\n    const externalThroughAs = `${includeAs.externalAs}.${through.as}`;\n    const throughAttributes = through.attributes.map(attr =>\n      this.quoteIdentifier(throughAs) + '.' + this.quoteIdentifier(Array.isArray(attr) ? attr[0] : attr)\n      + ' AS '\n      + this.quoteIdentifier(externalThroughAs + '.' + (Array.isArray(attr) ? attr[1] : attr))\n    );\n    const association = include.association;\n    const parentIsTop = !include.parent.association && include.parent.model.name === topLevelInfo.options.model.name;\n    const primaryKeysSource = association.source.primaryKeyAttributes;\n    const tableSource = parentTableName;\n    const identSource = association.identifierField;\n    const primaryKeysTarget = association.target.primaryKeyAttributes;\n    const tableTarget = includeAs.internalAs;\n    const identTarget = association.foreignIdentifierField;\n    const attrTarget = association.target.rawAttributes[primaryKeysTarget[0]].field || primaryKeysTarget[0];\n\n    const joinType = include.required ? 'INNER JOIN' : 'LEFT OUTER JOIN';\n    let joinBody;\n    let joinCondition;\n    const attributes = {\n      main: [],\n      subQuery: []\n    };\n    let attrSource = primaryKeysSource[0];\n    let sourceJoinOn;\n    let targetJoinOn;\n    let throughWhere;\n    let targetWhere;\n\n    if (topLevelInfo.options.includeIgnoreAttributes !== false) {\n      // Through includes are always hasMany, so we need to add the attributes to the mainAttributes no matter what (Real join will never be executed in subquery)\n      for (const attr of throughAttributes) {\n        attributes.main.push(attr);\n      }\n    }\n\n    // Figure out if we need to use field or attribute\n    if (!topLevelInfo.subQuery) {\n      attrSource = association.source.rawAttributes[primaryKeysSource[0]].field;\n    }\n    if (topLevelInfo.subQuery && !include.subQuery && !include.parent.subQuery && include.parent.model !== topLevelInfo.options.mainModel) {\n      attrSource = association.source.rawAttributes[primaryKeysSource[0]].field;\n    }\n\n    // Filter statement for left side of through\n    // Used by both join and subquery where\n    // If parent include was in a subquery need to join on the aliased attribute\n    if (topLevelInfo.subQuery && !include.subQuery && include.parent.subQuery && !parentIsTop) {\n      sourceJoinOn = `${this.quoteIdentifier(`${tableSource}.${attrSource}`)} = `;\n    } else {\n      sourceJoinOn = `${this.quoteTable(tableSource)}.${this.quoteIdentifier(attrSource)} = `;\n    }\n    sourceJoinOn += `${this.quoteIdentifier(throughAs)}.${this.quoteIdentifier(identSource)}`;\n\n    // Filter statement for right side of through\n    // Used by both join and subquery where\n    targetJoinOn = `${this.quoteIdentifier(tableTarget)}.${this.quoteIdentifier(attrTarget)} = `;\n    targetJoinOn += `${this.quoteIdentifier(throughAs)}.${this.quoteIdentifier(identTarget)}`;\n\n    if (through.where) {\n      throughWhere = this.getWhereConditions(through.where, this.sequelize.literal(this.quoteIdentifier(throughAs)), through.model);\n    }\n\n    if (this._dialect.supports.joinTableDependent) {\n      // Generate a wrapped join so that the through table join can be dependent on the target join\n      joinBody = `( ${this.quoteTable(throughTable, throughAs)} INNER JOIN ${this.quoteTable(include.model.getTableName(), includeAs.internalAs)} ON ${targetJoinOn}`;\n      if (throughWhere) {\n        joinBody += ` AND ${throughWhere}`;\n      }\n      joinBody += ')';\n      joinCondition = sourceJoinOn;\n    } else {\n      // Generate join SQL for left side of through\n      joinBody = `${this.quoteTable(throughTable, throughAs)} ON ${sourceJoinOn} ${joinType} ${this.quoteTable(include.model.getTableName(), includeAs.internalAs)}`;\n      joinCondition = targetJoinOn;\n      if (throughWhere) {\n        joinCondition += ` AND ${throughWhere}`;\n      }\n    }\n\n    if (include.where || include.through.where) {\n      if (include.where) {\n        targetWhere = this.getWhereConditions(include.where, this.sequelize.literal(this.quoteIdentifier(includeAs.internalAs)), include.model, topLevelInfo.options);\n        if (targetWhere) {\n          joinCondition += ` AND ${targetWhere}`;\n        }\n      }\n      if (topLevelInfo.subQuery && include.required) {\n        if (!topLevelInfo.options.where) {\n          topLevelInfo.options.where = {};\n        }\n        let parent = include;\n        let child = include;\n        let nestedIncludes = [];\n        let query;\n\n        while ((parent = parent.parent)) { // eslint-disable-line\n          nestedIncludes = [_.extend({}, child, { include: nestedIncludes })];\n          child = parent;\n        }\n\n        const topInclude = nestedIncludes[0];\n        const topParent = topInclude.parent;\n\n        if (topInclude.through && Object(topInclude.through.model) === topInclude.through.model) {\n          query = this.selectQuery(topInclude.through.model.getTableName(), {\n            attributes: [topInclude.through.model.primaryKeyField],\n            include: Model._validateIncludedElements({\n              model: topInclude.through.model,\n              include: [{\n                association: topInclude.association.toTarget,\n                required: true\n              }]\n            }).include,\n            model: topInclude.through.model,\n            where: {\n              $and: [\n                this.sequelize.asIs([\n                  this.quoteTable(topParent.model.name) + '.' + this.quoteIdentifier(topParent.model.primaryKeyField),\n                  this.quoteIdentifier(topInclude.through.model.name) + '.' + this.quoteIdentifier(topInclude.association.identifierField)\n                ].join(' = ')),\n                topInclude.through.where\n              ]\n            },\n            limit: 1,\n            includeIgnoreAttributes: false\n          }, topInclude.through.model);\n        } else {\n          const isBelongsTo = topInclude.association.associationType === 'BelongsTo';\n          const join = [\n            this.quoteTable(topParent.model.name) + '.' + this.quoteIdentifier(isBelongsTo ? topInclude.association.identifierField : topParent.model.primaryKeyAttributes[0]),\n            this.quoteIdentifier(topInclude.model.name) + '.' + this.quoteIdentifier(isBelongsTo ? topInclude.model.primaryKeyAttributes[0] : topInclude.association.identifierField)\n          ].join(' = ');\n          query = this.selectQuery(topInclude.model.tableName, {\n            attributes: [topInclude.model.primaryKeyAttributes[0]],\n            include: topInclude.include,\n            where: {\n              $join: this.sequelize.asIs(join)\n            },\n            limit: 1,\n            includeIgnoreAttributes: false\n          }, topInclude.model);\n        }\n        topLevelInfo.options.where['__' + throughAs] = this.sequelize.asIs([\n          '(',\n          query.replace(/\\;$/, ''),\n          ')',\n          'IS NOT NULL'\n        ].join(' '));\n      }\n    }\n\n    return {\n      join: joinType,\n      body: joinBody,\n      condition: joinCondition,\n      attributes\n    };\n  },\n\n  getQueryOrders(options, model, subQuery) {\n    const mainQueryOrder = [];\n    const subQueryOrder = [];\n\n    if (Array.isArray(options.order)) {\n      for (let order of options.order) {\n        // wrap if not array\n        if (!Array.isArray(order)) {\n          order = [order];\n        }\n\n        if (\n          subQuery\n          && Array.isArray(order)\n          && order[0]\n          && !(order[0] instanceof Association)\n          && !(typeof order[0] === 'function' && order[0].prototype instanceof Model)\n          && !(typeof order[0].model === 'function' && order[0].model.prototype instanceof Model)\n          && !(typeof order[0] === 'string' && model && model.associations !== undefined && model.associations[order[0]])\n        ) {\n          subQueryOrder.push(this.quote(order, model, '->'));\n        }\n        mainQueryOrder.push(this.quote(order, model, '->'));\n      }\n    } else if (options.order instanceof Utils.SequelizeMethod) {\n      const sql = this.quote(options.order, model, '->');\n      if (subQuery) {\n        subQueryOrder.push(sql);\n      }\n      mainQueryOrder.push(sql);\n    } else {\n      throw new Error('Order must be type of array or instance of a valid sequelize method.');\n    }\n\n    return {mainQueryOrder, subQueryOrder};\n  },\n\n  selectFromTableFragment(options, model, attributes, tables, mainTableAs) {\n    let fragment = 'SELECT ' + attributes.join(', ') + ' FROM ' + tables;\n\n    if (mainTableAs) {\n      fragment += ' AS ' + mainTableAs;\n    }\n\n    return fragment;\n  },\n\n  /**\n   * Returns a query that starts a transaction.\n   *\n   * @param  {Boolean} value   A boolean that states whether autocommit shall be done or not.\n   * @param  {Object}  options An object with options.\n   * @return {String}          The generated sql query.\n   * @private\n   */\n  setAutocommitQuery(value, options) {\n    if (options.parent) {\n      return;\n    }\n\n    // no query when value is not explicitly set\n    if (typeof value === 'undefined' || value === null) {\n      return;\n    }\n\n    return 'SET autocommit = ' + (value ? 1 : 0) + ';';\n  },\n\n  /**\n   * Returns a query that sets the transaction isolation level.\n   *\n   * @param  {String} value   The isolation level.\n   * @param  {Object} options An object with options.\n   * @return {String}         The generated sql query.\n   * @private\n   */\n  setIsolationLevelQuery(value, options) {\n    if (options.parent) {\n      return;\n    }\n\n    return 'SET SESSION TRANSACTION ISOLATION LEVEL ' + value + ';';\n  },\n\n  generateTransactionId() {\n    return uuid.v4();\n  },\n\n  /**\n   * Returns a query that starts a transaction.\n   *\n   * @param  {Transaction} transaction\n   * @param  {Object} options An object with options.\n   * @return {String}         The generated sql query.\n   * @private\n   */\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      // force quoting of savepoint identifiers for postgres\n      return 'SAVEPOINT ' + this.quoteIdentifier(transaction.name, true) + ';';\n    }\n\n    return 'START TRANSACTION;';\n  },\n\n  /**\n   * Returns a query that defers the constraints. Only works for postgres.\n   *\n   * @param  {Transaction} transaction\n   * @param  {Object} options An object with options.\n   * @return {String}         The generated sql query.\n   * @private\n   */\n  deferConstraintsQuery() {},\n\n  setConstraintQuery() {},\n  setDeferredQuery() {},\n  setImmediateQuery() {},\n\n  /**\n   * Returns a query that commits a transaction.\n   *\n   * @param  {Object} options An object with options.\n   * @return {String}         The generated sql query.\n   * @private\n   */\n  commitTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return;\n    }\n\n    return 'COMMIT;';\n  },\n\n  /**\n   * Returns a query that rollbacks a transaction.\n   *\n   * @param  {Transaction} transaction\n   * @param  {Object} options An object with options.\n   * @return {String}         The generated sql query.\n   * @private\n   */\n  rollbackTransactionQuery(transaction) {\n    if (transaction.parent) {\n      // force quoting of savepoint identifiers for postgres\n      return 'ROLLBACK TO SAVEPOINT ' + this.quoteIdentifier(transaction.name, true) + ';';\n    }\n\n    return 'ROLLBACK;';\n  },\n\n  /**\n   * Returns an SQL fragment for adding result constraints\n   *\n   * @param  {Object} options An object with selectQuery options.\n   * @param  {Object} options The model passed to the selectQuery.\n   * @return {String}         The generated sql query.\n   * @private\n   */\n  addLimitAndOffset(options) {\n    let fragment = '';\n\n    /* eslint-disable */\n    if (options.offset != null && options.limit == null) {\n      fragment += ' LIMIT ' + this.escape(options.offset) + ', ' + 10000000000000;\n    } else if (options.limit != null) {\n      if (options.offset != null) {\n        fragment += ' LIMIT ' + this.escape(options.offset) + ', ' + this.escape(options.limit);\n      } else {\n        fragment += ' LIMIT ' + this.escape(options.limit);\n      }\n    }\n    /* eslint-enable */\n\n    return fragment;\n  },\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    let result;\n\n    if (smth instanceof Utils.Where) {\n      let value = smth.logic;\n      let key;\n\n      if (smth.attribute instanceof Utils.SequelizeMethod) {\n        key = this.getWhereConditions(smth.attribute, tableName, factory, options, prepend);\n      } else {\n        key = this.quoteTable(smth.attribute.Model.name) + '.' + this.quoteIdentifier(smth.attribute.field || smth.attribute.fieldName);\n      }\n\n      if (value && value instanceof Utils.SequelizeMethod) {\n        value = this.getWhereConditions(value, tableName, factory, options, prepend);\n\n        result = value === 'NULL' ? key + ' IS NULL' : [key, value].join(smth.comparator);\n      } else if (_.isPlainObject(value)) {\n        result = this.whereItemQuery(smth.attribute, value, {\n          model: factory\n        });\n      } else {\n        if (typeof value === 'boolean') {\n          value = this.booleanValue(value);\n        } else {\n          value = this.escape(value);\n        }\n\n        result = value === 'NULL' ? key + ' IS NULL' : [key, value].join(' ' + smth.comparator + ' ');\n      }\n    } else if (smth instanceof Utils.Literal) {\n      result = smth.val;\n    } else if (smth instanceof Utils.Cast) {\n      if (smth.val instanceof Utils.SequelizeMethod) {\n        result = this.handleSequelizeMethod(smth.val, tableName, factory, options, prepend);\n      } else if (_.isPlainObject(smth.val)) {\n        result = this.whereItemsQuery(smth.val);\n      } else {\n        result = this.escape(smth.val);\n      }\n\n      result = 'CAST(' + result + ' AS ' + smth.type.toUpperCase() + ')';\n    } else if (smth instanceof Utils.Fn) {\n      result = smth.fn + '(' + smth.args.map(arg => {\n        if (arg instanceof Utils.SequelizeMethod) {\n          return this.handleSequelizeMethod(arg, tableName, factory, options, prepend);\n        } else if (_.isPlainObject(arg)) {\n          return this.whereItemsQuery(arg);\n        } else {\n          return this.escape(arg);\n        }\n      }).join(', ') + ')';\n    } else if (smth instanceof Utils.Col) {\n      if (Array.isArray(smth.col)) {\n        if (!factory) {\n          throw new Error('Cannot call Sequelize.col() with array outside of order / group clause');\n        }\n      } else if (smth.col.indexOf('*') === 0) {\n        return '*';\n      }\n      return this.quote(smth.col, factory);\n    } else {\n      result = smth.toString(this, factory);\n    }\n\n    return result;\n  },\n\n  whereQuery(where, options) {\n    const query = this.whereItemsQuery(where, options);\n    if (query && query.length) {\n      return 'WHERE '+query;\n    }\n    return '';\n  },\n\n  whereItemsQuery(where, options, binding) {\n    if (\n      Array.isArray(where) && where.length === 0 ||\n      _.isPlainObject(where) && _.isEmpty(where) ||\n      where === null ||\n      where === undefined\n    ) {\n      // NO OP\n      return '';\n    }\n\n    if (_.isString(where)) {\n      throw new Error('Support for `{where: \\'raw query\\'}` has been removed.');\n    }\n\n    const items = [];\n\n    binding = binding || 'AND';\n    if (binding.substr(0, 1) !== ' ') binding = ' '+binding+' ';\n\n    if (_.isPlainObject(where)) {\n      _.forOwn(where, (value, key) => {\n        items.push(this.whereItemQuery(key, value, options));\n      });\n    } else {\n      items.push(this.whereItemQuery(undefined, where, options));\n    }\n\n    return items.length && items.filter(item => item && item.length).join(binding) || '';\n  },\n\n  whereItemQuery(key, value, options) {\n\n    options = options || {};\n\n    let binding;\n    let outerBinding;\n    let comparator = '=';\n    let field = options.field || options.model && options.model.rawAttributes && options.model.rawAttributes[key] || options.model && options.model.fieldRawAttributesMap && options.model.fieldRawAttributesMap[key];\n    let fieldType = field && field.type || options.type;\n\n    if (key && typeof key === 'string' && key.indexOf('.') !== -1 && options.model) {\n      if (options.model.rawAttributes[key.split('.')[0]] && options.model.rawAttributes[key.split('.')[0]].type instanceof DataTypes.JSON) {\n        field = options.model.rawAttributes[key.split('.')[0]];\n        fieldType = field.type;\n        const tmp = value;\n        value = {};\n\n        Dottie.set(value, key.split('.').slice(1), tmp);\n        key = field.field || key.split('.')[0];\n      }\n    }\n\n    const comparatorMap = {\n      $eq: '=',\n      $ne: '!=',\n      $gte: '>=',\n      $gt: '>',\n      $lte: '<=',\n      $lt: '<',\n      $not: 'IS NOT',\n      $is: 'IS',\n      $like: 'LIKE',\n      $notLike: 'NOT LIKE',\n      $iLike: 'ILIKE',\n      $notILike: 'NOT ILIKE',\n      $regexp: '~',\n      $notRegexp: '!~',\n      $iRegexp: '~*',\n      $notIRegexp: '!~*',\n      $between: 'BETWEEN',\n      $notBetween: 'NOT BETWEEN',\n      $overlap: '&&',\n      $contains: '@>',\n      $contained: '<@',\n      $adjacent: '-|-',\n      $strictLeft: '<<',\n      $strictRight: '>>',\n      $noExtendRight: '&<',\n      $noExtendLeft: '&>'\n    };\n\n    // Maintain BC\n    const aliasMap = {\n      'ne': '$ne',\n      'in': '$in',\n      'not': '$not',\n      'notIn': '$notIn',\n      'gte': '$gte',\n      'gt': '$gt',\n      'lte': '$lte',\n      'lt': '$lt',\n      'like': '$like',\n      'ilike': '$iLike',\n      '$ilike': '$iLike',\n      'nlike': '$notLike',\n      '$notlike': '$notLike',\n      'notilike': '$notILike',\n      '..': '$between',\n      'between': '$between',\n      '!..': '$notBetween',\n      'notbetween': '$notBetween',\n      'nbetween': '$notBetween',\n      'overlap': '$overlap',\n      '&&': '$overlap',\n      '@>': '$contains',\n      '<@': '$contained'\n    };\n\n    key = aliasMap[key] || key;\n    if (_.isPlainObject(value)) {\n      _.forOwn(value, (item, key) => {\n        if (aliasMap[key]) {\n          value[aliasMap[key]] = item;\n          delete value[key];\n        }\n      });\n    }\n\n    if (key === undefined) {\n      if (typeof value === 'string') {\n        return value;\n      }\n\n      if (_.isPlainObject(value) && _.size(value) === 1) {\n        key = Object.keys(value)[0];\n        value = _.values(value)[0];\n      }\n    }\n\n    if (value && value instanceof Utils.SequelizeMethod && !(key !== undefined && value instanceof Utils.Fn)) {\n      return this.handleSequelizeMethod(value);\n    }\n\n    // Convert where: [] to $and if possible, else treat as literal/replacements\n    if (key === undefined && Array.isArray(value)) {\n      if (Utils.canTreatArrayAsAnd(value)) {\n        key = '$and';\n      } else {\n        throw new Error('Support for literal replacements in the `where` object has been removed.');\n      }\n    }\n    // OR/AND/NOT grouping logic\n    if (key === '$or' || key === '$and' || key === '$not') {\n      binding = key === '$or' ?' OR ' : ' AND ';\n      outerBinding = '';\n      if (key === '$not') outerBinding = 'NOT ';\n\n      if (Array.isArray(value)) {\n        value = value.map(item => {\n          let itemQuery = this.whereItemsQuery(item, options, ' AND ');\n          if ((Array.isArray(item) || _.isPlainObject(item)) && _.size(item) > 1) {\n            itemQuery = '('+itemQuery+')';\n          }\n          return itemQuery;\n        }).filter(item => item && item.length);\n\n        // $or: [] should return no data.\n        // $not of no restriction should also return no data\n        if ((key === '$or' || key === '$not') && value.length === 0) {\n          return '0 = 1';\n        }\n\n        return value.length ? outerBinding + '('+value.join(binding)+')' : undefined;\n      } else {\n        value = this.whereItemsQuery(value, options, binding);\n\n        if ((key === '$or' || key === '$not') && !value) {\n          return '0 = 1';\n        }\n\n        return value ? outerBinding + '('+value+')' : undefined;\n      }\n    }\n\n    if (value && (value.$or || value.$and)) {\n      binding = value.$or ? ' OR ' : ' AND ';\n      value = value.$or || value.$and;\n\n      if (_.isPlainObject(value)) {\n        value = _.reduce(value, (result, _value, key) => {\n          result.push(_.zipObject([key], [_value]));\n          return result;\n        }, []);\n      }\n\n      value = value.map(_value => this.whereItemQuery(key, _value, options)).filter(item => item && item.length);\n\n      return value.length ? '('+value.join(binding)+')' : undefined;\n    }\n\n    if (_.isPlainObject(value) && fieldType instanceof DataTypes.JSON && options.json !== false) {\n      const items = [];\n      const traverse = (prop, item, path) => {\n        const where = {};\n        let cast;\n\n        if (path[path.length - 1].indexOf('::') > -1) {\n          const tmp = path[path.length - 1].split('::');\n          cast = tmp[1];\n          path[path.length - 1] = tmp[0];\n        }\n\n        let baseKey = this.quoteIdentifier(key);\n\n        if (options.prefix) {\n          if (options.prefix instanceof Utils.Literal) {\n            baseKey = `${this.handleSequelizeMethod(options.prefix)}.${baseKey}`;\n          } else {\n            baseKey = `${this.quoteTable(options.prefix)}.${baseKey}`;\n          }\n        }\n\n        baseKey = this.jsonPathExtractionQuery(baseKey, path);\n\n        const castKey = item => {\n          const key = baseKey;\n\n          if (!cast) {\n            if (typeof item === 'number') {\n              cast = 'double precision';\n            } else if (item instanceof Date) {\n              cast = 'timestamptz';\n            } else if (typeof item === 'boolean') {\n              cast = 'boolean';\n            }\n          }\n\n          if (cast) {\n            return this.handleSequelizeMethod(new Utils.Cast(new Utils.Literal(key), cast));\n          }\n\n          return key;\n        };\n\n        if (_.isPlainObject(item)) {\n          _.forOwn(item, (item, prop) => {\n            if (prop.indexOf('$') === 0) {\n              where[prop] = item;\n              const key = castKey(item);\n\n              items.push(this.whereItemQuery(new Utils.Literal(key), where/*, _.pick(options, 'prefix')*/));\n            } else {\n              traverse(prop, item, path.concat([prop]));\n            }\n          });\n        } else {\n          where.$eq = item;\n          const key = castKey(item);\n\n          items.push(this.whereItemQuery(new Utils.Literal(key), where/*, _.pick(options, 'prefix')*/));\n        }\n      };\n\n      _.forOwn(value, (item, prop) => {\n        if (prop.indexOf('$') === 0) {\n          const where = {};\n          where[prop] = item;\n          items.push(this.whereItemQuery(key, where, _.assign({}, options, {json: false})));\n          return;\n        }\n\n        traverse(prop, item, [prop]);\n      });\n\n      const result = items.join(' AND ');\n      return items.length > 1 ? '('+result+')' : result;\n    }\n\n    // If multiple keys we combine the different logic conditions\n    if (_.isPlainObject(value) && Object.keys(value).length > 1) {\n      const items = [];\n      _.forOwn(value, (item, logic) => {\n        const where = {};\n        where[logic] = item;\n        items.push(this.whereItemQuery(key, where, options));\n      });\n\n      return '('+items.join(' AND ')+')';\n    }\n\n    // Do [] to $in/$notIn normalization\n    if (value && (!fieldType || !(fieldType instanceof DataTypes.ARRAY))) {\n      if (Array.isArray(value)) {\n        value = {\n          $in: value\n        };\n      } else if (value && Array.isArray(value.$not)) {\n        value.$notIn = value.$not;\n        delete value.$not;\n      }\n    }\n\n    // normalize $not: non-bool|non-null to $ne\n    if (value && typeof value.$not !== 'undefined' && [null, true, false].indexOf(value.$not) < 0) {\n      value.$ne = value.$not;\n      delete value.$not;\n    }\n\n    // Setup keys and comparators\n    if (Array.isArray(value) && fieldType instanceof DataTypes.ARRAY) {\n      value = this.escape(value, field);\n    } else if (value && (value.$in || value.$notIn)) {\n      comparator = 'IN';\n      if (value.$notIn) comparator = 'NOT IN';\n\n      if ((value.$in || value.$notIn) instanceof Utils.Literal) {\n        value = (value.$in || value.$notIn).val;\n      } else if ((value.$in || value.$notIn).length) {\n        value = '('+(value.$in || value.$notIn).map(item => this.escape(item)).join(', ')+')';\n      } else {\n        if (value.$in) {\n          value = '(NULL)';\n        } else {\n          return '';\n        }\n      }\n    } else if (value && (value.$any || value.$all)) {\n      comparator = value.$any ? '= ANY' : '= ALL';\n      if (value.$any && value.$any.$values || value.$all && value.$all.$values) {\n        value = '(VALUES '+(value.$any && value.$any.$values || value.$all && value.$all.$values).map(value => '('+this.escape(value)+')').join(', ')+')';\n      } else {\n        value = '('+this.escape(value.$any || value.$all, field)+')';\n      }\n    } else if (value && (value.$between || value.$notBetween)) {\n      comparator = 'BETWEEN';\n      if (value.$notBetween) comparator = 'NOT BETWEEN';\n\n      value = (value.$between || value.$notBetween).map(item => this.escape(item)).join(' AND ');\n    } else if (value && value.$raw) {\n      throw new Error('The `$raw` where property is no longer supported.  Use `sequelize.literal` instead.');\n    } else if (value && value.$col) {\n      value = value.$col.split('.');\n\n      if (value.length > 2) {\n        value = [\n          // join the tables by -> to match out internal namings\n          value.slice(0, -1).join('->'),\n          value[value.length - 1]\n        ];\n      }\n\n      value = value.map(identifier => this.quoteIdentifier(identifier)).join('.');\n    } else {\n      let escapeValue = true;\n      const escapeOptions = {};\n\n      if (_.isPlainObject(value)) {\n        _.forOwn(value, (item, key) => {\n          if (comparatorMap[key]) {\n            comparator = comparatorMap[key];\n            value = item;\n\n            if (_.isPlainObject(value) && value.$any) {\n              comparator += ' ANY';\n              escapeOptions.isList = true;\n              value = value.$any;\n            } else if (_.isPlainObject(value) && value.$all) {\n              comparator += ' ALL';\n              escapeOptions.isList = true;\n              value = value.$all;\n            } else if (value && value.$col) {\n              escapeValue = false;\n              value = this.whereItemQuery(null, value);\n            }\n          }\n        });\n      }\n\n      if (comparator === '=' && value === null) {\n        comparator = 'IS';\n      } else if (comparator === '!=' && value === null) {\n        comparator = 'IS NOT';\n      }\n\n      if (comparator.indexOf('~') !== -1) {\n        escapeValue = false;\n      }\n\n      if (this._dialect.name === 'mysql') {\n        if (comparator ===  '~') {\n          comparator = 'REGEXP';\n        } else if (comparator ===  '!~') {\n          comparator = 'NOT REGEXP';\n        }\n      }\n\n      escapeOptions.acceptStrings = comparator.indexOf('LIKE') !== -1;\n      escapeOptions.acceptRegExp = comparator.indexOf('~') !== -1 || comparator.indexOf('REGEXP') !== -1;\n\n      if (escapeValue) {\n        value = this.escape(value, field, escapeOptions);\n\n        // if ANY or ALL is used with like, add parentheses to generate correct query\n        if (escapeOptions.acceptStrings && (\n          comparator.indexOf('ANY') > comparator.indexOf('LIKE') ||\n          comparator.indexOf('ALL') > comparator.indexOf('LIKE')\n        )) {\n          value = '(' + value + ')';\n        }\n      } else if (escapeOptions.acceptRegExp) {\n        value = '\\'' + value + '\\'';\n      }\n    }\n\n    if (key) {\n      let prefix = true;\n      if (key instanceof Utils.SequelizeMethod) {\n        key = this.handleSequelizeMethod(key);\n      } else if (Utils.isColString(key)) {\n        key = key.substr(1, key.length - 2).split('.');\n\n        if (key.length > 2) {\n          key = [\n            // join the tables by -> to match out internal namings\n            key.slice(0, -1).join('->'),\n            key[key.length - 1]\n          ];\n        }\n\n        key = key.map(identifier => this.quoteIdentifier(identifier)).join('.');\n        prefix = false;\n      } else {\n        key = this.quoteIdentifier(key);\n      }\n\n      if (options.prefix && prefix) {\n        if (options.prefix instanceof Utils.Literal) {\n          key = [this.handleSequelizeMethod(options.prefix), key].join('.');\n        } else {\n          key = [this.quoteTable(options.prefix), key].join('.');\n        }\n      }\n      return [key, value].join(' '+comparator+' ');\n    }\n    return value;\n  },\n\n  /*\n    Takes something and transforms it into values of a where condition.\n   @private\n  */\n  getWhereConditions(smth, tableName, factory, options, prepend) {\n    let result = null;\n    const where = {};\n\n    if (Array.isArray(tableName)) {\n      tableName = tableName[0];\n      if (Array.isArray(tableName)) {\n        tableName = tableName[1];\n      }\n    }\n\n    options = options || {};\n\n    if (typeof prepend === 'undefined') {\n      prepend = true;\n    }\n\n    if (smth && smth instanceof Utils.SequelizeMethod) { // Checking a property is cheaper than a lot of instanceof calls\n      result = this.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n    } else if (_.isPlainObject(smth)) {\n      return this.whereItemsQuery(smth, {\n        model: factory,\n        prefix: prepend && tableName\n      });\n    } else if (typeof smth === 'number') {\n      let primaryKeys = factory ? Object.keys(factory.primaryKeys) : [];\n\n      if (primaryKeys.length > 0) {\n        // Since we're just a number, assume only the first key\n        primaryKeys = primaryKeys[0];\n      } else {\n        primaryKeys = 'id';\n      }\n\n      where[primaryKeys] = smth;\n\n      return this.whereItemsQuery(where, {\n        model: factory,\n        prefix: prepend && tableName\n      });\n    } else if (typeof smth === 'string') {\n      return this.whereItemsQuery(smth, {\n        model: factory,\n        prefix: prepend && tableName\n      });\n    } else if (Buffer.isBuffer(smth)) {\n      result = this.escape(smth);\n    } else if (Array.isArray(smth)) {\n      if (smth.length === 0 || smth.length > 0 && smth[0].length === 0) return '1=1';\n      if (Utils.canTreatArrayAsAnd(smth)) {\n        const _smth = { $and: smth };\n        result = this.getWhereConditions(_smth, tableName, factory, options, prepend);\n      } else {\n        throw new Error('Support for literal replacements in the `where` object has been removed.');\n      }\n    } else if (smth === null) {\n      return this.whereItemsQuery(smth, {\n        model: factory,\n        prefix: prepend && tableName\n      });\n    }\n\n    return result ? result : '1=1';\n  },\n\n  // A recursive parser for nested where conditions\n  parseConditionObject(conditions, path) {\n    path = path || [];\n    return _.reduce(conditions, (result, value, key) => {\n      if (_.isObject(value)) {\n        result = result.concat(this.parseConditionObject(value, path.concat(key))); // Recursively parse objects\n      } else {\n        result.push({ path: path.concat(key), value });\n      }\n      return result;\n    }, []);\n  },\n\n  isIdentifierQuoted(string) {\n    return /^\\s*(?:([`\"'])(?:(?!\\1).|\\1{2})*\\1\\.?)+\\s*$/i.test(string);\n  },\n\n  booleanValue(value) {\n    return value;\n  }\n};\n\nmodule.exports = QueryGenerator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/dialects/abstract/query-generator.js\n// module id = 26\n// module chunks = 0","module.exports = require(\"fs\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"fs\"\n// module id = 27\n// module chunks = 0","'use strict';\n\nconst hstore = require('pg-hstore')({sanitize : true});\n\nfunction stringify(data) {\n  if (data === null) return null;\n  return hstore.stringify(data);\n}\nexports.stringify = stringify;\n\nfunction parse(value) {\n  if (value === null) return null;\n  return hstore.parse(value);\n}\nexports.parse = parse;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/dialects/postgres/hstore.js\n// module id = 28\n// module chunks = 0","'use strict';\n\nconst dataTypes = require('./data-types');\nconst _ = require('lodash');\n\nfunction escape(val, timeZone, dialect, format) {\n  let prependN = false;\n  if (val === undefined || val === null) {\n    return 'NULL';\n  }\n  switch (typeof val) {\n    case 'boolean':\n    // SQLite doesn't have true/false support. MySQL aliases true/false to 1/0\n    // for us. Postgres actually has a boolean type with true/false literals,\n    // but sequelize doesn't use it yet.\n      if (dialect === 'sqlite' || dialect === 'mssql') {\n        return +!!val;\n      }\n      return '' + !!val;\n    case 'number':\n      return val + '';\n    case 'string':\n    // In mssql, prepend N to all quoted vals which are originally a string (for\n    // unicode compatibility)\n      prependN = dialect === 'mssql';\n      break;\n  }\n\n  if (val instanceof Date) {\n    val = dataTypes[dialect].DATE.prototype.stringify(val, { timezone: timeZone });\n  }\n\n  if (Buffer.isBuffer(val)) {\n    if (dataTypes[dialect].BLOB) {\n      return dataTypes[dialect].BLOB.prototype.stringify(val);\n    }\n\n    return dataTypes.BLOB.prototype.stringify(val);\n  }\n\n  if (Array.isArray(val)) {\n    const partialEscape = _.partial(escape, _, timeZone, dialect, format);\n    if (dialect === 'postgres' && !format) {\n      return dataTypes.ARRAY.prototype.stringify(val, {escape: partialEscape});\n    }\n    return val.map(partialEscape);\n  }\n\n  if (!val.replace) {\n    throw new Error('Invalid value ' + val);\n  }\n\n  if (dialect === 'postgres' || dialect === 'sqlite' || dialect === 'mssql') {\n    // http://www.postgresql.org/docs/8.2/static/sql-syntax-lexical.html#SQL-SYNTAX-STRINGS\n    // http://stackoverflow.com/q/603572/130598\n    val = val.replace(/'/g, \"''\");\n  } else {\n    val = val.replace(/[\\0\\n\\r\\b\\t\\\\\\'\\\"\\x1a]/g, s => {\n      switch (s) {\n        case '\\0': return '\\\\0';\n        case '\\n': return '\\\\n';\n        case '\\r': return '\\\\r';\n        case '\\b': return '\\\\b';\n        case '\\t': return '\\\\t';\n        case '\\x1a': return '\\\\Z';\n        default: return '\\\\' + s;\n      }\n    });\n  }\n  return (prependN ? \"N'\" : \"'\") + val + \"'\";\n}\nexports.escape = escape;\n\nfunction format(sql, values, timeZone, dialect) {\n  values = [].concat(values);\n\n  if (typeof sql !== 'string') {\n    throw new Error('Invalid SQL string provided: ' + sql);\n  }\n  return sql.replace(/\\?/g, match => {\n    if (!values.length) {\n      return match;\n    }\n\n    return escape(values.shift(), timeZone, dialect, true);\n  });\n}\nexports.format = format;\n\nfunction formatNamedParameters(sql, values, timeZone, dialect) {\n  return sql.replace(/\\:+(?!\\d)(\\w+)/g, (value, key) => {\n    if ('postgres' === dialect && '::' === value.slice(0, 2)) {\n      return value;\n    }\n\n    if (values[key] !== undefined) {\n      return escape(values[key], timeZone, dialect, true);\n    } else {\n      throw new Error('Named parameter \"' + value + '\" has no value in the given object.');\n    }\n  });\n}\nexports.formatNamedParameters = formatNamedParameters;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/sql-string.js\n// module id = 29\n// module chunks = 0","module.exports = require(\"uuid\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"uuid\"\n// module id = 30\n// module chunks = 0","'use strict';\n\nconst Utils = require('./../utils');\nconst Helpers = require('./helpers');\nconst _ = require('lodash');\nconst Association = require('./base');\n\n/**\n * One-to-one association\n *\n * In the API reference below, add the name of the association to the method, e.g. for `User.hasOne(Project)` the getter will be `user.getProject()`.\n * This is almost the same as `belongsTo` with one exception - The foreign key will be defined on the target model.\n *\n * @see {@link Model.hasOne}\n */\nclass HasOne extends Association {\n  constructor(source, target, options) {\n    super(source, target, options);\n\n    this.associationType = 'HasOne';\n    this.isSingleAssociation = true;\n    this.foreignKeyAttribute = {};\n\n    if (this.as) {\n      this.isAliased = true;\n      this.options.name = {\n        singular: this.as\n      };\n    } else {\n      this.as = this.target.options.name.singular;\n      this.options.name = this.target.options.name;\n    }\n\n    if (_.isObject(this.options.foreignKey)) {\n      this.foreignKeyAttribute = this.options.foreignKey;\n      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n    } else if (this.options.foreignKey) {\n      this.foreignKey = this.options.foreignKey;\n    }\n\n    if (!this.foreignKey) {\n      this.foreignKey = Utils.camelizeIf(\n        [\n          Utils.underscoredIf(Utils.singularize(this.options.as || this.source.name), this.target.options.underscored),\n          this.source.primaryKeyAttribute\n        ].join('_'),\n        !this.source.options.underscored\n      );\n    }\n\n    this.sourceIdentifier = this.source.primaryKeyAttribute;\n    this.sourceKey = this.source.primaryKeyAttribute;\n    this.sourceKeyIsPrimary = this.sourceKey === this.source.primaryKeyAttribute;\n\n    this.associationAccessor = this.as;\n    this.options.useHooks = options.useHooks;\n\n    if (this.target.rawAttributes[this.foreignKey]) {\n      this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    }\n\n    // Get singular name, trying to uppercase the first letter, unless the model forbids it\n    const singular = Utils.uppercaseFirst(this.options.name.singular);\n\n    this.accessors = {\n      get: 'get' + singular,\n      set: 'set' + singular,\n      create: 'create' + singular\n    };\n  }\n\n  // the id is in the target table\n  injectAttributes() {\n    const newAttributes = {};\n    const keyType = this.source.rawAttributes[this.source.primaryKeyAttribute].type;\n\n    newAttributes[this.foreignKey] = _.defaults({}, this.foreignKeyAttribute, {\n      type: this.options.keyType || keyType,\n      allowNull : true\n    });\n    Utils.mergeDefaults(this.target.rawAttributes, newAttributes);\n\n    this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n\n    if (this.options.constraints !== false) {\n      const target = this.target.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];\n      this.options.onDelete = this.options.onDelete || (target.allowNull ? 'SET NULL' : 'CASCADE');\n      this.options.onUpdate = this.options.onUpdate || 'CASCADE';\n    }\n\n    Helpers.addForeignKeyConstraints(this.target.rawAttributes[this.foreignKey], this.source, this.target, this.options);\n\n    // Sync attributes and setters/getters to Model prototype\n    this.target.refreshAttributes();\n\n    Helpers.checkNamingCollision(this);\n\n    return this;\n  }\n\n  mixin(obj) {\n    const methods = ['get', 'set', 'create'];\n\n    Helpers.mixinMethods(this, obj, methods);\n  }\n\n  /**\n   * Get the associated instance.\n   *\n   * @param {Object} [options]\n   * @param {String|Boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n   * @param {String} [options.schema] Apply a schema on the related model\n   * @see {@link Model.findOne} for a full explanation of options\n   * @return {Promise<Model>}\n   */\n  get(instances, options) {\n    const association = this;\n    const where = {};\n    let Target = association.target;\n    let instance;\n\n    options = Utils.cloneDeep(options);\n\n    if (options.hasOwnProperty('scope')) {\n      if (!options.scope) {\n        Target = Target.unscoped();\n      } else {\n        Target = Target.scope(options.scope);\n      }\n    }\n\n    if (options.hasOwnProperty('schema')) {\n      Target = Target.schema(options.schema, options.schemaDelimiter);\n    }\n\n    if (!Array.isArray(instances)) {\n      instance = instances;\n      instances = undefined;\n    }\n\n    if (instances) {\n      where[association.foreignKey] = {\n        $in: instances.map(instance => instance.get(association.sourceKey))\n      };\n    } else {\n      where[association.foreignKey] = instance.get(association.sourceKey);\n    }\n\n    if (association.scope) {\n      _.assign(where, association.scope);\n    }\n\n    options.where = options.where ?\n      {$and: [where, options.where]} :\n      where;\n\n    if (instances) {\n      return Target.findAll(options).then(results => {\n        const result = {};\n        for (const instance of instances) {\n          result[instance.get(association.sourceKey, {raw: true})] = null;\n        }\n\n        for (const instance of results) {\n          result[instance.get(association.foreignKey, {raw: true})] = instance;\n        }\n\n        return result;\n      });\n    }\n    return Target.findOne(options);\n  }\n\n  /**\n   * Set the associated model.\n   *\n   * @param {Model|String|Number} [newAssociation] An persisted instance or the primary key of a persisted instance to associate with this. Pass `null` or `undefined` to remove the association.\n   * @param {Object} [options] Options passed to getAssociation and `target.save`\n   * @return {Promise}\n   */\n  set(sourceInstance, associatedInstance, options) {\n    const association = this;\n\n    let alreadyAssociated;\n\n    options = _.assign({}, options, {\n      scope: false\n    });\n\n    return sourceInstance[association.accessors.get](options).then(oldInstance => {\n      // TODO Use equals method once #5605 is resolved\n      alreadyAssociated = oldInstance && associatedInstance && _.every(association.target.primaryKeyAttributes, attribute =>\n        oldInstance.get(attribute, {raw: true}) === (associatedInstance.get ? associatedInstance.get(attribute, {raw: true}) : associatedInstance)\n      );\n\n      if (oldInstance && !alreadyAssociated) {\n        oldInstance[association.foreignKey] = null;\n        return oldInstance.save(_.extend({}, options, {\n          fields: [association.foreignKey],\n          allowNull: [association.foreignKey],\n          association: true\n        }));\n      }\n    }).then(() => {\n      if (associatedInstance && !alreadyAssociated) {\n        if (!(associatedInstance instanceof association.target)) {\n          const tmpInstance = {};\n          tmpInstance[association.target.primaryKeyAttribute] = associatedInstance;\n          associatedInstance = association.target.build(tmpInstance, {\n            isNewRecord: false\n          });\n        }\n\n        _.assign(associatedInstance, association.scope);\n        associatedInstance.set(association.foreignKey, sourceInstance.get(association.sourceIdentifier));\n\n        return associatedInstance.save(options);\n      }\n\n      return null;\n    });\n  }\n\n  /**\n   * Create a new instance of the associated model and associate it with this.\n   *\n   * @param {Object} [values]\n   * @param {Object} [options] Options passed to `target.create` and setAssociation.\n   * @see {@link Model#create} for a full explanation of options\n   * @return {Promise}\n   */\n  create(sourceInstance, values, options) {\n    const association = this;\n\n    values = values || {};\n    options = options || {};\n\n    if (association.scope) {\n      for (const attribute of Object.keys(association.scope)) {\n        values[attribute] = association.scope[attribute];\n        if (options.fields) {\n          options.fields.push(attribute);\n        }\n      }\n    }\n\n    values[association.foreignKey] = sourceInstance.get(association.sourceIdentifier);\n    if (options.fields) {\n      options.fields.push(association.foreignKey);\n    }\n\n    return association.target.create(values, options);\n  }\n}\n\nmodule.exports = HasOne;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/associations/has-one.js\n// module id = 31\n// module chunks = 0","module.exports = require(\"dottie\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"dottie\"\n// module id = 32\n// module chunks = 0","module.exports = require(\"koa-router\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"koa-router\"\n// module id = 33\n// module chunks = 0","module.exports = require(\"wkx\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"wkx\"\n// module id = 34\n// module chunks = 0","'use strict';\n\nconst Utils = require('./utils');\nconst BelongsTo = require('./associations/belongs-to');\nconst BelongsToMany = require('./associations/belongs-to-many');\nconst InstanceValidator = require('./instance-validator');\nconst QueryTypes = require('./query-types');\nconst sequelizeErrors = require('./errors');\nconst Dottie = require('dottie');\nconst Promise = require('./promise');\nconst _ = require('lodash');\nconst moment = require('moment');\nconst Association = require('./associations/base');\nconst HasMany = require('./associations/has-many');\nconst DataTypes = require('./data-types');\nconst Hooks = require('./hooks');\nconst associationsMixin = require('./associations/mixin');\nconst defaultsOptions = { raw: true };\nconst assert = require('assert');\n\n/**\n * A Model represents a table in the database. Instances of this class represent a database row.\n *\n * Model instances operate with the concept of a `dataValues` property, which stores the actual values represented by the instance.\n * By default, the values from dataValues can also be accessed directly from the Instance, that is:\n * ```js\n * instance.field\n * // is the same as\n * instance.get('field')\n * // is the same as\n * instance.getDataValue('field')\n * ```\n * However, if getters and/or setters are defined for `field` they will be invoked, instead of returning the value from `dataValues`.\n * Accessing properties directly or using `get` is preferred for regular use, `getDataValue` should only be used for custom getters.\n *\n * @see {@link Sequelize#define} for more information about getters and setters\n * @class Model\n * @mixes Hooks\n */\nclass Model {\n  static get QueryInterface() {\n    return this.sequelize.getQueryInterface();\n  }\n\n  static get QueryGenerator() {\n    return this.QueryInterface.QueryGenerator;\n  }\n\n  // validateIncludedElements should have been called before this method\n  static _paranoidClause(model, options) {\n    options = options || {};\n\n    // Apply on each include\n    // This should be handled before handling where conditions because of logic with returns\n    // otherwise this code will never run on includes of a already conditionable where\n    if (options.include) {\n      for (const include of options.include) {\n        this._paranoidClause(include.model, include);\n      }\n    }\n\n    // apply paranoid when groupedLimit is used\n    if (_.get(options, 'groupedLimit.on.options.paranoid')) {\n      const throughModel = _.get(options, 'groupedLimit.on.through.model');\n      if (throughModel) {\n        options.groupedLimit.through = this._paranoidClause(throughModel, options.groupedLimit.through);\n      }\n    }\n\n    if (!model.options.timestamps || !model.options.paranoid || options.paranoid === false) {\n      // This model is not paranoid, nothing to do here;\n      return options;\n    }\n\n    const deletedAtCol = model._timestampAttributes.deletedAt;\n    const deletedAtAttribute = model.rawAttributes[deletedAtCol];\n    const deletedAtObject = {};\n    let deletedAtDefaultValue = deletedAtAttribute.hasOwnProperty('defaultValue') ? deletedAtAttribute.defaultValue : null;\n\n    deletedAtDefaultValue = deletedAtDefaultValue || { $or: { $gt: model.sequelize.literal('CURRENT_TIMESTAMP'), $eq: null } };\n\n    deletedAtObject[deletedAtAttribute.field || deletedAtCol] = deletedAtDefaultValue;\n\n    if (Utils._.isEmpty(options.where)) {\n      options.where = deletedAtObject;\n    } else {\n      options.where = { $and: [deletedAtObject, options.where] };\n    }\n\n    return options;\n  }\n\n  static _addDefaultAttributes() {\n    const tail = {};\n    let head = {};\n\n    // Add id if no primary key was manually added to definition\n    // Can't use this.primaryKeys here, since this function is called before PKs are identified\n    if (!_.some(this.rawAttributes, 'primaryKey')) {\n      if ('id' in this.rawAttributes) {\n        // Something is fishy here!\n        throw new Error(`A column called 'id' was added to the attributes of '${this.tableName}' but not marked with 'primaryKey: true'`);\n      }\n\n      head = {\n        id: {\n          type: new DataTypes.INTEGER(),\n          allowNull: false,\n          primaryKey: true,\n          autoIncrement: true,\n          _autoGenerated: true\n        }\n      };\n    }\n\n    if (this._timestampAttributes.createdAt) {\n      tail[this._timestampAttributes.createdAt] = {\n        type: DataTypes.DATE,\n        allowNull: false,\n        _autoGenerated: true\n      };\n    }\n\n    if (this._timestampAttributes.updatedAt) {\n      tail[this._timestampAttributes.updatedAt] = {\n        type: DataTypes.DATE,\n        allowNull: false,\n        _autoGenerated: true\n      };\n    }\n\n    if (this._timestampAttributes.deletedAt) {\n      tail[this._timestampAttributes.deletedAt] = {\n        type: DataTypes.DATE,\n        _autoGenerated: true\n      };\n    }\n\n    if (this._versionAttribute) {\n      tail[this._versionAttribute] = {\n        type: DataTypes.INTEGER,\n        allowNull: false,\n        defaultValue: 0,\n        _autoGenerated: true\n      };\n    }\n\n    const existingAttributes = Utils._.clone(this.rawAttributes);\n    this.rawAttributes = {};\n\n    Utils._.each(head, (value, attr) => {\n      this.rawAttributes[attr] = value;\n    });\n\n    Utils._.each(existingAttributes, (value, attr) => {\n      this.rawAttributes[attr] = value;\n    });\n\n    Utils._.each(tail, (value, attr) => {\n      if (Utils._.isUndefined(this.rawAttributes[attr])) {\n        this.rawAttributes[attr] = value;\n      }\n    });\n\n    if (!Object.keys(this.primaryKeys).length) {\n      this.primaryKeys.id = this.rawAttributes.id;\n    }\n  }\n\n  static _findAutoIncrementAttribute() {\n    this.autoIncrementAttribute = null;\n\n    for (const name in this.rawAttributes) {\n      if (this.rawAttributes.hasOwnProperty(name)) {\n        const definition = this.rawAttributes[name];\n        if (definition && definition.autoIncrement) {\n          if (this.autoIncrementAttribute) {\n            throw new Error('Invalid Instance definition. Only one autoincrement field allowed.');\n          } else {\n            this.autoIncrementAttribute = name;\n          }\n        }\n      }\n    }\n  }\n\n  static _conformOptions(options, self) {\n    if (self) {\n      self._expandAttributes(options);\n    }\n\n    if (!options.include) {\n      return;\n    }\n    // if include is not an array, wrap in an array\n    if (!Array.isArray(options.include)) {\n      options.include = [options.include];\n    } else if (!options.include.length) {\n      delete options.include;\n      return;\n    }\n\n    // convert all included elements to { model: Model } form\n    options.include = options.include.map(include => this._conformInclude(include, self));\n  }\n\n  static _transformStringAssociation(include, self) {\n    if (self && typeof include === 'string') {\n      if (!self.associations.hasOwnProperty(include)) {\n        throw new Error('Association with alias \"' + include + '\" does not exists');\n      }\n      return self.associations[include];\n    }\n    return include;\n  }\n\n  static _conformInclude(include, self) {\n    let model;\n\n    if (include._pseudo) return include;\n\n    include = this._transformStringAssociation(include, self);\n\n    if (include instanceof Association) {\n      if (self && include.target.name === self.name) {\n        model = include.source;\n      } else {\n        model = include.target;\n      }\n\n      include = { model, association: include, as: include.as };\n    } else if (include.prototype && include.prototype instanceof Model) {\n      include = { model: include };\n    } else if (_.isPlainObject(include)) {\n      if (include.association) {\n\n        include.association = this._transformStringAssociation(include.association, self);\n\n        if (self && include.association.target.name === self.name) {\n          model = include.association.source;\n        } else {\n          model = include.association.target;\n        }\n\n        if (!include.model) {\n          include.model = model;\n        }\n        if (!include.as) {\n          include.as = include.association.as;\n        }\n      } else {\n        model = include.model;\n      }\n\n      this._conformOptions(include, model);\n    } else {\n      throw new Error('Include unexpected. Element has to be either a Model, an Association or an object.');\n    }\n\n    return include;\n  }\n\n  static _expandIncludeAllElement(includes, include) {\n    // check 'all' attribute provided is valid\n    let all = include.all;\n    delete include.all;\n\n    if (all !== true) {\n      if (!Array.isArray(all)) {\n        all = [all];\n      }\n\n      const validTypes = {\n        BelongsTo: true,\n        HasOne: true,\n        HasMany: true,\n        One: ['BelongsTo', 'HasOne'],\n        Has: ['HasOne', 'HasMany'],\n        Many: ['HasMany']\n      };\n\n      for (let i = 0; i < all.length; i++) {\n        const type = all[i];\n        if (type === 'All') {\n          all = true;\n          break;\n        }\n\n        const types = validTypes[type];\n        if (!types) {\n          throw new sequelizeErrors.EagerLoadingError('include all \\'' + type + '\\' is not valid - must be BelongsTo, HasOne, HasMany, One, Has, Many or All');\n        }\n\n        if (types !== true) {\n          // replace type placeholder e.g. 'One' with it's constituent types e.g. 'HasOne', 'BelongsTo'\n          all.splice(i, 1);\n          i--;\n          for (let j = 0; j < types.length; j++) {\n            if (all.indexOf(types[j]) === -1) {\n              all.unshift(types[j]);\n              i++;\n            }\n          }\n        }\n      }\n    }\n\n    // add all associations of types specified to includes\n    const nested = include.nested;\n    if (nested) {\n      delete include.nested;\n\n      if (!include.include) {\n        include.include = [];\n      } else if (!Array.isArray(include.include)) {\n        include.include = [include.include];\n      }\n    }\n\n    const used = [];\n    (function addAllIncludes(parent, includes) {\n      Utils._.forEach(parent.associations, association => {\n        if (all !== true && all.indexOf(association.associationType) === -1) {\n          return;\n        }\n\n        // check if model already included, and skip if so\n        const model = association.target;\n        const as = association.options.as;\n\n        const predicate = {model};\n        if (as) {\n          // We only add 'as' to the predicate if it actually exists\n          predicate.as = as;\n        }\n\n        if (Utils._.find(includes, predicate)) {\n          return;\n        }\n\n        // skip if recursing over a model already nested\n        if (nested && used.indexOf(model) !== -1) {\n          return;\n        }\n        used.push(parent);\n\n        // include this model\n        const thisInclude = Utils.cloneDeep(include);\n        thisInclude.model = model;\n        if (as) {\n          thisInclude.as = as;\n        }\n        includes.push(thisInclude);\n\n        // run recursively if nested\n        if (nested) {\n          addAllIncludes(model, thisInclude.include);\n          if (thisInclude.include.length === 0) delete thisInclude.include;\n        }\n      });\n      used.pop();\n    })(this, includes);\n  }\n\n  static _validateIncludedElements(options, tableNames) {\n    if (!options.model) options.model = this;\n\n    tableNames = tableNames || {};\n    options.includeNames = [];\n    options.includeMap = {};\n\n    /* Legacy */\n    options.hasSingleAssociation = false;\n    options.hasMultiAssociation = false;\n\n    if (!options.parent) {\n      options.topModel = options.model;\n      options.topLimit = options.limit;\n    }\n\n    options.include = options.include.map(include => {\n      include = this._conformInclude(include);\n      include.parent = options;\n\n      this._validateIncludedElement.call(options.model, include, tableNames, options);\n\n      if (include.duplicating === undefined) {\n        include.duplicating = include.association.isMultiAssociation;\n      }\n\n      include.hasDuplicating = include.hasDuplicating || include.duplicating;\n      include.hasRequired = include.hasRequired || include.required;\n\n      options.hasDuplicating = options.hasDuplicating || include.hasDuplicating;\n      options.hasRequired = options.hasRequired || include.required;\n\n      options.hasWhere = options.hasWhere || include.hasWhere || !!include.where;\n      return include;\n    });\n\n    for (const include of options.include) {\n      include.hasParentWhere = options.hasParentWhere || !!options.where;\n      include.hasParentRequired = options.hasParentRequired || !!options.required;\n\n      if (include.subQuery !== false && options.hasDuplicating && options.topLimit) {\n        if (include.duplicating) {\n          include.subQuery = false;\n          include.subQueryFilter = include.hasRequired;\n        } else {\n          include.subQuery = include.hasRequired;\n          include.subQueryFilter = false;\n        }\n      } else {\n        include.subQuery = include.subQuery || false;\n        if (include.duplicating) {\n          include.subQueryFilter = include.subQuery;\n          include.subQuery = false;\n        } else {\n          include.subQueryFilter = false;\n          include.subQuery = include.subQuery || include.hasParentRequired && include.hasRequired;\n        }\n      }\n\n      options.includeMap[include.as] = include;\n      options.includeNames.push(include.as);\n\n      // Set top level options\n      if (options.topModel === options.model && options.subQuery === undefined && options.topLimit) {\n        if (include.subQuery) {\n          options.subQuery = include.subQuery;\n        } else if (include.hasDuplicating) {\n          options.subQuery = true;\n        }\n      }\n\n      /* Legacy */\n      options.hasIncludeWhere = options.hasIncludeWhere || include.hasIncludeWhere || !!include.where;\n      options.hasIncludeRequired = options.hasIncludeRequired || include.hasIncludeRequired || !!include.required;\n\n      if (include.association.isMultiAssociation || include.hasMultiAssociation) {\n        options.hasMultiAssociation = true;\n      }\n      if (include.association.isSingleAssociation || include.hasSingleAssociation) {\n        options.hasSingleAssociation = true;\n      }\n    }\n\n    if (options.topModel === options.model && options.subQuery === undefined) {\n      options.subQuery = false;\n    }\n    return options;\n  }\n\n  static _validateIncludedElement(include, tableNames, options) {\n    tableNames[include.model.getTableName()] = true;\n\n    if (include.attributes && !options.raw) {\n      include.model._expandAttributes(include);\n\n      // Need to make sure virtuals are mapped before setting originalAttributes\n      include = Utils.mapFinderOptions(include, include.model);\n\n      include.originalAttributes = include.attributes.slice(0);\n\n      if (include.attributes.length) {\n        _.each(include.model.primaryKeys, (attr, key) => {\n          // Include the primary key if its not already take - take into account that the pk might be aliassed (due to a .field prop)\n          if (!_.some(include.attributes, includeAttr => {\n            if (attr.field !== key) {\n              return Array.isArray(includeAttr) && includeAttr[0] === attr.field && includeAttr[1] === key;\n            }\n            return includeAttr === key;\n          })) {\n            include.attributes.unshift(key);\n          }\n        });\n      }\n    } else {\n      include = Utils.mapFinderOptions(include, include.model);\n    }\n\n    // pseudo include just needed the attribute logic, return\n    if (include._pseudo) {\n      include.attributes = Object.keys(include.model.tableAttributes);\n      return Utils.mapFinderOptions(include, include.model);\n    }\n\n    // check if the current Model is actually associated with the passed Model - or it's a pseudo include\n    const association = include.association || this._getIncludedAssociation(include.model, include.as);\n\n    include.association = association;\n    include.as = association.as;\n\n    // If through, we create a pseudo child include, to ease our parsing later on\n    if (include.association.through && Object(include.association.through.model) === include.association.through.model) {\n      if (!include.include) include.include = [];\n      const through = include.association.through;\n\n      include.through = Utils._.defaults(include.through || {}, {\n        model: through.model,\n        as: through.model.name,\n        association: {\n          isSingleAssociation: true\n        },\n        _pseudo: true,\n        parent: include\n      });\n\n\n      if (through.scope) {\n        include.through.where = include.through.where ? { $and: [include.through.where, through.scope]} :  through.scope;\n      }\n\n      include.include.push(include.through);\n      tableNames[through.tableName] = true;\n    }\n\n    // include.model may be the main model, while the association target may be scoped - thus we need to look at association.target/source\n    let model;\n    if (include.model.scoped === true) {\n      // If the passed model is already scoped, keep that\n      model = include.model;\n    } else {\n      // Otherwise use the model that was originally passed to the association\n      model = include.association.target.name === include.model.name ? include.association.target : include.association.source;\n    }\n\n    model._injectScope(include);\n\n    // This check should happen after injecting the scope, since the scope may contain a .attributes\n    if (!include.attributes) {\n      include.attributes = Object.keys(include.model.tableAttributes);\n    }\n\n    include = Utils.mapFinderOptions(include, include.model);\n\n    if (include.required === undefined) {\n      include.required = !!include.where;\n    }\n\n    if (include.association.scope) {\n      include.where = include.where ? { $and: [include.where, include.association.scope] }:  include.association.scope;\n    }\n\n    if (include.limit && include.separate === undefined) {\n      include.separate = true;\n    }\n\n    if (include.separate === true && !(include.association instanceof HasMany)) {\n      throw new Error('Only HasMany associations support include.separate');\n    }\n\n    if (include.separate === true) {\n      include.duplicating = false;\n    }\n\n    if (include.separate === true && options.attributes && options.attributes.length && !_.includes(options.attributes, association.source.primaryKeyAttribute)) {\n      options.attributes.push(association.source.primaryKeyAttribute);\n    }\n\n    // Validate child includes\n    if (include.hasOwnProperty('include')) {\n      this._validateIncludedElements.call(include.model, include, tableNames, options);\n    }\n\n    return include;\n  }\n\n  static _getIncludedAssociation(targetModel, targetAlias) {\n    const associations = this.getAssociations(targetModel);\n    let association = null;\n    if (associations.length === 0) {\n      throw new sequelizeErrors.EagerLoadingError(`${targetModel.name} is not associated to ${this.name}!`);\n    } else if (associations.length === 1) {\n      association = this.getAssociationForAlias(targetModel, targetAlias);\n      if (!association) {\n        if (targetAlias) {\n          throw new sequelizeErrors.EagerLoadingError(`${targetModel.name} is associated to ${this.name} using an alias. ` +\n            `You've included an alias (${targetAlias}), but it does not match the alias defined in your association.`);\n        } else {\n          throw new sequelizeErrors.EagerLoadingError(`${targetModel.name} is associated to ${this.name} using an alias. ` +\n            'You must use the \\'as\\' keyword to specify the alias within your include statement.');\n        }\n      }\n    } else {\n      association = this.getAssociationForAlias(targetModel, targetAlias);\n      if (!association) {\n        throw new sequelizeErrors.EagerLoadingError(`${targetModel.name} is associated to ${this.name} multiple times. ` +\n          'To identify the correct association, you must use the \\'as\\' keyword to specify the alias of the association you want to include.');\n      }\n    }\n    return association;\n  }\n\n\n  static _expandIncludeAll(options) {\n    const includes = options.include;\n    if (!includes) {\n      return;\n    }\n\n    for (let index = 0; index < includes.length; index++) {\n      const include = includes[index];\n\n      if (include.all) {\n        includes.splice(index, 1);\n        index--;\n\n        this._expandIncludeAllElement.call(this, includes, include);\n      }\n    }\n\n    Utils._.forEach(includes, include => {\n      this._expandIncludeAll.call(include.model, include);\n    });\n  }\n\n  /**\n   * Initialize a model, representing a table in the DB, with attributes and options.\n   *\n   * The table columns are define by the hash that is given as the second argument. Each attribute of the hash represents a column. A short table definition might look like this:\n   *\n   * ```js\n   * Project.init({\n   *   columnA: {\n   *     type: Sequelize.BOOLEAN,\n   *     validate: {\n   *       is: ['[a-z]','i'],        // will only allow letters\n   *       max: 23,                  // only allow values <= 23\n   *       isIn: {\n   *         args: [['en', 'zh']],\n   *         msg: \"Must be English or Chinese\"\n   *       }\n   *     },\n   *     field: 'column_a'\n   *     // Other attributes here\n   *   },\n   *   columnB: Sequelize.STRING,\n   *   columnC: 'MY VERY OWN COLUMN TYPE'\n   * }, {sequelize})\n   *\n   * sequelize.models.modelName // The model will now be available in models under the class name\n   * ```\n   *\n   *\n   * As shown above, column definitions can be either strings, a reference to one of the datatypes that are predefined on the Sequelize constructor, or an object that allows you to specify both the type of the column, and other attributes such as default values, foreign key constraints and custom setters and getters.\n   *\n   * For a list of possible data types, see {@link DataTypes}\n   *\n   * For more about validation, see http://docs.sequelizejs.com/manual/tutorial/models-definition.html#validations\n   *\n   * @see {@link DataTypes}\n   * @see {@link Hooks}\n   *\n   * @param {Object}                  attributes An object, where each attribute is a column of the table. Each column can be either a DataType, a string or a type-description object, with the properties described below:\n   * @param {String|DataTypes|Object}  attributes.column The description of a database column\n   * @param {String|DataTypes}         attributes.column.type A string or a data type\n   * @param {Boolean}                 [attributes.column.allowNull=true] If false, the column will have a NOT NULL constraint, and a not null validation will be run before an instance is saved.\n   * @param {any}                     [attributes.column.defaultValue=null] A literal default value, a JavaScript function, or an SQL function (see `sequelize.fn`)\n   * @param {String|Boolean}          [attributes.column.unique=false] If true, the column will get a unique constraint. If a string is provided, the column will be part of a composite unique index. If multiple columns have the same string, they will be part of the same unique index\n   * @param {Boolean}                 [attributes.column.primaryKey=false]\n   * @param {String}                  [attributes.column.field=null] If set, sequelize will map the attribute name to a different name in the database\n   * @param {Boolean}                 [attributes.column.autoIncrement=false]\n   * @param {String}                  [attributes.column.comment=null]\n   * @param {String|Model}            [attributes.column.references=null] An object with reference configurations\n   * @param {String|Model}            [attributes.column.references.model] If this column references another table, provide it here as a Model, or a string\n   * @param {String}                  [attributes.column.references.key='id'] The column of the foreign table that this column references\n   * @param {String}                  [attributes.column.onUpdate] What should happen when the referenced key is updated. One of CASCADE, RESTRICT, SET DEFAULT, SET NULL or NO ACTION\n   * @param {String}                  [attributes.column.onDelete] What should happen when the referenced key is deleted. One of CASCADE, RESTRICT, SET DEFAULT, SET NULL or NO ACTION\n   * @param {Function}                [attributes.column.get] Provide a custom getter for this column. Use `this.getDataValue(String)` to manipulate the underlying values.\n   * @param {Function}                [attributes.column.set] Provide a custom setter for this column. Use `this.setDataValue(String, Value)` to manipulate the underlying values.\n   * @param {Object}                  [attributes.validate] An object of validations to execute for this column every time the model is saved. Can be either the name of a validation provided by validator.js, a validation function provided by extending validator.js (see the `DAOValidator` property for more details), or a custom validation function. Custom validation functions are called with the value of the field, and can possibly take a second callback argument, to signal that they are asynchronous. If the validator is sync, it should throw in the case of a failed validation, it it is async, the callback should be called with the error text.\n   * @param {Object}                  [options] These options are merged with the default define options provided to the Sequelize constructor\n   * @param {Object}                  [options.defaultScope={}] Define the default search scope to use for this model. Scopes have the same form as the options passed to find / findAll\n   * @param {Object}                  [options.scopes] More scopes, defined in the same way as defaultScope above. See `Model.scope` for more information about how scopes are defined, and what you can do with them\n   * @param {Boolean}                 [options.omitNull] Don't persist null values. This means that all columns with null values will not be saved\n   * @param {Boolean}                 [options.timestamps=true] Adds createdAt and updatedAt timestamps to the model.\n   * @param {Boolean}                 [options.paranoid=false] Calling `destroy` will not delete the model, but instead set a `deletedAt` timestamp if this is true. Needs `timestamps=true` to work\n   * @param {Boolean}                 [options.underscored=false] Converts all camelCased columns to underscored if true. Will not affect timestamp fields named explicitly by model options and will not affect fields with explicitly set `field` option\n   * @param {Boolean}                 [options.underscoredAll=false] Converts camelCased model names to underscored table names if true. Will not change model name if freezeTableName is set to true\n   * @param {Boolean}                 [options.freezeTableName=false] If freezeTableName is true, sequelize will not try to alter the model name to get the table name. Otherwise, the model name will be pluralized\n   * @param {Object}                  [options.name] An object with two attributes, `singular` and `plural`, which are used when this model is associated to others.\n   * @param {String}                  [options.name.singular=Utils.singularize(modelName)]\n   * @param {String}                  [options.name.plural=Utils.pluralize(modelName)]\n   * @param {Array<Object>}           [options.indexes]\n   * @param {String}                  [options.indexes[].name] The name of the index. Defaults to model name + _ + fields concatenated\n   * @param {String}                  [options.indexes[].type] Index type. Only used by mysql. One of `UNIQUE`, `FULLTEXT` and `SPATIAL`\n   * @param {String}                  [options.indexes[].method] The method to create the index by (`USING` statement in SQL). BTREE and HASH are supported by mysql and postgres, and postgres additionally supports GIST and GIN.\n   * @param {Boolean}                 [options.indexes[].unique=false] Should the index by unique? Can also be triggered by setting type to `UNIQUE`\n   * @param {Boolean}                 [options.indexes[].concurrently=false] PostgreSQL will build the index without taking any write locks. Postgres only\n   * @param {Array<String|Object>}    [options.indexes[].fields] An array of the fields to index. Each field can either be a string containing the name of the field, a sequelize object (e.g `sequelize.fn`), or an object with the following attributes: `attribute` (field name), `length` (create a prefix index of length chars), `order` (the direction the column should be sorted in), `collate` (the collation (sort order) for the column)\n   * @param {String|Boolean}          [options.createdAt] Override the name of the createdAt column if a string is provided, or disable it if false. Timestamps must be true. Not affected by underscored setting.\n   * @param {String|Boolean}          [options.updatedAt] Override the name of the updatedAt column if a string is provided, or disable it if false. Timestamps must be true. Not affected by underscored setting.\n   * @param {String|Boolean}          [options.deletedAt] Override the name of the deletedAt column if a string is provided, or disable it if false. Timestamps must be true. Not affected by underscored setting.\n   * @param {String}                  [options.tableName] Defaults to pluralized model name, unless freezeTableName is true, in which case it uses model name verbatim\n   * @param {String}                  [options.schema='public']\n   * @param {String}                  [options.engine]\n   * @param {String}                  [options.charset]\n   * @param {String}                  [options.comment]\n   * @param {String}                  [options.collate]\n   * @param {String}                  [options.initialAutoIncrement] Set the initial AUTO_INCREMENT value for the table in MySQL.\n   * @param {Object}                  [options.hooks] An object of hook function that are called before and after certain lifecycle events. The possible hooks are: beforeValidate, afterValidate, validationFailed, beforeBulkCreate, beforeBulkDestroy, beforeBulkUpdate, beforeCreate, beforeDestroy, beforeUpdate, afterCreate, afterDestroy, afterUpdate, afterBulkCreate, afterBulkDestory and afterBulkUpdate. See Hooks for more information about hook functions and their signatures. Each property can either be a function, or an array of functions.\n   * @param {Object}                  [options.validate] An object of model wide validations. Validations have access to all model values via `this`. If the validator function takes an argument, it is assumed to be async, and is called with a callback that accepts an optional error.\n\n   * @return {Model}\n   */\n  static init(attributes, options) { // testhint options:none\n    options = options || {};\n\n    if (!options.sequelize) {\n      throw new Error('No Sequelize instance passed');\n    }\n\n    this.sequelize = options.sequelize;\n\n    const globalOptions = this.sequelize.options;\n\n    options = Utils.merge(_.cloneDeep(globalOptions.define), options);\n\n    if (!options.modelName) {\n      options.modelName = this.name;\n    }\n\n    options = Utils.merge({\n      name: {\n        plural: Utils.pluralize(options.modelName),\n        singular: Utils.singularize(options.modelName)\n      },\n      indexes: [],\n      omitNull: globalOptions.omitNull,\n      schema: globalOptions.schema\n    }, options);\n\n    this.sequelize.runHooks('beforeDefine', attributes, options);\n\n    if (options.modelName !== this.name) {\n      Object.defineProperty(this, 'name', {value: options.modelName});\n    }\n    delete options.modelName;\n\n    this.options = Object.assign({\n      timestamps: true,\n      validate: {},\n      freezeTableName: false,\n      underscored: false,\n      underscoredAll: false,\n      paranoid: false,\n      rejectOnEmpty: false,\n      whereCollection: null,\n      schema: null,\n      schemaDelimiter: '',\n      defaultScope: {},\n      scopes: [],\n      hooks: {},\n      indexes: []\n    }, options);\n\n    // if you call \"define\" multiple times for the same modelName, do not clutter the factory\n    if (this.sequelize.isDefined(this.name)) {\n      this.sequelize.modelManager.removeModel(this.sequelize.modelManager.getModel(this.name));\n    }\n\n    this.associations = {};\n    this.options.hooks = _.mapValues(this.replaceHookAliases(this.options.hooks), hooks => {\n      if (!Array.isArray(hooks)) hooks = [hooks];\n      return hooks;\n    });\n\n    this.underscored = this.underscored || this.underscoredAll;\n\n    if (!this.options.tableName) {\n      this.tableName = this.options.freezeTableName ? this.name : Utils.underscoredIf(Utils.pluralize(this.name), this.options.underscoredAll);\n    } else {\n      this.tableName = this.options.tableName;\n    }\n\n    this._schema = this.options.schema;\n    this._schemaDelimiter = this.options.schemaDelimiter;\n\n    // error check options\n    _.each(options.validate, (validator, validatorType) => {\n      if (_.includes(Utils._.keys(attributes), validatorType)) {\n        throw new Error('A model validator function must not have the same name as a field. Model: ' + this.name + ', field/validation name: ' + validatorType);\n      }\n\n      if (!_.isFunction(validator)) {\n        throw new Error('Members of the validate option must be functions. Model: ' + this.name + ', error with validate member ' + validatorType);\n      }\n    });\n\n    this.rawAttributes = _.mapValues(attributes, (attribute, name) => {\n\n      attribute = this.sequelize.normalizeAttribute(attribute);\n\n      if (attribute.type === undefined) {\n        throw new Error('Unrecognized data type for field ' + name);\n      }\n\n      if (_.get(attribute, 'references.model.prototype') instanceof Model) {\n        attribute.references.model = attribute.references.model.tableName;\n      }\n\n      return attribute;\n    });\n\n    this.primaryKeys = {};\n\n    // Setup names of timestamp attributes\n    this._timestampAttributes = {};\n    if (this.options.timestamps) {\n      if (this.options.createdAt !== false) {\n        this._timestampAttributes.createdAt = this.options.createdAt || Utils.underscoredIf('createdAt', this.options.underscored);\n      }\n      if (this.options.updatedAt !== false) {\n        this._timestampAttributes.updatedAt = this.options.updatedAt || Utils.underscoredIf('updatedAt', this.options.underscored);\n      }\n      if (this.options.paranoid && this.options.deletedAt !== false) {\n        this._timestampAttributes.deletedAt = this.options.deletedAt || Utils.underscoredIf('deletedAt', this.options.underscored);\n      }\n    }\n    if (this.options.version) {\n      this._versionAttribute = typeof this.options.version === 'string' ? this.options.version : 'version';\n    }\n\n    // Add head and tail default attributes (id, timestamps)\n    this._readOnlyAttributes = Utils._.values(this._timestampAttributes);\n    if (this._versionAttribute) {\n      this._readOnlyAttributes.push(this._versionAttribute);\n    }\n    this._hasReadOnlyAttributes = this._readOnlyAttributes && this._readOnlyAttributes.length;\n    this._isReadOnlyAttribute = Utils._.memoize(key => this._hasReadOnlyAttributes && this._readOnlyAttributes.indexOf(key) !== -1);\n\n    this._addDefaultAttributes();\n    this.refreshAttributes();\n    this._findAutoIncrementAttribute();\n\n    this._scope = this.options.defaultScope;\n\n    if (_.isPlainObject(this._scope)) {\n      this._conformOptions(this._scope, this);\n    }\n\n    _.each(this.options.scopes, scope => {\n      if (_.isPlainObject(scope)) {\n        this._conformOptions(scope, this);\n      }\n    });\n\n    this.options.indexes = this.options.indexes.map(this._conformIndex);\n\n    this.sequelize.modelManager.addModel(this);\n    this.sequelize.runHooks('afterDefine', this);\n\n    return this;\n  }\n\n  static _conformIndex(index) {\n    index = _.defaults(index, {\n      type: '',\n      parser: null\n    });\n\n    if (index.type && index.type.toLowerCase() === 'unique') {\n      index.unique = true;\n      delete index.type;\n    }\n    return index;\n  }\n\n  static refreshAttributes() {\n    const attributeManipulation = {};\n\n    this.prototype._customGetters = {};\n    this.prototype._customSetters = {};\n\n    Utils._.each(['get', 'set'], type => {\n      const opt = type + 'terMethods';\n      const funcs = Utils._.clone(Utils._.isObject(this.options[opt]) ? this.options[opt] : {});\n      const _custom = type === 'get' ? this.prototype._customGetters : this.prototype._customSetters;\n\n      Utils._.each(funcs, (method, attribute) => {\n        _custom[attribute] = method;\n\n        if (type === 'get') {\n          funcs[attribute] = function() {\n            return this.get(attribute);\n          };\n        }\n        if (type === 'set') {\n          funcs[attribute] = function(value) {\n            return this.set(attribute, value);\n          };\n        }\n      });\n\n      Utils._.each(this.rawAttributes, (options, attribute) => {\n        if (options.hasOwnProperty(type)) {\n          _custom[attribute] = options[type];\n        }\n\n        if (type === 'get') {\n          funcs[attribute] = function() {\n            return this.get(attribute);\n          };\n        }\n        if (type === 'set') {\n          funcs[attribute] = function(value) {\n            return this.set(attribute, value);\n          };\n        }\n      });\n\n      Utils._.each(funcs, (fct, name) => {\n        if (!attributeManipulation[name]) {\n          attributeManipulation[name] = {\n            configurable: true\n          };\n        }\n        attributeManipulation[name][type] = fct;\n      });\n    });\n\n    this._booleanAttributes = [];\n    this._dateAttributes = [];\n    this._hstoreAttributes = [];\n    this._rangeAttributes = [];\n    this._jsonAttributes = [];\n    this._geometryAttributes = [];\n    this._virtualAttributes = [];\n    this._defaultValues = {};\n    this.prototype.validators = {};\n\n    this.fieldRawAttributesMap = {};\n\n    this.primaryKeys = {};\n    this.options.uniqueKeys = {};\n\n    _.each(this.rawAttributes, (definition, name) => {\n      definition.type = this.sequelize.normalizeDataType(definition.type);\n\n      definition.Model = this;\n      definition.fieldName = name;\n      definition._modelAttribute = true;\n\n      if (definition.field === undefined) {\n        definition.field = name;\n      }\n\n      if (definition.primaryKey === true) {\n        this.primaryKeys[name] = definition;\n      }\n\n      this.fieldRawAttributesMap[definition.field] = definition;\n\n      if (definition.type instanceof DataTypes.BOOLEAN) {\n        this._booleanAttributes.push(name);\n      } else if (definition.type instanceof DataTypes.DATE || definition.type instanceof DataTypes.DATEONLY) {\n        this._dateAttributes.push(name);\n      } else if (definition.type instanceof DataTypes.HSTORE || DataTypes.ARRAY.is(definition.type, DataTypes.HSTORE)) {\n        this._hstoreAttributes.push(name);\n      } else if (definition.type instanceof DataTypes.RANGE || DataTypes.ARRAY.is(definition.type, DataTypes.RANGE)) {\n        this._rangeAttributes.push(name);\n      } else if (definition.type instanceof DataTypes.JSON) {\n        this._jsonAttributes.push(name);\n      } else if (definition.type instanceof DataTypes.VIRTUAL) {\n        this._virtualAttributes.push(name);\n      } else if (definition.type instanceof DataTypes.GEOMETRY) {\n        this._geometryAttributes.push(name);\n      }\n\n      if (definition.hasOwnProperty('defaultValue')) {\n        this._defaultValues[name] = Utils._.partial(Utils.toDefaultValue, definition.defaultValue);\n      }\n\n      if (definition.hasOwnProperty('unique') && definition.unique !== false) {\n        let idxName;\n        if (typeof definition.unique === 'object' && definition.unique.hasOwnProperty('name')) {\n          idxName = definition.unique.name;\n        } else if (typeof definition.unique === 'string') {\n          idxName = definition.unique;\n        } else {\n          idxName = this.tableName + '_' + name + '_unique';\n        }\n\n        let idx = this.options.uniqueKeys[idxName] || { fields: [] };\n        idx = idx || {fields: [], msg: null};\n        idx.fields.push(definition.field);\n        idx.msg = idx.msg || definition.unique.msg || null;\n        idx.name = idxName || false;\n        idx.column = name;\n\n        this.options.uniqueKeys[idxName] = idx;\n      }\n\n      if (definition.hasOwnProperty('validate')) {\n        this.prototype.validators[name] = definition.validate;\n      }\n\n      if (definition.index === true && definition.type instanceof DataTypes.JSONB) {\n        this.options.indexes.push({\n          fields: [definition.field || name],\n          using: 'gin'\n        });\n\n        delete definition.index;\n      }\n    });\n    // Create a map of field to attribute names\n    this.fieldAttributeMap = Utils._.reduce(this.fieldRawAttributesMap, (map, value, key) => {\n      if (key !== value.fieldName) {\n        map[key] = value.fieldName;\n      }\n      return map;\n    }, {});\n\n    this.uniqueKeys = this.options.uniqueKeys;\n\n    this._hasBooleanAttributes = !!this._booleanAttributes.length;\n    this._isBooleanAttribute = Utils._.memoize(key => this._booleanAttributes.indexOf(key) !== -1);\n\n    this._hasDateAttributes = !!this._dateAttributes.length;\n    this._isDateAttribute = Utils._.memoize(key => this._dateAttributes.indexOf(key) !== -1);\n\n    this._hasHstoreAttributes = !!this._hstoreAttributes.length;\n    this._isHstoreAttribute = Utils._.memoize(key => this._hstoreAttributes.indexOf(key) !== -1);\n\n    this._hasRangeAttributes = !!this._rangeAttributes.length;\n    this._isRangeAttribute = Utils._.memoize(key => this._rangeAttributes.indexOf(key) !== -1);\n\n    this._hasJsonAttributes = !!this._jsonAttributes.length;\n    this._isJsonAttribute = Utils._.memoize(key => this._jsonAttributes.indexOf(key) !== -1);\n\n    this._hasVirtualAttributes = !!this._virtualAttributes.length;\n    this._isVirtualAttribute = Utils._.memoize(key => this._virtualAttributes.indexOf(key) !== -1);\n\n    this._hasGeometryAttributes = !!this._geometryAttributes.length;\n    this._isGeometryAttribute = Utils._.memoize(key => this._geometryAttributes.indexOf(key) !== -1);\n\n    this._hasDefaultValues = !Utils._.isEmpty(this._defaultValues);\n\n    // DEPRECATE: All code base is free from this.attributes now\n    //            This should be removed in v5\n    this.attributes = this.rawAttributes;\n\n    this.tableAttributes = Utils._.omit(this.rawAttributes, this._virtualAttributes);\n\n    this.prototype._hasCustomGetters = Object.keys(this.prototype._customGetters).length;\n    this.prototype._hasCustomSetters = Object.keys(this.prototype._customSetters).length;\n\n    for (const key of Object.keys(attributeManipulation)) {\n      if (Model.prototype.hasOwnProperty(key)) {\n        this.sequelize.log('Not overriding built-in method from model attribute: ' + key);\n        continue;\n      }\n      Object.defineProperty(this.prototype, key, attributeManipulation[key]);\n    }\n\n\n    this.prototype.rawAttributes = this.rawAttributes;\n    this.prototype.attributes = Object.keys(this.prototype.rawAttributes);\n    this.prototype._isAttribute = Utils._.memoize(key => this.prototype.attributes.indexOf(key) !== -1);\n\n    // Primary key convenience constiables\n    this.primaryKeyAttributes = Object.keys(this.primaryKeys);\n    this.primaryKeyAttribute = this.primaryKeyAttributes[0];\n    if (this.primaryKeyAttribute) {\n      this.primaryKeyField = this.rawAttributes[this.primaryKeyAttribute].field || this.primaryKeyAttribute;\n    }\n\n    this._hasPrimaryKeys = this.primaryKeyAttributes.length > 0;\n    this._isPrimaryKey = Utils._.memoize(key => this.primaryKeyAttributes.indexOf(key) !== -1);\n  }\n\n  /**\n   * Remove attribute from model definition\n   * @param {String} [attribute]\n   */\n  static removeAttribute(attribute) {\n    delete this.rawAttributes[attribute];\n    this.refreshAttributes();\n  }\n\n  /**\n   * Sync this Model to the DB, that is create the table. Upon success, the callback will be called with the model instance (this)\n   * @see {@link Sequelize#sync} for options\n   * @return {Promise<this>}\n   */\n  static sync(options) {\n    options = _.extend({}, this.options, options);\n    options.hooks = options.hooks === undefined ? true : !!options.hooks;\n\n    const attributes = this.tableAttributes;\n\n    return Promise.try(() => {\n      if (options.hooks) {\n        return this.runHooks('beforeSync', options);\n      }\n    }).then(() => {\n      if (options.force) {\n        return this.drop(options);\n      }\n    })\n      .then(() => this.QueryInterface.createTable(this.getTableName(options), attributes, options, this))\n      .then(() => {\n        if (options.alter) {\n          return this.QueryInterface.describeTable(this.getTableName(options))\n            .then(columns => {\n              const changes = []; // array of promises to run\n              _.each(attributes, (columnDesc, columnName) => {\n                if (!columns[columnName]) {\n                  changes.push(() => this.QueryInterface.addColumn(this.getTableName(options), columnName, attributes[columnName]));\n                }\n              });\n              _.each(columns, (columnDesc, columnName) => {\n                if (!attributes[columnName]) {\n                  changes.push(() => this.QueryInterface.removeColumn(this.getTableName(options), columnName, options));\n                } else if (!attributes[columnName].primaryKey) {\n                  changes.push(() => this.QueryInterface.changeColumn(this.getTableName(options), columnName, attributes[columnName]));\n                }\n              });\n              return changes.reduce((p, fn) => p.then(fn), Promise.resolve());\n            });\n        }\n      })\n      .then(() => this.QueryInterface.showIndex(this.getTableName(options), options))\n      .then(indexes => {\n      // Assign an auto-generated name to indexes which are not named by the user\n        this.options.indexes = this.QueryInterface.nameIndexes(this.options.indexes, this.tableName);\n\n        indexes = _.filter(this.options.indexes, item1 =>\n          !_.some(indexes, item2 => item1.name === item2.name)\n        ).sort((index1, index2) => {\n          if (this.sequelize.options.dialect === 'postgres') {\n          // move concurrent indexes to the bottom to avoid weird deadlocks\n            if (index1.concurrently === true) return 1;\n            if (index2.concurrently === true) return -1;\n          }\n\n          return 0;\n        });\n\n        return Promise.map(indexes, index => this.QueryInterface.addIndex(\n          this.getTableName(options),\n          _.assign({\n            logging: options.logging,\n            benchmark: options.benchmark,\n            transaction: options.transaction\n          }, index),\n          this.tableName\n        ));\n      }).then(() => {\n        if (options.hooks) {\n          return this.runHooks('afterSync', options);\n        }\n      }).return(this);\n  }\n\n  /**\n   * Drop the table represented by this Model\n   * @param {Object}   [options]\n   * @param {Boolean}  [options.cascade=false]   Also drop all objects depending on this table, such as views. Only works in postgres\n   * @param {Function} [options.logging=false]   A function that gets executed while running the query to log the sql.\n   * @param {Boolean}  [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).\n   * @return {Promise}\n   */\n  static drop(options) {\n    return this.QueryInterface.dropTable(this.getTableName(options), options);\n  }\n\n  static dropSchema(schema) {\n    return this.QueryInterface.dropSchema(schema);\n  }\n\n  /**\n   * Apply a schema to this model. For postgres, this will actually place the schema in front of the table name - `\"schema\".\"tableName\"`,\n   * while the schema will be prepended to the table name for mysql and sqlite - `'schema.tablename'`.\n   *\n   * This method is intended for use cases where the same model is needed in multiple schemas. In such a use case it is important\n   * to call `model.schema(schema, [options]).sync()` for each model to ensure the models are created in the correct schema.\n   *\n   * If a single default schema per model is needed, set the `options.schema='schema'` parameter during the `define()` call\n   * for the model.\n   *\n   * @param {String} schema The name of the schema\n   * @param {Object} [options]\n   * @param {String} [options.schemaDelimiter='.'] The character(s) that separates the schema name from the table name\n   * @param {Function} [options.logging=false] A function that gets executed while running the query to log the sql.\n   * @param {Boolean}  [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).\n   *\n   * @see {@link Sequelize#define} for more information about setting a default schema.\n   *\n   * @return {this}\n   */\n  static schema(schema, options) { // testhint options:none\n\n    const clone = class extends this {};\n    Object.defineProperty(clone, 'name', {value: this.name});\n\n    clone._schema = schema;\n\n    if (options) {\n      if (typeof options === 'string') {\n        clone._schemaDelimiter = options;\n      } else {\n        if (options.schemaDelimiter) {\n          clone._schemaDelimiter = options.schemaDelimiter;\n        }\n      }\n    }\n\n    return clone;\n  }\n\n  /**\n   * Get the tablename of the model, taking schema into account. The method will return The name as a string if the model has no schema,\n   * or an object with `tableName`, `schema` and `delimiter` properties.\n   *\n   * @return {String|Object}\n   */\n  static getTableName() { // testhint options:none\n    return this.QueryGenerator.addSchema(this);\n  }\n\n  /**\n   * @return {Model}\n   */\n  static unscoped() {\n    return this.scope();\n  }\n\n  /**\n   * Add a new scope to the model. This is especially useful for adding scopes with includes, when the model you want to include is not available at the time this model is defined.\n   *\n   * By default this will throw an error if a scope with that name already exists. Pass `override: true` in the options object to silence this error.\n   *\n   * @param {String}          name The name of the scope. Use `defaultScope` to override the default scope\n   * @param {Object|Function} scope\n   * @param {Object}          [options]\n   * @param {Boolean}         [options.override=false]\n   */\n  static addScope(name, scope, options) {\n    options = _.assign({\n      override: false\n    }, options);\n\n    if ((name === 'defaultScope' || name in this.options.scopes) && options.override === false) {\n      throw new Error('The scope ' + name + ' already exists. Pass { override: true } as options to silence this error');\n    }\n\n    this._conformOptions(scope, this);\n\n    if (name === 'defaultScope') {\n      this.options.defaultScope = this._scope = scope;\n    } else {\n      this.options.scopes[name] = scope;\n    }\n  }\n\n  /**\n   * Apply a scope created in `define` to the model. First let's look at how to create scopes:\n   * ```js\n   * const Model = sequelize.define('model', attributes, {\n   *   defaultScope: {\n   *     where: {\n   *       username: 'dan'\n   *     },\n   *     limit: 12\n   *   },\n   *   scopes: {\n   *     isALie: {\n   *       where: {\n   *         stuff: 'cake'\n   *       }\n   *     },\n   *     complexFunction: function(email, accessLevel) {\n   *       return {\n   *         where: {\n   *           email: {\n   *             $like: email\n   *           },\n   *           accesss_level {\n   *             $gte: accessLevel\n   *           }\n   *         }\n   *       }\n   *     }\n   *   }\n   * })\n   * ```\n   * Now, since you defined a default scope, every time you do Model.find, the default scope is appended to your query. Here's a couple of examples:\n   * ```js\n   * Model.findAll() // WHERE username = 'dan'\n   * Model.findAll({ where: { age: { gt: 12 } } }) // WHERE age > 12 AND username = 'dan'\n   * ```\n   *\n   * To invoke scope functions you can do:\n   * ```js\n   * Model.scope({ method: ['complexFunction' 'dan@sequelize.com', 42]}).findAll()\n   * // WHERE email like 'dan@sequelize.com%' AND access_level >= 42\n   * ```\n   *\n   * @param {Array|Object|String|null}    options The scope(s) to apply. Scopes can either be passed as consecutive arguments, or as an array of arguments. To apply simple scopes and scope functions with no arguments, pass them as strings. For scope function, pass an object, with a `method` property. The value can either be a string, if the method does not take any arguments, or an array, where the first element is the name of the method, and consecutive elements are arguments to that method. Pass null to remove all scopes, including the default.\n   * @return {Model}                      A reference to the model, with the scope(s) applied. Calling scope again on the returned model will clear the previous scope.\n   */\n  static scope(option) {\n    const self = class extends this {};\n    let scope;\n    let scopeName;\n    Object.defineProperty(self, 'name', {value: this.name});\n\n    self._scope = {};\n    self.scoped = true;\n\n    if (!option) {\n      return self;\n    }\n\n    const options = _.flatten(arguments);\n    for (const option of options) {\n      scope = null;\n      scopeName = null;\n\n      if (_.isPlainObject(option)) {\n        if (option.method) {\n          if (Array.isArray(option.method) && !!self.options.scopes[option.method[0]]) {\n            scopeName = option.method[0];\n            scope = self.options.scopes[scopeName].apply(self, option.method.slice(1));\n          }\n          else if (self.options.scopes[option.method]) {\n            scopeName = option.method;\n            scope = self.options.scopes[scopeName].apply(self);\n          }\n        } else {\n          scope = option;\n        }\n      } else {\n        if (option === 'defaultScope' && _.isPlainObject(self.options.defaultScope)) {\n          scope = self.options.defaultScope;\n        } else {\n          scopeName = option;\n          scope = self.options.scopes[scopeName];\n\n          if (_.isFunction(scope)) {\n            scope = scope();\n            this._conformOptions(scope, self);\n          }\n        }\n      }\n\n      if (scope) {\n        _.assignWith(self._scope, scope, (objectValue, sourceValue, key) => {\n          if (key === 'where') {\n            return Array.isArray(sourceValue) ? sourceValue : _.assign(objectValue || {}, sourceValue);\n          } else if (['attributes', 'include', 'group'].indexOf(key) >= 0 && Array.isArray(objectValue) && Array.isArray(sourceValue)) {\n            return objectValue.concat(sourceValue);\n          }\n\n          return objectValue ? objectValue : sourceValue;\n        });\n      } else {\n        throw new sequelizeErrors.SequelizeScopeError('Invalid scope ' + scopeName + ' called.');\n      }\n    }\n\n    return self;\n  }\n\n  static all(options) {\n    return this.findAll(options);\n  }\n\n  /**\n   * Search for multiple instances.\n   *\n   * __Simple search using AND and =__\n   * ```js\n   * Model.findAll({\n   *   where: {\n   *     attr1: 42,\n   *     attr2: 'cake'\n   *   }\n   * })\n   * ```\n   * ```sql\n   * WHERE attr1 = 42 AND attr2 = 'cake'\n   *```\n   *\n   * __Using greater than, less than etc.__\n   * ```js\n   *\n   * Model.findAll({\n   *   where: {\n   *     attr1: {\n   *       gt: 50\n   *     },\n   *     attr2: {\n   *       lte: 45\n   *     },\n   *     attr3: {\n   *       in: [1,2,3]\n   *     },\n   *     attr4: {\n   *       ne: 5\n   *     }\n   *   }\n   * })\n   * ```\n   * ```sql\n   * WHERE attr1 > 50 AND attr2 <= 45 AND attr3 IN (1,2,3) AND attr4 != 5\n   * ```\n   * Possible options are: `$ne, $in, $not, $notIn, $gte, $gt, $lte, $lt, $like, $ilike/$iLike, $notLike, $notILike, $regexp, $notRegexp, '..'/$between, '!..'/$notBetween, '&&'/$overlap, '@>'/$contains, '<@'/$contained`\n   *\n   * __Queries using OR__\n   * ```js\n   * Model.findAll({\n   *   where: {\n   *     name: 'a project',\n   *     $or: [\n   *       {id: [1, 2, 3]},\n   *       {\n   *         $and: [\n   *           {id: {gt: 10}},\n   *           {id: {lt: 100}}\n   *         ]\n   *       }\n   *     ]\n   *   }\n   * });\n   * ```\n   * ```sql\n   * WHERE `Model`.`name` = 'a project' AND (`Model`.`id` IN (1, 2, 3) OR (`Model`.`id` > 10 AND `Model`.`id` < 100));\n   * ```\n   *\n   * The promise is resolved with an array of Model instances if the query succeeds.\n   *\n   * __Alias__: _all_\n   *\n   * @param  {Object}                                                    [options] A hash of options to describe the scope of the search\n   * @param  {Object}                                                    [options.where] A hash of attributes to describe your search. See above for examples.\n   * @param  {Array<String>|Object}                                      [options.attributes] A list of the attributes that you want to select, or an object with `include` and `exclude` keys. To rename an attribute, you can pass an array, with two elements - the first is the name of the attribute in the DB (or some kind of expression such as `Sequelize.literal`, `Sequelize.fn` and so on), and the second is the name you want the attribute to have in the returned instance\n   * @param  {Array<String>}                                             [options.attributes.include] Select all the attributes of the model, plus some additional ones. Useful for aggregations, e.g. `{ attributes: { include: [[sequelize.fn('COUNT', sequelize.col('id')), 'total']] }`\n   * @param  {Array<String>}                                             [options.attributes.exclude] Select all the attributes of the model, except some few. Useful for security purposes e.g. `{ attributes: { exclude: ['password'] } }`\n   * @param  {Boolean}                                                   [options.paranoid=true] If true, only non-deleted records will be returned. If false, both deleted and non-deleted records will be returned. Only applies if `options.paranoid` is true for the model.\n   * @param  {Array<Object|Model|String>}                                [options.include] A list of associations to eagerly load using a left join. Supported is either `{ include: [ Model1, Model2, ...]}` or `{ include: [{ model: Model1, as: 'Alias' }]}` or `{ include: ['Alias']}`. If your association are set up with an `as` (eg. `X.hasMany(Y, { as: 'Z }`, you need to specify Z in the as attribute when eager loading Y).\n   * @param  {Model}                                                     [options.include[].model] The model you want to eagerly load\n   * @param  {String}                                                    [options.include[].as] The alias of the relation, in case the model you want to eagerly load is aliased. For `hasOne` / `belongsTo`, this should be the singular name, and for `hasMany`, it should be the plural\n   * @param  {Association}                                               [options.include[].association] The association you want to eagerly load. (This can be used instead of providing a model/as pair)\n   * @param  {Object}                                                    [options.include[].where] Where clauses to apply to the child models. Note that this converts the eager load to an inner join, unless you explicitly set `required: false`\n   * @param  {Boolean}                                                   [options.include[].or=false] Whether to bind the ON and WHERE clause together by OR instead of AND.\n   * @param  {Object}                                                    [options.include[].on] Supply your own ON condition for the join.\n   * @param  {Array<String>}                                             [options.include[].attributes] A list of attributes to select from the child model\n   * @param  {Boolean}                                                   [options.include[].required] If true, converts to an inner join, which means that the parent model will only be loaded if it has any matching children. True if `include.where` is set, false otherwise.\n   * @param  {Boolean}                                                   [options.include[].separate] If true, runs a separate query to fetch the associated instances, only supported for hasMany associations\n   * @param  {Number}                                                    [options.include[].limit] Limit the joined rows, only supported with include.separate=true\n   * @param  {Object}                                                    [options.include[].through.where] Filter on the join model for belongsToMany relations\n   * @param  {Array}                                                     [options.include[].through.attributes] A list of attributes to select from the join model for belongsToMany relations\n   * @param  {Array<Object|Model|String>}                                [options.include[].include] Load further nested related models\n   * @param  {Array|Sequelize.fn|Sequelize.col|Sequelize.literal}        [options.order] Specifies an ordering. Using an array, you can provide several columns / functions to order by. Each element can be further wrapped in a two-element array. The first element is the column / function to order by, the second is the direction. For example: `order: [['name', 'DESC']]`. In this way the column will be escaped, but the direction will not.\n   * @param  {Number}                                                    [options.limit]\n   * @param  {Number}                                                    [options.offset]\n   * @param  {Transaction}                                               [options.transaction] Transaction to run query under\n   * @param  {String|Object}                                             [options.lock] Lock the selected rows. Possible options are transaction.LOCK.UPDATE and transaction.LOCK.SHARE. Postgres also supports transaction.LOCK.KEY_SHARE, transaction.LOCK.NO_KEY_UPDATE and specific model locks with joins. See [transaction.LOCK for an example](transaction#lock)\n   * @param  {Boolean}                                                   [options.raw] Return raw result. See sequelize.query for more information.\n   * @param  {Function}                                                  [options.logging=false] A function that gets executed while running the query to log the sql.\n   * @param  {Boolean}                                                   [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).\n   * @param  {Object}                                                    [options.having]\n   * @param  {String}                                                    [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)\n   * @param  {Boolean|Error}                                             [options.rejectOnEmpty=false] Throws an error when no records found\n   *\n   * @link   {@link Sequelize.query}\n   * @return {Promise<Array<Model>>}\n   */\n  static findAll(options) {\n    if (options !== undefined && !_.isPlainObject(options)) {\n      throw new sequelizeErrors.QueryError('The argument passed to findAll must be an options object, use findById if you wish to pass a single primary key value');\n    }\n\n    if (options !== undefined && options.attributes) {\n      if (!Array.isArray(options.attributes) && !_.isPlainObject(options.attributes)) {\n        throw new sequelizeErrors.QueryError('The attributes option must be an array of column names or an object');\n      }\n    }\n\n    this.warnOnInvalidOptions(options, Object.keys(this.rawAttributes));\n\n    const tableNames = {};\n    let originalOptions;\n\n    tableNames[this.getTableName(options)] = true;\n    options = Utils.cloneDeep(options);\n\n    _.defaults(options, { hooks: true, rejectOnEmpty: this.options.rejectOnEmpty });\n\n    // set rejectOnEmpty option from model config\n    options.rejectOnEmpty = options.rejectOnEmpty || this.options.rejectOnEmpty;\n\n    return Promise.try(() => {\n      this._injectScope(options);\n\n      if (options.hooks) {\n        return this.runHooks('beforeFind', options);\n      }\n    }).then(() => {\n      this._conformOptions(options, this);\n      this._expandIncludeAll(options);\n\n      if (options.hooks) {\n        return this.runHooks('beforeFindAfterExpandIncludeAll', options);\n      }\n    }).then(() => {\n      if (options.include) {\n        options.hasJoin = true;\n\n        this._validateIncludedElements(options, tableNames);\n\n        // If we're not raw, we have to make sure we include the primary key for deduplication\n        if (options.attributes && !options.raw && this.primaryKeyAttribute &&  options.attributes.indexOf(this.primaryKeyAttribute) === -1) {\n          options.originalAttributes = options.attributes;\n          options.attributes = [this.primaryKeyAttribute].concat(options.attributes);\n        }\n      }\n\n      if (!options.attributes) {\n        options.attributes = Object.keys(this.tableAttributes);\n      }\n\n      // whereCollection is used for non-primary key updates\n      this.options.whereCollection = options.where || null;\n\n      Utils.mapFinderOptions(options, this);\n\n      options = this._paranoidClause(this, options);\n\n      if (options.hooks) {\n        return this.runHooks('beforeFindAfterOptions', options);\n      }\n    }).then(() => {\n      originalOptions = Utils.cloneDeep(options);\n      options.tableNames = Object.keys(tableNames);\n      return this.QueryInterface.select(this, this.getTableName(options), options);\n    }).tap(results => {\n      if (options.hooks) {\n        return this.runHooks('afterFind', results, options);\n      }\n    }).then(results => {\n\n      //rejectOnEmpty mode\n      if (_.isEmpty(results) && options.rejectOnEmpty) {\n        if (typeof options.rejectOnEmpty === 'function') {\n          throw new options.rejectOnEmpty();\n        } else if (typeof options.rejectOnEmpty === 'object') {\n          throw options.rejectOnEmpty;\n        } else {\n          throw new sequelizeErrors.EmptyResultError();\n        }\n      }\n\n      return Model._findSeparate(results, originalOptions);\n    });\n  }\n\n  static warnOnInvalidOptions(options, validColumnNames) {\n    if (!_.isPlainObject(options)) {\n      return;\n    }\n\n    // This list will quickly become dated, but failing to maintain this list just means\n    // we won't throw a warning when we should. At least most common cases will forever be covered\n    // so we stop throwing erroneous warnings when we shouldn't.\n    const validQueryKeywords = ['where', 'attributes', 'paranoid', 'include', 'order', 'limit', 'offset',\n      'transaction', 'lock', 'raw', 'logging', 'benchmark', 'having', 'searchPath', 'rejectOnEmpty', 'plain',\n      'scope', 'group', 'through', 'defaults', 'distinct', 'primary', 'exception', 'type', 'hooks', 'force',\n      'name'];\n\n    const unrecognizedOptions = _.difference(Object.keys(options), validQueryKeywords);\n    const unexpectedModelAttributes = _.intersection(unrecognizedOptions, validColumnNames);\n    if (!options.where && unexpectedModelAttributes.length > 0) {\n      Utils.warn(`Model attributes (${unexpectedModelAttributes.join(', ')}) passed into finder method options of model ${this.name}, but the options.where object is empty. Did you forget to use options.where?`);\n    }\n  }\n\n  static _findSeparate(results, options) {\n    if (!options.include || options.raw || !results) return Promise.resolve(results);\n\n    const original = results;\n    if (options.plain) results = [results];\n\n    if (!results.length) return original;\n\n    return Promise.map(options.include, include => {\n      if (!include.separate) {\n        return Model._findSeparate(\n          results.reduce((memo, result) => {\n            let associations = result.get(include.association.as);\n\n            // Might be an empty belongsTo relation\n            if (!associations) return memo;\n\n            // Force array so we can concat no matter if it's 1:1 or :M\n            if (!Array.isArray(associations)) associations = [associations];\n\n            for (let i = 0, len = associations.length; i !== len; ++i) {\n              memo.push(associations[i]);\n            }\n            return memo;\n          }, []),\n          _.assign(\n            {},\n            _.omit(options, 'include', 'attributes', 'order', 'where', 'limit', 'plain', 'scope'),\n            {include: include.include || []}\n          )\n        );\n      }\n\n      return include.association.get(results, _.assign(\n        {},\n        _.omit(options, 'include', 'attributes', 'order', 'where', 'limit', 'plain'),\n        _.omit(include, 'parent', 'association', 'as')\n      )).then(map => {\n        for (const result of results) {\n          result.set(\n            include.association.as,\n            map[result.get(include.association.source.primaryKeyAttribute)],\n            {\n              raw: true\n            }\n          );\n        }\n      });\n    }).return(original);\n  }\n\n  /**\n   * Search for a single instance by its primary key.\n   *\n   * __Alias__: _findByPrimary_\n   *\n   * @param  {Number|String|Buffer}      id The value of the desired instance's primary key.\n   * @param  {Object}                    [options]\n   * @param  {Transaction}               [options.transaction] Transaction to run query under\n   * @param  {String}                    [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)\n   *\n   * @see {@link Model.findAll}           for a full explanation of options\n   * @return {Promise<Model>}\n   */\n  static findById(param, options) {\n    // return Promise resolved with null if no arguments are passed\n    if ([null, undefined].indexOf(param) !== -1) {\n      return Promise.resolve(null);\n    }\n\n    options = Utils.cloneDeep(options) || {};\n\n    if (typeof param === 'number' || typeof param === 'string' || Buffer.isBuffer(param)) {\n      options.where = {};\n      options.where[this.primaryKeyAttribute] = param;\n    } else {\n      throw new Error('Argument passed to findById is invalid: '+param);\n    }\n\n    // Bypass a possible overloaded findOne\n    return this.findOne(options);\n  }\n\n  /**\n   * Search for a single instance. This applies LIMIT 1, so the listener will always be called with a single instance.\n   *\n   * __Alias__: _find_\n   *\n   * @param  {Object}                    [options] A hash of options to describe the scope of the search\n   * @param  {Transaction}               [options.transaction] Transaction to run query under\n   * @param  {String}                    [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)\n   *\n   * @see {@link Model.findAll}           for an explanation of options\n   * @return {Promise<Model>}\n   */\n  static findOne(options) {\n    if (options !== undefined && !_.isPlainObject(options)) {\n      throw new Error('The argument passed to findOne must be an options object, use findById if you wish to pass a single primary key value');\n    }\n    options = Utils.cloneDeep(options);\n\n    if (options.limit === undefined) {\n      const pkVal = options.where && options.where[this.primaryKeyAttribute];\n\n      // Don't add limit if querying directly on the pk\n      if (!options.where || !(Utils.isPrimitive(pkVal) || Buffer.isBuffer(pkVal))) {\n        options.limit = 1;\n      }\n    }\n\n    // Bypass a possible overloaded findAll.\n    return this.findAll(_.defaults(options, {\n      plain: true,\n      rejectOnEmpty: false\n    }));\n  }\n\n  /**\n   * Run an aggregation method on the specified field\n   *\n   * @param {String}          field The field to aggregate over. Can be a field name or *\n   * @param {String}          aggregateFunction The function to use for aggregation, e.g. sum, max etc.\n   * @param {Object}          [options] Query options. See sequelize.query for full options\n   * @param {Object}          [options.where] A hash of search attributes.\n   * @param {Function}        [options.logging=false] A function that gets executed while running the query to log the sql.\n   * @param {Boolean}         [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).\n   * @param {DataTypes|String} [options.dataType] The type of the result. If `field` is a field in this Model, the default will be the type of that field, otherwise defaults to float.\n   * @param {boolean}         [options.distinct] Applies DISTINCT to the field being aggregated over\n   * @param {Transaction}     [options.transaction] Transaction to run query under\n   * @param {Boolean}         [options.plain] When `true`, the first returned value of `aggregateFunction` is cast to `dataType` and returned. If additional attributes are specified, along with `group` clauses, set `plain` to `false` to return all values of all returned rows.  Defaults to `true`\n   *\n   * @return {Promise<DataTypes|object>}                Returns the aggregate result cast to `options.dataType`, unless `options.plain` is false, in which case the complete data result is returned.\n   */\n  static aggregate(attribute, aggregateFunction, options) {\n    options = Utils.cloneDeep(options);\n    options = _.defaults(options, { attributes: [] });\n    this._conformOptions(options, this);\n    this._injectScope(options);\n\n    if (options.include) {\n      this._expandIncludeAll(options);\n      this._validateIncludedElements(options);\n    }\n\n    const attrOptions = this.rawAttributes[attribute];\n    const field = attrOptions && attrOptions.field || attribute;\n    let aggregateColumn = this.sequelize.col(field);\n\n    if (options.distinct) {\n      aggregateColumn = this.sequelize.fn('DISTINCT', aggregateColumn);\n    }\n    options.attributes.push([this.sequelize.fn(aggregateFunction, aggregateColumn), aggregateFunction]);\n\n    if (!options.dataType) {\n      if (attrOptions) {\n        options.dataType = attrOptions.type;\n      } else {\n        // Use FLOAT as fallback\n        options.dataType = new DataTypes.FLOAT();\n      }\n    } else {\n      options.dataType = this.sequelize.normalizeDataType(options.dataType);\n    }\n\n    Utils.mapOptionFieldNames(options, this);\n    options = this._paranoidClause(this, options);\n\n    return this.QueryInterface.rawSelect(this.getTableName(options), options, aggregateFunction, this);\n  }\n\n  /**\n   * Count the number of records matching the provided where clause.\n   *\n   * If you provide an `include` option, the number of matching associations will be counted instead.\n   *\n   * @param {Object}        [options]\n   * @param {Object}        [options.where] A hash of search attributes.\n   * @param {Object}        [options.include] Include options. See `find` for details\n   * @param {Boolean}       [options.paranoid=true] Set `true` to count only non-deleted records. Can be used on models with `paranoid` enabled\n   * @param {Boolean}       [options.distinct] Apply COUNT(DISTINCT(col)) on primary key or on options.col.\n   * @param {String}        [options.col] Column on which COUNT() should be applied\n   * @param {Object}        [options.attributes] Used in conjunction with `group`\n   * @param {Object}        [options.group] For creating complex counts. Will return multiple rows as needed.\n   * @param {Transaction}   [options.transaction] Transaction to run query under\n   * @param {Function}      [options.logging=false] A function that gets executed while running the query to log the sql.\n   * @param {Boolean}       [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).\n   * @param {String}        [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)\n   *\n   * @return {Promise<Integer>}\n   */\n  static count(options) {\n    return Promise.try(() => {\n      options = _.defaults(Utils.cloneDeep(options), { hooks: true });\n      if (options.hooks) {\n        return this.runHooks('beforeCount', options);\n      }\n    }).then(() => {\n      let col = options.col || '*';\n      if (options.include) {\n        col = this.name + '.' + (options.col || this.primaryKeyField);\n      }\n\n      Utils.mapOptionFieldNames(options, this);\n\n      options.plain = !options.group;\n      options.dataType = new DataTypes.INTEGER();\n      options.includeIgnoreAttributes = false;\n\n      // No limit, offset or order for the options max be given to count()\n      // Set them to null to prevent scopes setting those values\n      options.limit = null;\n      options.offset = null;\n      options.order = null;\n\n      return this.aggregate(col, 'count', options);\n    });\n  }\n\n  /**\n   * Find all the rows matching your query, within a specified offset / limit, and get the total number of rows matching your query. This is very useful for paging\n   *\n   * ```js\n   * Model.findAndCountAll({\n   *   where: ...,\n   *   limit: 12,\n   *   offset: 12\n   * }).then(result => {\n   *   ...\n   * })\n   * ```\n   * In the above example, `result.rows` will contain rows 13 through 24, while `result.count` will return the total number of rows that matched your query.\n   *\n   * When you add includes, only those which are required (either because they have a where clause, or because `required` is explicitly set to true on the include) will be added to the count part.\n   *\n   * Suppose you want to find all users who have a profile attached:\n   * ```js\n   * User.findAndCountAll({\n   *   include: [\n   *      { model: Profile, required: true}\n   *   ],\n   *   limit 3\n   * });\n   * ```\n   * Because the include for `Profile` has `required` set it will result in an inner join, and only the users who have a profile will be counted. If we remove `required` from the include, both users with and without profiles will be counted\n   *\n   * __Alias__: _findAndCountAll_\n   *\n   * @param {Object} [findOptions] See findAll\n   *\n   * @see {@link Model.findAll} for a specification of find and query options\n   * @return {Promise<{count: Integer, rows: Model[]}>}\n   */\n  static findAndCount(options) {\n    if (options !== undefined && !_.isPlainObject(options)) {\n      throw new Error('The argument passed to findAndCount must be an options object, use findById if you wish to pass a single primary key value');\n    }\n\n    const countOptions = Utils.cloneDeep(options);\n    if (countOptions.attributes) {\n      countOptions.attributes = undefined;\n    }\n\n    const countQuery = this.count(countOptions);\n    const findQuery = this.findAll(options);\n\n    return countQuery.then(count => {\n      if (count === 0) {\n        return {\n          count: 0,\n          rows: []\n        };\n      }\n      return findQuery.then(results => ({\n        count: count || 0,\n        rows: results\n      }));\n    });\n  }\n\n  /**\n   * Find the maximum value of field\n   *\n   * @param {String} field\n   * @param {Object} [options] See aggregate\n   * @see {@link Model#aggregate} for options\n   *\n   * @return {Promise<Any>}\n   */\n  static max(field, options) {\n    return this.aggregate(field, 'max', options);\n  }\n\n  /**\n   * Find the minimum value of field\n   *\n   * @param {String} field\n   * @param {Object} [options] See aggregate\n   * @see {@link Model#aggregate} for options\n   *\n   * @return {Promise<Any>}\n   */\n  static min(field, options) {\n    return this.aggregate(field, 'min', options);\n  }\n\n  /**\n   * Find the sum of field\n   *\n   * @param {String} field\n   * @param {Object} [options] See aggregate\n   * @see {@link Model#aggregate} for options\n   *\n   * @return {Promise<Number>}\n   */\n  static sum(field, options) {\n    return this.aggregate(field, 'sum', options);\n  }\n\n  /**\n   * Builds a new model instance.\n   *\n   * @param {Object}  [(values|values[])={}] An object of key value pairs or an array of such. If an array, the function will return an array of instances.\n   * @param {Object}  [options]\n   * @param {Boolean} [options.raw=false] If set to true, values will ignore field and virtual setters.\n   * @param {Boolean} [options.isNewRecord=true]\n   * @param {Array}   [options.include] an array of include options - Used to build prefetched/included model instances. See `set`\n   *\n   * @return {(Model|Model[])}\n   */\n  static build(values, options) { // testhint options:none\n    if (Array.isArray(values)) {\n      return this.bulkBuild(values, options);\n    }\n\n    return new this(values, options);\n  }\n\n  static bulkBuild(valueSets, options) { // testhint options:none\n    options = _.extend({\n      isNewRecord: true\n    }, options || {});\n\n    if (!options.includeValidated) {\n      this._conformOptions(options, this);\n      if (options.include) {\n        this._expandIncludeAll(options);\n        this._validateIncludedElements(options);\n      }\n    }\n\n    if (options.attributes) {\n      options.attributes = options.attributes.map(attribute => Array.isArray(attribute) ? attribute[1] : attribute);\n    }\n\n    return valueSets.map(values => this.build(values, options));\n  }\n\n  /**\n   * Builds a new model instance and calls save on it.\n\n   * @see {@link Model#build}\n   * @see {@link Model#save}\n   *\n   * @param {Object}        values\n   * @param {Object}        [options]\n   * @param {Boolean}       [options.raw=false] If set to true, values will ignore field and virtual setters.\n   * @param {Boolean}       [options.isNewRecord=true]\n   * @param {Array}         [options.include] an array of include options - Used to build prefetched/included model instances. See `set`\n   * @param {Array}         [options.fields] If set, only columns matching those in fields will be saved\n   * @param {string[]}      [options.fields] An optional array of strings, representing database columns. If fields is provided, only those columns will be validated and saved.\n   * @param {Boolean}       [options.silent=false] If true, the updatedAt timestamp will not be updated.\n   * @param {Boolean}       [options.validate=true] If false, validations won't be run.\n   * @param {Boolean}       [options.hooks=true] Run before and after create / update + validate hooks\n   * @param {Function}      [options.logging=false] A function that gets executed while running the query to log the sql.\n   * @param {Boolean}       [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).\n   * @param {Transaction}   [options.transaction] Transaction to run query under\n   * @param {String}        [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)\n   * @param  {Boolean}      [options.returning=true] Return the affected rows (only for postgres)\n   *\n   * @return {Promise<Model>}\n   *\n   */\n  static create(values, options) {\n    options = Utils.cloneDeep(options || {});\n\n    return this.build(values, {\n      isNewRecord: true,\n      attributes: options.fields,\n      include: options.include,\n      raw: options.raw,\n      silent: options.silent\n    }).save(options);\n  }\n\n  /**\n   * Find a row that matches the query, or build (but don't save) the row if none is found.\n   * The successful result of the promise will be (instance, initialized) - Make sure to use .spread()\n   *\n   * __Alias__: _findOrInitialize_\n   *\n   * @param {Object}   options\n   * @param {Object}   options.where A hash of search attributes.\n   * @param {Object}   [options.defaults] Default values to use if building a new instance\n   * @param {Object}   [options.transaction] Transaction to run query under\n   * @param {Function} [options.logging=false] A function that gets executed while running the query to log the sql.\n   * @param {Boolean}  [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).\n   *\n   * @return {Promise<Model,initialized>}\n   */\n  static findOrBuild(options) {\n    if (!options || !options.where || arguments.length > 1) {\n      throw new Error(\n        'Missing where attribute in the options parameter passed to findOrInitialize. ' +\n        'Please note that the API has changed, and is now options only (an object with where, defaults keys, transaction etc.)'\n      );\n    }\n\n    let values;\n\n    return this.find(options).then(instance => {\n      if (instance === null) {\n        values = Utils._.clone(options.defaults) || {};\n        if (Utils._.isPlainObject(options.where)) {\n          values = Utils._.defaults(values, options.where);\n        }\n\n        instance = this.build(values);\n\n        return Promise.resolve([instance, true]);\n      }\n\n      return Promise.resolve([instance, false]);\n    });\n  }\n\n  /**\n   * Find a row that matches the query, or build and save the row if none is found\n   * The successful result of the promise will be (instance, created) - Make sure to use .spread()\n   *\n   * If no transaction is passed in the `options` object, a new transaction will be created internally, to prevent the race condition where a matching row is created by another connection after the find but before the insert call.\n   * However, it is not always possible to handle this case in SQLite, specifically if one transaction inserts and another tries to select before the first one has committed. In this case, an instance of sequelize. TimeoutError will be thrown instead.\n   * If a transaction is created, a savepoint will be created instead, and any unique constraint violation will be handled internally.\n   *\n   * @param {Object}      options\n   * @param {Object}      options.where where A hash of search attributes.\n   * @param {Object}      [options.defaults] Default values to use if creating a new instance\n   * @param {Transaction} [options.transaction] Transaction to run query under\n   * @see {@link Model.findAll} for a full specification of find and options\n   * @return {Promise<Model,created>}\n   */\n  static findOrCreate(options) {\n    if (!options || !options.where || arguments.length > 1) {\n      throw new Error(\n        'Missing where attribute in the options parameter passed to findOrCreate. '+\n        'Please note that the API has changed, and is now options only (an object with where, defaults keys, transaction etc.)'\n      );\n    }\n\n    options = _.assign({}, options);\n\n    if (options.transaction === undefined && this.sequelize.constructor._cls) {\n      const t = this.sequelize.constructor._cls.get('transaction');\n      if (t) {\n        options.transaction = t;\n      }\n    }\n\n    const internalTransaction = !options.transaction;\n    let values;\n    let transaction;\n\n    // Create a transaction or a savepoint, depending on whether a transaction was passed in\n    return this.sequelize.transaction(options).then(t => {\n      transaction = t;\n      options.transaction = t;\n\n      return this.findOne(_.defaults({transaction}, options));\n    }).then(instance => {\n      if (instance !== null) {\n        return [instance, false];\n      }\n\n      values = Utils._.clone(options.defaults) || {};\n      if (Utils._.isPlainObject(options.where)) {\n        values = _.defaults(values, options.where);\n      }\n\n      options.exception = true;\n\n      return this.create(values, options).then(instance => {\n        if (instance.get(this.primaryKeyAttribute, { raw: true }) === null) {\n          // If the query returned an empty result for the primary key, we know that this was actually a unique constraint violation\n          throw new this.sequelize.UniqueConstraintError();\n        }\n\n        return [instance, true];\n      }).catch(this.sequelize.UniqueConstraintError, err => {\n        const flattenedWhere = Utils.flattenObjectDeep(options.where);\n        const flattenedWhereKeys = _.map(_.keys(flattenedWhere), name => _.last(_.split(name, '.')));\n        const whereFields = flattenedWhereKeys.map(name => _.get(this.rawAttributes, `${name}.field`, name));\n        const defaultFields = options.defaults && Object.keys(options.defaults).map(name => this.rawAttributes[name].field || name);\n\n        if (defaultFields) {\n          if (!_.intersection(Object.keys(err.fields), whereFields).length && _.intersection(Object.keys(err.fields), defaultFields).length) {\n            throw err;\n          }\n        }\n\n        if (_.intersection(Object.keys(err.fields), whereFields).length) {\n          _.each(err.fields, (value, key) => {\n            const name = this.fieldRawAttributesMap[key].fieldName;\n            if (value.toString() !== options.where[name].toString()) {\n              throw new Error(`${this.name}#findOrCreate: value used for ${name} was not equal for both the find and the create calls, '${options.where[name]}' vs '${value}'`);\n            }\n          });\n        }\n\n        // Someone must have created a matching instance inside the same transaction since we last did a find. Let's find it!\n        return this.findOne(_.defaults({\n          transaction: internalTransaction ? null : transaction\n        }, options)).then(instance => {\n          // Sanity check, ideally we caught this at the defaultFeilds/err.fields check\n          // But if we didn't and instance is null, we will throw\n          if (instance === null) throw err;\n          return [instance, false];\n        });\n      });\n    }).finally(() => {\n      if (internalTransaction && transaction) {\n        // If we created a transaction internally (and not just a savepoint), we should clean it up\n        return transaction.commit();\n      }\n    });\n  }\n\n  /**\n   * A more performant findOrCreate that will not work under a transaction (at least not in postgres)\n   * Will execute a find call, if empty then attempt to create, if unique constraint then attempt to find again\n   *\n   * @param {Object}      options\n   * @param {Object}      options.where where A hash of search attributes.\n   * @param {Object}      [options.defaults] Default values to use if creating a new instance\n   * @see {@link Model.findAll} for a full specification of find and options\n   * @return {Promise<Model,created>}\n   */\n  static findCreateFind(options) {\n    if (!options || !options.where) {\n      throw new Error(\n        'Missing where attribute in the options parameter passed to findOrCreate.'\n      );\n    }\n\n    let values = Utils._.clone(options.defaults) || {};\n    if (Utils._.isPlainObject(options.where)) {\n      values = _.defaults(values, options.where);\n    }\n\n\n    return this.findOne(options).then(result => {\n      if (result) return [result, false];\n\n      return this.create(values, options)\n        .then(result => [result, true])\n        .catch(this.sequelize.UniqueConstraintError, () => this.findOne(options).then(result => [result, false]));\n    });\n  }\n\n  /**\n   * Insert or update a single row. An update will be executed if a row which matches the supplied values on either the primary key or a unique key is found. Note that the unique index must be defined in your sequelize model and not just in the table. Otherwise you may experience a unique constraint violation, because sequelize fails to identify the row that should be updated.\n   *\n   * **Implementation details:**\n   *\n   * * MySQL - Implemented as a single query `INSERT values ON DUPLICATE KEY UPDATE values`\n   * * PostgreSQL - Implemented as a temporary function with exception handling: INSERT EXCEPTION WHEN unique_constraint UPDATE\n   * * SQLite - Implemented as two queries `INSERT; UPDATE`. This means that the update is executed regardless of whether the row already existed or not\n   * * MSSQL - Implemented as a single query using `MERGE` and `WHEN (NOT) MATCHED THEN`\n   * **Note** that SQLite returns undefined for created, no matter if the row was created or updated. This is because SQLite always runs INSERT OR IGNORE + UPDATE, in a single query, so there is no way to know whether the row was inserted or not.\n   *\n   * __Alias__: _insertOrUpdate_\n   *\n   * @param  {Object}       values\n   * @param  {Object}       [options]\n   * @param  {Boolean}      [options.validate=true] Run validations before the row is inserted\n   * @param  {Array}        [options.fields=Object.keys(this.attributes)] The fields to insert / update. Defaults to all changed fields\n   * @param  {Boolean}      [options.hooks=true]  Run before / after upsert hooks?\n   * @param  {Transaction}  [options.transaction] Transaction to run query under\n   * @param  {Function}     [options.logging=false] A function that gets executed while running the query to log the sql.\n   * @param  {Boolean}      [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).\n   * @param  {String}       [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)\n   *\n   * @return {Promise<created>} Returns a boolean indicating whether the row was created or updated.\n   */\n  static upsert(values, options) {\n    options = Utils._.extend({\n      hooks: true\n    }, Utils.cloneDeep(options || {}));\n\n    const createdAtAttr = this._timestampAttributes.createdAt;\n    const updatedAtAttr = this._timestampAttributes.updatedAt;\n    const hadPrimary = this.primaryKeyField in values || this.primaryKeyAttribute in values;\n    const instance = this.build(values);\n\n    if (!options.fields) {\n      options.fields = Object.keys(instance._changed);\n    }\n\n    return instance.validate(options).then(() => {\n      // Map field names\n      const updatedDataValues = _.pick(instance.dataValues, Object.keys(instance._changed));\n      const insertValues = Utils.mapValueFieldNames(instance.dataValues, instance.attributes, this);\n      const updateValues = Utils.mapValueFieldNames(updatedDataValues, options.fields, this);\n      const now = Utils.now(this.sequelize.options.dialect);\n\n      // Attach createdAt\n      if (createdAtAttr && !updateValues[createdAtAttr]) {\n        const field = this.rawAttributes[createdAtAttr].field || createdAtAttr;\n        insertValues[field] = this._getDefaultTimestamp(createdAtAttr) || now;\n      }\n      if (updatedAtAttr && !insertValues[updatedAtAttr]) {\n        const field = this.rawAttributes[updatedAtAttr].field || updatedAtAttr;\n        insertValues[field] = updateValues[field] = this._getDefaultTimestamp(updatedAtAttr) || now;\n      }\n\n      // Build adds a null value for the primary key, if none was given by the user.\n      // We need to remove that because of some Postgres technicalities.\n      if (!hadPrimary && this.primaryKeyAttribute && !this.rawAttributes[this.primaryKeyAttribute].defaultValue) {\n        delete insertValues[this.primaryKeyField];\n        delete updateValues[this.primaryKeyField];\n      }\n\n      return Promise.try(() => {\n        if (options.hooks) {\n          return this.runHooks('beforeUpsert', values, options);\n        }\n      }).then(() => {\n        return this.QueryInterface.upsert(this.getTableName(options), insertValues, updateValues, instance.where(), this, options);\n      }).tap(result => {\n        if (options.hooks) {\n          return this.runHooks('afterUpsert', result, options);\n        }\n      });\n    });\n  }\n\n  /**\n   * Create and insert multiple instances in bulk.\n   *\n   * The success handler is passed an array of instances, but please notice that these may not completely represent the state of the rows in the DB. This is because MySQL\n   * and SQLite do not make it easy to obtain back automatically generated IDs and other default values in a way that can be mapped to multiple records.\n   * To obtain Instances for the newly created values, you will need to query for them again.\n   *\n   * If validation fails, the promise is rejected with an array-like [AggregateError](http://bluebirdjs.com/docs/api/aggregateerror.html)\n   *\n   * @param  {Array}        records                          List of objects (key/value pairs) to create instances from\n   * @param  {Object}       [options]\n   * @param  {Array}        [options.fields]                 Fields to insert (defaults to all fields)\n   * @param  {Boolean}      [options.validate=false]         Should each row be subject to validation before it is inserted. The whole insert will fail if one row fails validation\n   * @param  {Boolean}      [options.hooks=true]             Run before / after bulk create hooks?\n   * @param  {Boolean}      [options.individualHooks=false]  Run before / after create hooks for each individual Instance? BulkCreate hooks will still be run if options.hooks is true.\n   * @param  {Boolean}      [options.ignoreDuplicates=false] Ignore duplicate values for primary keys? (not supported by postgres)\n   * @param  {Array}        [options.updateOnDuplicate]      Fields to update if row key already exists (on duplicate key update)? (only supported by mysql). By default, all fields are updated.\n   * @param  {Transaction}  [options.transaction] Transaction to run query under\n   * @param  {Function}     [options.logging=false]          A function that gets executed while running the query to log the sql.\n   * @param  {Boolean}      [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).\n   * @param  {Boolean}      [options.returning=false] Append RETURNING * to get back auto generated values (Postgres only)\n   * @param  {String}       [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)\n   *\n   * @return {Promise<Array<Model>>}\n   */\n  static bulkCreate(records, options) {\n    if (!records.length) {\n      return Promise.resolve([]);\n    }\n\n    options = Utils._.extend({\n      validate: false,\n      hooks: true,\n      individualHooks: false,\n      ignoreDuplicates: false\n    }, options || {});\n\n    options.fields = options.fields || Object.keys(this.tableAttributes);\n\n    const dialect = this.sequelize.options.dialect;\n    if (options.ignoreDuplicates && ['postgres', 'mssql'].indexOf(dialect) !== -1) {\n      return Promise.reject(new Error(dialect + ' does not support the \\'ignoreDuplicates\\' option.'));\n    }\n    if (options.updateOnDuplicate && dialect !== 'mysql') {\n      return Promise.reject(new Error(dialect + ' does not support the \\'updateOnDuplicate\\' option.'));\n    }\n\n    if (options.updateOnDuplicate) {\n      // By default, all attributes except 'createdAt' can be updated\n      let updatableFields = Utils._.pull(Object.keys(this.tableAttributes), 'createdAt');\n      if (Utils._.isArray(options.updateOnDuplicate) && !Utils._.isEmpty(options.updateOnDuplicate)) {\n        updatableFields = Utils._.intersection(updatableFields, options.updateOnDuplicate);\n      }\n      options.updateOnDuplicate = updatableFields;\n    }\n\n    options.model = this;\n\n    const createdAtAttr = this._timestampAttributes.createdAt;\n    const updatedAtAttr = this._timestampAttributes.updatedAt;\n    const now = Utils.now(this.sequelize.options.dialect);\n\n    let instances = records.map(values => this.build(values, {isNewRecord: true}));\n\n    return Promise.try(() => {\n      // Run before hook\n      if (options.hooks) {\n        return this.runHooks('beforeBulkCreate', instances, options);\n      }\n    }).then(() => {\n      // Validate\n      if (options.validate) {\n        const errors = new Promise.AggregateError();\n        const validateOptions = _.clone(options);\n        validateOptions.hooks = options.individualHooks;\n\n        return Promise.map(instances, instance =>\n          instance.validate(validateOptions).catch(err => {\n            errors.push({record: instance, errors: err});\n          })\n        ).then(() => {\n          delete options.skip;\n          if (errors.length) {\n            throw errors;\n          }\n        });\n      }\n    }).then(() => {\n      for (const instance of instances) {\n        const values = instance.dataValues;\n\n        // set createdAt/updatedAt attributes\n        if (createdAtAttr && !values[createdAtAttr]) {\n          values[createdAtAttr] = now;\n          options.fields.indexOf(createdAtAttr) === -1 && options.fields.push(createdAtAttr);\n        }\n        if (updatedAtAttr && !values[updatedAtAttr]) {\n          values[updatedAtAttr] = now;\n          options.fields.indexOf(updatedAtAttr) === -1 && options.fields.push(updatedAtAttr);\n        }\n\n        instance.dataValues = Utils.mapValueFieldNames(values, options.fields, this);\n      }\n\n      if (options.individualHooks) {\n        // Create each instance individually\n        return Promise.map(instances, instance => {\n          const individualOptions = Utils._.clone(options);\n          delete individualOptions.fields;\n          delete individualOptions.individualHooks;\n          delete individualOptions.ignoreDuplicates;\n          individualOptions.validate = false;\n          individualOptions.hooks = true;\n\n          return instance.save(individualOptions);\n        }).then(_instances => {\n          instances = _instances;\n        });\n      } else {\n        // Create all in one query\n        // Recreate records from instances to represent any changes made in hooks or validation\n        records = instances.map(instance => {\n          return Utils._.omit(instance.dataValues, this._virtualAttributes);\n        });\n\n        // Map attributes for serial identification\n        const attributes = {};\n        for (const attr in this.tableAttributes) {\n          attributes[this.rawAttributes[attr].field] = this.rawAttributes[attr];\n        }\n\n        return this.QueryInterface.bulkInsert(this.getTableName(options), records, options, attributes).then(results => {\n          if (Array.isArray(results)) {\n            results.forEach((result, i) => {\n              instances[i] && instances[i].set(this.primaryKeyAttribute, result[this.primaryKeyField], {raw: true});\n            });\n          }\n          return results;\n        });\n      }\n    }).then(() => {\n\n      // map fields back to attributes\n      instances.forEach(instance => {\n        for (const attr in this.rawAttributes) {\n          if (this.rawAttributes[attr].field &&\n              instance.dataValues[this.rawAttributes[attr].field] !== undefined &&\n              this.rawAttributes[attr].field !== attr\n          ) {\n            instance.set(attr, instance.dataValues[this.rawAttributes[attr].field]);\n            delete instance.dataValues[this.rawAttributes[attr].field];\n          }\n        }\n        instance.isNewRecord = false;\n      });\n\n      // Run after hook\n      if (options.hooks) {\n        return this.runHooks('afterBulkCreate', instances, options);\n      }\n    }).then(() => instances);\n  }\n\n  /**\n   * Truncate all instances of the model. This is a convenient method for Model.destroy({ truncate: true }).\n   *\n   * @param {object} [options] The options passed to Model.destroy in addition to truncate\n   * @param {Boolean|function} [options.cascade = false] Only used in conjunction with TRUNCATE. Truncates  all tables that have foreign-key references to the named table, or to any tables added to the group due to CASCADE.\n   * @param {Transaction}      [options.transaction] Transaction to run query under\n   * @param {Boolean|function} [options.logging] A function that logs sql queries, or false for no logging\n   * @param {Boolean}          [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).\n   * @param {String}           [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)\n   *\n   * @return {Promise}\n   *\n   * @see {@link Model#destroy} for more information\n   */\n  static truncate(options) {\n    options = Utils.cloneDeep(options) || {};\n    options.truncate = true;\n    return this.destroy(options);\n  }\n\n  /**\n   * Delete multiple instances, or set their deletedAt timestamp to the current time if `paranoid` is enabled.\n   *\n   * @param  {Object}       options\n   * @param  {Object}       [options.where]                 Filter the destroy\n   * @param  {Boolean}      [options.hooks=true]            Run before / after bulk destroy hooks?\n   * @param  {Boolean}      [options.individualHooks=false] If set to true, destroy will SELECT all records matching the where parameter and will execute before / after destroy hooks on each row\n   * @param  {Number}       [options.limit]                 How many rows to delete\n   * @param  {Boolean}      [options.force=false]           Delete instead of setting deletedAt to current timestamp (only applicable if `paranoid` is enabled)\n   * @param  {Boolean}      [options.truncate=false]        If set to true, dialects that support it will use TRUNCATE instead of DELETE FROM. If a table is truncated the where and limit options are ignored\n   * @param  {Boolean}      [options.cascade=false]         Only used in conjunction with TRUNCATE. Truncates  all tables that have foreign-key references to the named table, or to any tables added to the group due to CASCADE.\n   * @param  {Boolean}      [options.restartIdentity=false] Only used in conjunction with TRUNCATE. Automatically restart sequences owned by columns of the truncated table.\n   * @param  {Transaction}  [options.transaction] Transaction to run query under\n   * @param  {Function}     [options.logging=false]         A function that gets executed while running the query to log the sql.\n   * @param  {Boolean}      [options.benchmark=false]       Pass query execution time in milliseconds as second argument to logging function (options.logging).\n   * @return {Promise<Integer>} The number of destroyed rows\n   */\n  static destroy(options) {\n    let instances;\n\n    if (!options || !(options.where || options.truncate)) {\n      throw new Error('Missing where or truncate attribute in the options parameter of model.destroy.');\n    }\n\n    if (!options.truncate && !_.isPlainObject(options.where) && !_.isArray(options.where) && !(options.where instanceof Utils.SequelizeMethod)) {\n      throw new Error('Expected plain object, array or sequelize method in the options.where parameter of model.destroy.');\n    }\n\n    options = Utils.cloneDeep(options);\n    options = _.defaults(options, {\n      hooks: true,\n      individualHooks: false,\n      force: false,\n      cascade: false,\n      restartIdentity: false\n    });\n\n    options.type = QueryTypes.BULKDELETE;\n    this._injectScope(options);\n\n    Utils.mapOptionFieldNames(options, this);\n    options.model = this;\n\n    return Promise.try(() => {\n      // Run before hook\n      if (options.hooks) {\n        return this.runHooks('beforeBulkDestroy', options);\n      }\n    }).then(() => {\n      // Get daos and run beforeDestroy hook on each record individually\n      if (options.individualHooks) {\n        return this.findAll({where: options.where, transaction: options.transaction, logging: options.logging, benchmark: options.benchmark})\n          .map(instance => this.runHooks('beforeDestroy', instance, options).then(() => instance))\n          .then(_instances => {\n            instances = _instances;\n          });\n      }\n    }).then(() => {\n      // Run delete query (or update if paranoid)\n      if (this._timestampAttributes.deletedAt && !options.force) {\n        // Set query type appropriately when running soft delete\n        options.type = QueryTypes.BULKUPDATE;\n\n        const attrValueHash = {};\n        const deletedAtAttribute = this.rawAttributes[this._timestampAttributes.deletedAt];\n        const field = this.rawAttributes[this._timestampAttributes.deletedAt].field;\n        const where = {};\n\n        where[field] = deletedAtAttribute.hasOwnProperty('defaultValue') ? deletedAtAttribute.defaultValue : null;\n\n        attrValueHash[field] = Utils.now(this.sequelize.options.dialect);\n        return this.QueryInterface.bulkUpdate(this.getTableName(options), attrValueHash, _.defaults(where, options.where), options, this.rawAttributes);\n      } else {\n        return this.QueryInterface.bulkDelete(this.getTableName(options), options.where, options, this);\n      }\n    }).tap(() => {\n      // Run afterDestroy hook on each record individually\n      if (options.individualHooks) {\n        return Promise.map(instances, instance => this.runHooks('afterDestroy', instance, options));\n      }\n    }).tap(() => {\n      // Run after hook\n      if (options.hooks) {\n        return this.runHooks('afterBulkDestroy', options);\n      }\n    });\n  }\n\n  /**\n   * Restore multiple instances if `paranoid` is enabled.\n   *\n   * @param  {Object}       options\n   * @param  {Object}       [options.where]                 Filter the restore\n   * @param  {Boolean}      [options.hooks=true]            Run before / after bulk restore hooks?\n   * @param  {Boolean}      [options.individualHooks=false] If set to true, restore will find all records within the where parameter and will execute before / after bulkRestore hooks on each row\n   * @param  {Number}       [options.limit]                 How many rows to undelete (only for mysql)\n   * @param  {Function}     [options.logging=false]         A function that gets executed while running the query to log the sql.\n   * @param  {Boolean}      [options.benchmark=false]       Pass query execution time in milliseconds as second argument to logging function (options.logging).\n   * @param  {Transaction}  [options.transaction] Transaction to run query under\n   *\n   * @return {Promise<undefined>}\n   */\n  static restore(options) {\n    if (!this._timestampAttributes.deletedAt) throw new Error('Model is not paranoid');\n\n    options = Utils._.extend({\n      hooks: true,\n      individualHooks: false\n    }, options || {});\n\n    options.type = QueryTypes.RAW;\n    options.model = this;\n\n    let instances;\n\n    Utils.mapOptionFieldNames(options, this);\n\n    return Promise.try(() => {\n      // Run before hook\n      if (options.hooks) {\n        return this.runHooks('beforeBulkRestore', options);\n      }\n    }).then(() => {\n      // Get daos and run beforeRestore hook on each record individually\n      if (options.individualHooks) {\n        return this.findAll({where: options.where, transaction: options.transaction, logging: options.logging, benchmark: options.benchmark, paranoid: false})\n          .map(instance => this.runHooks('beforeRestore', instance, options).then(() => instance))\n          .then(_instances => {\n            instances = _instances;\n          });\n      }\n    }).then(() => {\n      // Run undelete query\n      const attrValueHash = {};\n      const deletedAtCol = this._timestampAttributes.deletedAt;\n      const deletedAtAttribute = this.rawAttributes[deletedAtCol];\n      const deletedAtDefaultValue = deletedAtAttribute.hasOwnProperty('defaultValue') ? deletedAtAttribute.defaultValue : null;\n\n      attrValueHash[deletedAtAttribute.field || deletedAtCol] = deletedAtDefaultValue;\n      options.omitNull = false;\n      return this.QueryInterface.bulkUpdate(this.getTableName(options), attrValueHash, options.where, options, this._timestampAttributes.deletedAt);\n    }).tap(() => {\n      // Run afterDestroy hook on each record individually\n      if (options.individualHooks) {\n        return Promise.map(instances, instance => this.runHooks('afterRestore', instance, options));\n      }\n    }).tap(() => {\n      // Run after hook\n      if (options.hooks) {\n        return this.runHooks('afterBulkRestore', options);\n      }\n    });\n  }\n\n  /**\n   * Update multiple instances that match the where options. The promise returns an array with one or two elements. The first element is always the number\n   * of affected rows, while the second element is the actual affected rows (only supported in postgres with `options.returning` true.)\n   *\n   * @param  {Object}       values\n   * @param  {Object}       options\n   * @param  {Object}       options.where                   Options to describe the scope of the search.\n   * @param  {Array}        [options.fields]                Fields to update (defaults to all fields)\n   * @param  {Boolean}      [options.validate=true]         Should each row be subject to validation before it is inserted. The whole insert will fail if one row fails validation\n   * @param  {Boolean}      [options.hooks=true]            Run before / after bulk update hooks?\n   * @param  {Boolean}      [options.sideEffects=true] Whether or not to update the side effects of any virtual setters.\n   * @param  {Boolean}      [options.individualHooks=false] Run before / after update hooks?. If true, this will execute a SELECT followed by individual UPDATEs. A select is needed, because the row data needs to be passed to the hooks\n   * @param  {Boolean}      [options.returning=false]       Return the affected rows (only for postgres)\n   * @param  {Number}       [options.limit]                 How many rows to update (only for mysql and mariadb, implemented as TOP(n) for MSSQL)\n   * @param  {Function}     [options.logging=false] A function that gets executed while running the query to log the sql.\n   * @param  {Boolean}      [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).\n   * @param  {Transaction}  [options.transaction] Transaction to run query under\n   * @param  {Boolean}      [options.silent=false] If true, the updatedAt timestamp will not be updated.\n   *\n   * @return {Promise<Array<affectedCount,affectedRows>>}\n   */\n  static update(values, options) {\n    this._optionsMustContainWhere(options);\n\n    options = Utils.cloneDeep(options);\n    options = _.defaults(options, {\n      validate: true,\n      hooks: true,\n      individualHooks: false,\n      returning: false,\n      force: false,\n      sideEffects: true\n    });\n\n    options.type = QueryTypes.BULKUPDATE;\n\n    this._injectScope(options);\n\n    // Clone values so it doesn't get modified for caller scope\n    values = _.clone(values);\n\n    // Remove values that are not in the options.fields\n    if (options.fields && options.fields instanceof Array) {\n      for (const key of Object.keys(values)) {\n        if (options.fields.indexOf(key) < 0) {\n          delete values[key];\n        }\n      }\n    } else {\n      const updatedAtAttr = this._timestampAttributes.updatedAt;\n      options.fields = _.intersection(Object.keys(values), Object.keys(this.tableAttributes));\n      if (updatedAtAttr && options.fields.indexOf(updatedAtAttr) === -1) {\n        options.fields.push(updatedAtAttr);\n      }\n    }\n\n    if (this._timestampAttributes.updatedAt && !options.silent) {\n      values[this._timestampAttributes.updatedAt] = this._getDefaultTimestamp(this._timestampAttributes.updatedAt) || Utils.now(this.sequelize.options.dialect);\n    }\n\n    options.model = this;\n\n    let instances;\n    let valuesUse;\n\n    return Promise.try(() => {\n      // Validate\n      if (options.validate) {\n        const build = this.build(values);\n        build.set(this._timestampAttributes.updatedAt, values[this._timestampAttributes.updatedAt], { raw: true });\n\n        if (options.sideEffects) {\n          values = Utils._.assign(values, Utils._.pick(build.get(), build.changed()));\n          options.fields = Utils._.union(options.fields, Object.keys(values));\n        }\n\n        // We want to skip validations for all other fields\n        options.skip = Utils._.difference(Object.keys(this.rawAttributes), Object.keys(values));\n        return build.validate(options).then(attributes => {\n          options.skip = undefined;\n          if (attributes && attributes.dataValues) {\n            values = Utils._.pick(attributes.dataValues, Object.keys(values));\n          }\n        });\n      }\n      return null;\n    }).then(() => {\n      // Run before hook\n      if (options.hooks) {\n        options.attributes = values;\n        return this.runHooks('beforeBulkUpdate', options).then(() => {\n          values = options.attributes;\n          delete options.attributes;\n        });\n      }\n      return null;\n    }).then(() => {\n      valuesUse = values;\n\n      // Get instances and run beforeUpdate hook on each record individually\n      if (options.individualHooks) {\n        return this.findAll({where: options.where, transaction: options.transaction, logging: options.logging, benchmark: options.benchmark}).then(_instances => {\n          instances = _instances;\n          if (!instances.length) {\n            return [];\n          }\n\n          // Run beforeUpdate hooks on each record and check whether beforeUpdate hook changes values uniformly\n          // i.e. whether they change values for each record in the same way\n          let changedValues;\n          let different = false;\n\n          return Promise.map(instances, instance => {\n            // Record updates in instances dataValues\n            Utils._.extend(instance.dataValues, values);\n            // Set the changed fields on the instance\n            Utils._.forIn(valuesUse, (newValue, attr) => {\n              if (newValue !== instance._previousDataValues[attr]) {\n                instance.setDataValue(attr, newValue);\n              }\n            });\n\n            // Run beforeUpdate hook\n            return this.runHooks('beforeUpdate', instance, options).then(() => {\n              if (!different) {\n                const thisChangedValues = {};\n                Utils._.forIn(instance.dataValues, (newValue, attr) => {\n                  if (newValue !== instance._previousDataValues[attr]) {\n                    thisChangedValues[attr] = newValue;\n                  }\n                });\n\n                if (!changedValues) {\n                  changedValues = thisChangedValues;\n                } else {\n                  different = !Utils._.isEqual(changedValues, thisChangedValues);\n                }\n              }\n\n              return instance;\n            });\n          }).then(_instances => {\n            instances = _instances;\n\n            if (!different) {\n              const keys = Object.keys(changedValues);\n              // Hooks do not change values or change them uniformly\n              if (keys.length) {\n                // Hooks change values - record changes in valuesUse so they are executed\n                valuesUse = changedValues;\n                options.fields = Utils._.union(options.fields, keys);\n              }\n              return;\n            } else {\n              // Hooks change values in a different way for each record\n              // Do not run original query but save each record individually\n              return Promise.map(instances, instance => {\n                const individualOptions = Utils._.clone(options);\n                delete individualOptions.individualHooks;\n                individualOptions.hooks = false;\n                individualOptions.validate = false;\n\n                return instance.save(individualOptions);\n              }).tap(_instances => {\n                instances = _instances;\n              });\n            }\n          });\n        });\n      }\n    }).then(results => {\n      if (results) {\n        // Update already done row-by-row - exit\n        return [results.length, results];\n      }\n\n      valuesUse = Utils.mapValueFieldNames(valuesUse, options.fields, this);\n      options = Utils.mapOptionFieldNames(options, this);\n      options.hasTrigger =  this.options ? this.options.hasTrigger : false;\n\n      // Run query to update all rows\n      return this.QueryInterface.bulkUpdate(this.getTableName(options), valuesUse, options.where, options, this.tableAttributes).then(affectedRows => {\n        if (options.returning) {\n          instances = affectedRows;\n          return [affectedRows.length, affectedRows];\n        }\n\n        return [affectedRows];\n      });\n    }).tap(result => {\n      if (options.individualHooks) {\n        return Promise.map(instances, instance => {\n          return this.runHooks('afterUpdate', instance, options);\n        }).then(() => {\n          result[1] = instances;\n        });\n      }\n    }).tap(() => {\n      // Run after hook\n      if (options.hooks) {\n        options.attributes = values;\n        return this.runHooks('afterBulkUpdate', options).then(() => {\n          delete options.attributes;\n        });\n      }\n    });\n  }\n\n  /**\n   * Run a describe query on the table. The result will be return to the listener as a hash of attributes and their types.\n   *\n   * @return {Promise}\n   */\n  static describe(schema, options) {\n    return this.QueryInterface.describeTable(this.tableName, _.assign({schema: schema || this._schema || undefined}, options));\n  }\n\n  static _getDefaultTimestamp(attr) {\n    if (!!this.rawAttributes[attr] && !!this.rawAttributes[attr].defaultValue) {\n      return Utils.toDefaultValue(this.rawAttributes[attr].defaultValue);\n    }\n    return undefined;\n  }\n\n  static _expandAttributes(options) {\n    if (_.isPlainObject(options.attributes)) {\n      let attributes = Object.keys(this.rawAttributes);\n\n      if (options.attributes.exclude) {\n        attributes = attributes.filter(elem => {\n          return options.attributes.exclude.indexOf(elem) === -1;\n        });\n      }\n      if (options.attributes.include) {\n        attributes = attributes.concat(options.attributes.include);\n      }\n\n      options.attributes = attributes;\n    }\n  }\n\n  // Inject _scope into options. Includes should have been conformed (conformOptions) before calling this\n  static _injectScope(options) {\n    const scope = Utils.cloneDeep(this._scope);\n\n    const filteredScope = _.omit(scope, 'include'); // Includes need special treatment\n\n    _.defaults(options, filteredScope);\n    _.defaults(options.where, filteredScope.where);\n\n    if (scope.include) {\n      options.include = options.include || [];\n\n      // Reverse so we consider the latest include first.\n      // This is used if several scopes specify the same include - the last scope should take precedence\n      for (const scopeInclude of scope.include.reverse()) {\n        if (scopeInclude.all || !options.include.some(item => {\n          const isSameModel = item.model && item.model.name === scopeInclude.model.name;\n          if (!isSameModel || !item.as) return isSameModel;\n\n          if (scopeInclude.as) {\n            return item.as === scopeInclude.as;\n          } else {\n            const association = scopeInclude.association || this.getAssociationForAlias(scopeInclude.model, scopeInclude.as);\n            return association ? item.as === association.as : false;\n          }\n        })) {\n          options.include.push(scopeInclude);\n        }\n      }\n    }\n  }\n\n  static inspect() {\n    return this.name;\n  }\n\n  static hasAlias(alias) {\n    return this.associations.hasOwnProperty(alias);\n  }\n\n  /**\n   * Increment the value of one or more columns. This is done in the database, which means it does not use the values currently stored on the Instance. The increment is done using a\n   * ```sql\n   * SET column = column + X WHERE foo = 'bar'\n   * ```\n   * query. To get the correct value after an increment into the Instance you should do a reload.\n   *\n   *```js\n  * Model.increment('number', { where: { foo: 'bar' }) // increment number by 1\n  * Model.increment(['number', 'count'], { by: 2, where: { foo: 'bar' } }) // increment number and count by 2\n  * Model.increment({ answer: 42, tries: -1}, { by: 2, where: { foo: 'bar' } }) // increment answer by 42, and decrement tries by 1.\n  *                                                        // `by` is ignored, since each column has its own value\n  * ```\n  *\n  * @see {@link Model#reload}\n  * @param {String|Array|Object} fields If a string is provided, that column is incremented by the value of `by` given in options. If an array is provided, the same is true for each column. If and object is provided, each column is incremented by the value given.\n  * @param {Object} options\n  * @param {Object} options.where\n  * @param {Integer} [options.by=1] The number to increment by\n  * @param {Boolean} [options.silent=false] If true, the updatedAt timestamp will not be updated.\n  * @param {Function} [options.logging=false] A function that gets executed while running the query to log the sql.\n  * @param {Transaction} [options.transaction]\n  * @param  {String}       [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)\n  *\n  * @return {Promise<this>}\n  */\n  static increment(fields, options) {\n    this._optionsMustContainWhere(options);\n\n    const updatedAtAttr = this._timestampAttributes.updatedAt;\n    const versionAttr = this._versionAttribute;\n    const updatedAtAttribute = this.rawAttributes[updatedAtAttr];\n    options = _.defaults({}, options, {\n      by: 1,\n      attributes: {},\n      where: {},\n      increment: true\n    });\n\n    const where = _.extend({}, options.where);\n\n    let values = {};\n    if (Utils._.isString(fields)) {\n      values[fields] = options.by;\n    } else if (Utils._.isArray(fields)) {\n      Utils._.each(fields, field => {\n        values[field] = options.by;\n      });\n    } else { // Assume fields is key-value pairs\n      values = fields;\n    }\n\n    if (!options.silent && updatedAtAttr && !values[updatedAtAttr]) {\n      options.attributes[updatedAtAttribute.field || updatedAtAttr] = this._getDefaultTimestamp(updatedAtAttr) || Utils.now(this.sequelize.options.dialect);\n    }\n    if (versionAttr) {\n      values[versionAttr] = 1;\n    }\n\n    for (const attr of Object.keys(values)) {\n      // Field name mapping\n      if (this.rawAttributes[attr] && this.rawAttributes[attr].field && this.rawAttributes[attr].field !== attr) {\n        values[this.rawAttributes[attr].field] = values[attr];\n        delete values[attr];\n      }\n    }\n\n    let promise;\n    if (!options.increment) {\n      promise = this.sequelize.getQueryInterface().decrement(this, this.getTableName(options), values, where, options);\n    } else {\n      promise = this.sequelize.getQueryInterface().increment(this, this.getTableName(options), values, where, options);\n    }\n\n    return promise.then(affectedRows => {\n      if (options.returning) {\n        return [affectedRows, affectedRows.length];\n      }\n\n      return [affectedRows];\n    });\n  }\n\n  static _optionsMustContainWhere(options) {\n    assert(options && options.where, 'Missing where attribute in the options parameter');\n    assert(_.isPlainObject(options.where) || _.isArray(options.where) || options.where instanceof Utils.SequelizeMethod,\n      'Expected plain object, array or sequelize method in the options.where parameter');\n  }\n\n  /**\n   * Builds a new model instance.\n   * @param {Object}  [values={}] an object of key value pairs\n   * @param {Object}  [options]\n   * @param {Boolean} [options.raw=false] If set to true, values will ignore field and virtual setters.\n   * @param {Boolean} [options.isNewRecord=true]\n   * @param {Array}   [options.include] an array of include options - Used to build prefetched/included model instances. See `set`\n   */\n  constructor(values, options) {\n    values = values || {};\n    options = _.extend({\n      isNewRecord: true,\n      _schema: this.constructor._schema,\n      _schemaDelimiter: this.constructor._schemaDelimiter\n    }, options || {});\n\n    if (options.attributes) {\n      options.attributes = options.attributes.map(attribute => Array.isArray(attribute) ? attribute[1] : attribute);\n    }\n\n    if (!options.includeValidated) {\n      this.constructor._conformOptions(options, this.constructor);\n      if (options.include) {\n        this.constructor._expandIncludeAll(options);\n        this.constructor._validateIncludedElements(options);\n      }\n    }\n\n    this.dataValues = {};\n    this._previousDataValues = {};\n    this._changed = {};\n    this._modelOptions = this.constructor.options;\n    this._options = options || {};\n    this.__eagerlyLoadedAssociations = [];\n    /**\n     * Returns true if this instance has not yet been persisted to the database\n     * @property isNewRecord\n     * @return {Boolean}\n     */\n    this.isNewRecord = options.isNewRecord;\n\n    /**\n     * Returns the Model the instance was created from.\n     * @see {@link Model}\n     * @property Model\n     * @return {Model}\n     */\n\n    this._initValues(values, options);\n  }\n\n  _initValues(values, options) {\n    let defaults;\n    let key;\n\n    values = values && _.clone(values) || {};\n\n    if (options.isNewRecord) {\n      defaults = {};\n\n      if (this.constructor._hasDefaultValues) {\n        defaults = _.mapValues(this.constructor._defaultValues, valueFn => {\n          const value = valueFn();\n          return value && value instanceof Utils.SequelizeMethod ? value : _.cloneDeep(value);\n        });\n      }\n\n      // set id to null if not passed as value, a newly created dao has no id\n      // removing this breaks bulkCreate\n      // do after default values since it might have UUID as a default value\n      if (this.constructor.primaryKeyAttribute && !defaults.hasOwnProperty(this.constructor.primaryKeyAttribute)) {\n        defaults[this.constructor.primaryKeyAttribute] = null;\n      }\n\n      if (this.constructor._timestampAttributes.createdAt && defaults[this.constructor._timestampAttributes.createdAt]) {\n        this.dataValues[this.constructor._timestampAttributes.createdAt] = Utils.toDefaultValue(defaults[this.constructor._timestampAttributes.createdAt]);\n        delete defaults[this.constructor._timestampAttributes.createdAt];\n      }\n\n      if (this.constructor._timestampAttributes.updatedAt && defaults[this.constructor._timestampAttributes.updatedAt]) {\n        this.dataValues[this.constructor._timestampAttributes.updatedAt] = Utils.toDefaultValue(defaults[this.constructor._timestampAttributes.updatedAt]);\n        delete defaults[this.constructor._timestampAttributes.updatedAt];\n      }\n\n      if (this.constructor._timestampAttributes.deletedAt && defaults[this.constructor._timestampAttributes.deletedAt]) {\n        this.dataValues[this.constructor._timestampAttributes.deletedAt] = Utils.toDefaultValue(defaults[this.constructor._timestampAttributes.deletedAt]);\n        delete defaults[this.constructor._timestampAttributes.deletedAt];\n      }\n\n      if (Object.keys(defaults).length) {\n        for (key in defaults) {\n          if (values[key] === undefined) {\n            this.set(key, Utils.toDefaultValue(defaults[key]), defaultsOptions);\n            delete values[key];\n          }\n        }\n      }\n    }\n\n    this.set(values, options);\n  }\n\n  /**\n   * A reference to the sequelize instance\n   * @see {@link Sequelize}\n   * @property sequelize\n   * @return {Sequelize}\n   */\n  get sequelize() {\n    return this.constructor.sequelize;\n  }\n\n  /**\n   * Get an object representing the query for this instance, use with `options.where`\n   *\n   * @property where\n   * @return {Object}\n   */\n  where(checkVersion) {\n    const where = this.constructor.primaryKeyAttributes.reduce((result, attribute) => {\n      result[attribute] = this.get(attribute, {raw: true});\n      return result;\n    }, {});\n\n    if (_.size(where) === 0) {\n      return this._modelOptions.whereCollection;\n    }\n    const versionAttr = this.constructor._versionAttribute;\n    if (checkVersion && versionAttr) {\n      where[versionAttr] = this.get(versionAttr, {raw: true});\n    }\n    return Utils.mapWhereFieldNames(where, this.constructor);\n  }\n\n  toString() {\n    return '[object SequelizeInstance:'+this.constructor.name+']';\n  }\n\n  /**\n   * Get the value of the underlying data value\n   *\n   * @param {String} key\n   * @return {any}\n   */\n  getDataValue(key) {\n    return this.dataValues[key];\n  }\n\n  /**\n   * Update the underlying data value\n   *\n   * @param {String} key\n   * @param {any} value\n   */\n  setDataValue(key, value) {\n    const originalValue = this._previousDataValues[key];\n    if (!Utils.isPrimitive(value) || value !== originalValue) {\n      this.changed(key, true);\n    }\n\n    this.dataValues[key] = value;\n  }\n\n  /**\n   * If no key is given, returns all values of the instance, also invoking virtual getters.\n   *\n   * If key is given and a field or virtual getter is present for the key it will call that getter - else it will return the value for key.\n   *\n   * @param {String}  [key]\n   * @param {Object}  [options]\n   * @param {Boolean} [options.plain=false] If set to true, included instances will be returned as plain objects\n   * @param {Boolean} [options.raw=false] If set to true, field and virtual setters will be ignored\n   * @return {Object|any}\n   */\n  get(key, options) { // testhint options:none\n    if (options === undefined && typeof key === 'object') {\n      options = key;\n      key = undefined;\n    }\n\n    options = options || {};\n\n    if (key) {\n      if (this._customGetters[key] && !options.raw) {\n        return this._customGetters[key].call(this, key, options);\n      }\n      if (options.plain && this._options.include && this._options.includeNames.indexOf(key) !== -1) {\n        if (Array.isArray(this.dataValues[key])) {\n          return this.dataValues[key].map(instance => instance.get(options));\n        } else if (this.dataValues[key] instanceof Model) {\n          return this.dataValues[key].get(options);\n        } else {\n          return this.dataValues[key];\n        }\n      }\n      return this.dataValues[key];\n    }\n\n    if (this._hasCustomGetters || options.plain && this._options.include || options.clone) {\n      const values = {};\n      let _key;\n\n      if (this._hasCustomGetters) {\n        for (_key in this._customGetters) {\n          if (this._customGetters.hasOwnProperty(_key)) {\n            values[_key] = this.get(_key, options);\n          }\n        }\n      }\n\n      for (_key in this.dataValues) {\n        if (!values.hasOwnProperty(_key) && this.dataValues.hasOwnProperty(_key)) {\n          values[_key] = this.get(_key, options);\n        }\n      }\n      return values;\n    }\n    return this.dataValues;\n  }\n\n  /**\n   * Set is used to update values on the instance (the sequelize representation of the instance that is, remember that nothing will be persisted before you actually call `save`).\n   * In its most basic form `set` will update a value stored in the underlying `dataValues` object. However, if a custom setter function is defined for the key, that function\n   * will be called instead. To bypass the setter, you can pass `raw: true` in the options object.\n   *\n   * If set is called with an object, it will loop over the object, and call set recursively for each key, value pair. If you set raw to true, the underlying dataValues will either be\n   * set directly to the object passed, or used to extend dataValues, if dataValues already contain values.\n   *\n   * When set is called, the previous value of the field is stored and sets a changed flag(see `changed`).\n   *\n   * Set can also be used to build instances for associations, if you have values for those.\n   * When using set with associations you need to make sure the property key matches the alias of the association\n   * while also making sure that the proper include options have been set (from .build() or .find())\n   *\n   * If called with a dot.separated key on a JSON/JSONB attribute it will set the value nested and flag the entire object as changed.\n   *\n   * @see {@link Model.findAll} for more information about includes\n   * @param {String|Object} key\n   * @param {any} value\n   * @param {Object} [options]\n   * @param {Boolean} [options.raw=false] If set to true, field and virtual setters will be ignored\n   * @param {Boolean} [options.reset=false] Clear all previously set data values\n   */\n  set(key, value, options) { // testhint options:none\n    let values;\n    let originalValue;\n\n    if (typeof key === 'object' && key !== null) {\n      values = key;\n      options = value || {};\n\n      if (options.reset) {\n        this.dataValues = {};\n      }\n\n      // If raw, and we're not dealing with includes or special attributes, just set it straight on the dataValues object\n      if (options.raw && !(this._options && this._options.include) && !(options && options.attributes) && !this.constructor._hasBooleanAttributes && !this.constructor._hasDateAttributes) {\n        if (Object.keys(this.dataValues).length) {\n          this.dataValues = _.extend(this.dataValues, values);\n        } else {\n          this.dataValues = values;\n        }\n        // If raw, .changed() shouldn't be true\n        this._previousDataValues = _.clone(this.dataValues);\n      } else {\n        // Loop and call set\n\n        if (options.attributes) {\n          let keys = options.attributes;\n          if (this.constructor._hasVirtualAttributes) {\n            keys = keys.concat(this.constructor._virtualAttributes);\n          }\n\n          if (this._options.includeNames) {\n            keys = keys.concat(this._options.includeNames);\n          }\n\n          for (let i = 0, length = keys.length; i < length; i++) {\n            if (values[keys[i]] !== undefined) {\n              this.set(keys[i], values[keys[i]], options);\n            }\n          }\n        } else {\n          for (const key in values) {\n            this.set(key, values[key], options);\n          }\n        }\n\n        if (options.raw) {\n          // If raw, .changed() shouldn't be true\n          this._previousDataValues = _.clone(this.dataValues);\n        }\n      }\n    } else {\n      if (!options)\n        options = {};\n      if (!options.raw) {\n        originalValue = this.dataValues[key];\n      }\n\n      // If not raw, and there's a custom setter\n      if (!options.raw && this._customSetters[key]) {\n        this._customSetters[key].call(this, value, key);\n        if (!Utils.isPrimitive(value) && value !== null || value !== originalValue) {\n          this._previousDataValues[key] = originalValue;\n          this.changed(key, true);\n        }\n      } else {\n        // Check if we have included models, and if this key matches the include model names/aliases\n\n        if (this._options && this._options.include && this._options.includeNames.indexOf(key) !== -1) {\n          // Pass it on to the include handler\n          this._setInclude(key, value, options);\n          return this;\n        } else {\n          // Bunch of stuff we won't do when its raw\n          if (!options.raw) {\n            // If attribute is not in model definition, return\n            if (!this._isAttribute(key)) {\n              if (key.indexOf('.') > -1 && this.constructor._isJsonAttribute(key.split('.')[0])) {\n                const previousDottieValue = Dottie.get(this.dataValues, key);\n                if (!_.isEqual(previousDottieValue, value)) {\n                  Dottie.set(this.dataValues, key, value);\n                  this.changed(key.split('.')[0], true);\n                }\n              }\n              return this;\n            }\n\n            // If attempting to set primary key and primary key is already defined, return\n            if (this.constructor._hasPrimaryKeys && originalValue && this.constructor._isPrimaryKey(key)) {\n              return this;\n            }\n\n            // If attempting to set read only attributes, return\n            if (!this.isNewRecord && this.constructor._hasReadOnlyAttributes && this.constructor._isReadOnlyAttribute(key)) {\n              return this;\n            }\n\n            // Convert date fields to real date objects\n            if (this.constructor._hasDateAttributes && this.constructor._isDateAttribute(key) && !!value && !(value instanceof Utils.SequelizeMethod)) {\n              // Dont parse DATEONLY to new Date, keep them as string\n              if (this.rawAttributes[key].type instanceof DataTypes.DATEONLY) {\n                if (originalValue && originalValue === value) {\n                  return this;\n                } else {\n                  value = moment(value).format('YYYY-MM-DD');\n                }\n              } else { // go ahread and parse as Date if required\n                if (!(value instanceof Date)) {\n                  value = new Date(value);\n                }\n                if (originalValue) {\n                  if (!(originalValue instanceof Date)) {\n                    originalValue = new Date(originalValue);\n                  }\n                  if (value.getTime() === originalValue.getTime()) {\n                    return this;\n                  }\n                }\n              }\n            }\n          }\n\n          // Convert boolean-ish values to booleans\n          if (this.constructor._hasBooleanAttributes && this.constructor._isBooleanAttribute(key) && value !== null && value !== undefined && !(value instanceof Utils.SequelizeMethod)) {\n            if (Buffer.isBuffer(value) && value.length === 1) {\n              // Bit fields are returned as buffers\n              value = value[0];\n            }\n\n            if (_.isString(value)) {\n              // Only take action on valid boolean strings.\n              value = value === 'true' ? true : value === 'false' ? false : value;\n\n            } else if (_.isNumber(value)) {\n              // Only take action on valid boolean integers.\n              value = value === 1 ? true : value === 0 ? false : value;\n            }\n          }\n\n          if (!options.raw && (!Utils.isPrimitive(value) && value !== null || value !== originalValue)) {\n            this._previousDataValues[key] = originalValue;\n            this.changed(key, true);\n          }\n          this.dataValues[key] = value;\n        }\n      }\n    }\n\n    return this;\n  }\n\n  setAttributes(updates) {\n    return this.set(updates);\n  }\n\n  /**\n   * If changed is called with a string it will return a boolean indicating whether the value of that key in `dataValues` is different from the value in `_previousDataValues`.\n   *\n   * If changed is called without an argument, it will return an array of keys that have changed.\n   *\n   * If changed is called without an argument and no keys have changed, it will return `false`.\n   *\n   * @param {String} [key]\n   * @return {Boolean|Array}\n   */\n  changed(key, value) {\n    if (key) {\n      if (value !== undefined) {\n        this._changed[key] = value;\n        return this;\n      }\n      return this._changed[key] || false;\n    }\n\n    const changed = Object.keys(this.dataValues).filter(key => this.changed(key));\n\n    return changed.length ? changed : false;\n  }\n\n  /**\n   * Returns the previous value for key from `_previousDataValues`.\n   *\n   * If called without a key, returns the previous values for all values which have changed\n   *\n   * @param {String} [key]\n   * @return {any|Array<any>}\n   */\n  previous(key) {\n    if (key) {\n      return this._previousDataValues[key];\n    }\n\n    return _.pickBy(this._previousDataValues, (value, key) => this.changed(key));\n  }\n\n  _setInclude(key, value, options) {\n    if (!Array.isArray(value)) value = [value];\n    if (value[0] instanceof Model) {\n      value = value.map(instance => instance.dataValues);\n    }\n\n    const include = this._options.includeMap[key];\n    const association = include.association;\n    const accessor = key;\n    const primaryKeyAttribute  = include.model.primaryKeyAttribute;\n    let childOptions;\n    let isEmpty;\n\n    if (!isEmpty) {\n      childOptions = {\n        isNewRecord: this.isNewRecord,\n        include: include.include,\n        includeNames: include.includeNames,\n        includeMap: include.includeMap,\n        includeValidated: true,\n        raw: options.raw,\n        attributes: include.originalAttributes\n      };\n    }\n    if (include.originalAttributes === undefined || include.originalAttributes.length) {\n      if (association.isSingleAssociation) {\n        if (Array.isArray(value)) {\n          value = value[0];\n        }\n\n        isEmpty = value && value[primaryKeyAttribute] === null || value === null;\n        this[accessor] = this.dataValues[accessor] = isEmpty ? null : include.model.build(value, childOptions);\n      } else {\n        isEmpty = value[0] && value[0][primaryKeyAttribute] === null;\n        this[accessor] = this.dataValues[accessor] = isEmpty ? [] : include.model.bulkBuild(value, childOptions);\n      }\n    }\n  }\n\n  /**\n   * Validate this instance, and if the validation passes, persist it to the database. It will only save changed fields, and do nothing if no fields have changed.\n   *\n   * On success, the callback will be called with this instance. On validation error, the callback will be called with an instance of `Sequelize.ValidationError`.\n   * This error will have a property for each of the fields for which validation failed, with the error message for that field.\n   *\n   * @param {Object}      [options]\n   * @param {string[]}    [options.fields] An optional array of strings, representing database columns. If fields is provided, only those columns will be validated and saved.\n   * @param {Boolean}     [options.silent=false] If true, the updatedAt timestamp will not be updated.\n   * @param {Boolean}     [options.validate=true] If false, validations won't be run.\n   * @param {Boolean}     [options.hooks=true] Run before and after create / update + validate hooks\n   * @param {Function}    [options.logging=false] A function that gets executed while running the query to log the sql.\n   * @param {Transaction} [options.transaction]\n   * @param  {String}     [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)\n   * @param  {Boolean}    [options.returning] Append RETURNING * to get back auto generated values (Postgres only)\n   * @return {Promise<this|Errors.ValidationError>}\n   */\n  save(options) {\n    if (arguments.length > 1) {\n      throw new Error('The second argument was removed in favor of the options object.');\n    }\n\n    options = Utils.cloneDeep(options);\n    options = _.defaults(options, {\n      hooks: true,\n      validate: true\n    });\n\n    if (!options.fields) {\n      if (this.isNewRecord) {\n        options.fields = Object.keys(this.constructor.rawAttributes);\n      } else {\n        options.fields = _.intersection(this.changed(), Object.keys(this.constructor.rawAttributes));\n      }\n\n      options.defaultFields = options.fields;\n    }\n\n    if (options.returning === undefined) {\n      if (options.association) {\n        options.returning = false;\n      } else if (this.isNewRecord) {\n        options.returning = true;\n      }\n    }\n\n    const primaryKeyName = this.constructor.primaryKeyAttribute;\n    const primaryKeyAttribute = primaryKeyName && this.constructor.rawAttributes[primaryKeyName];\n    const createdAtAttr = this.constructor._timestampAttributes.createdAt;\n    const versionAttr = this.constructor._versionAttribute;\n    const hook = this.isNewRecord ? 'Create' : 'Update';\n    const wasNewRecord = this.isNewRecord;\n    const now = Utils.now(this.sequelize.options.dialect);\n    let updatedAtAttr = this.constructor._timestampAttributes.updatedAt;\n\n    if (updatedAtAttr && options.fields.length >= 1 && options.fields.indexOf(updatedAtAttr) === -1) {\n      options.fields.push(updatedAtAttr);\n    }\n    if (versionAttr && options.fields.length >= 1 && options.fields.indexOf(versionAttr) === -1) {\n      options.fields.push(versionAttr);\n    }\n\n    if (options.silent === true && !(this.isNewRecord && this.get(updatedAtAttr, {raw: true}))) {\n      // UpdateAtAttr might have been added as a result of Object.keys(Model.attributes). In that case we have to remove it again\n      Utils._.remove(options.fields, val => val === updatedAtAttr);\n      updatedAtAttr = false;\n    }\n\n    if (this.isNewRecord === true) {\n      if (createdAtAttr && options.fields.indexOf(createdAtAttr) === -1) {\n        options.fields.push(createdAtAttr);\n      }\n\n      if (primaryKeyAttribute && primaryKeyAttribute.defaultValue && options.fields.indexOf(primaryKeyName) < 0) {\n        options.fields.unshift(primaryKeyName);\n      }\n    }\n\n    if (this.isNewRecord === false) {\n      if (primaryKeyName && this.get(primaryKeyName, {raw: true}) === undefined) {\n        throw new Error('You attempted to save an instance with no primary key, this is not allowed since it would result in a global update');\n      }\n    }\n\n    if (updatedAtAttr && !options.silent && options.fields.indexOf(updatedAtAttr) !== -1) {\n      this.dataValues[updatedAtAttr] = this.constructor._getDefaultTimestamp(updatedAtAttr) || now;\n    }\n\n    if (this.isNewRecord && createdAtAttr && !this.dataValues[createdAtAttr]) {\n      this.dataValues[createdAtAttr] = this.constructor._getDefaultTimestamp(createdAtAttr) || now;\n    }\n\n    return Promise.try(() => {\n      // Validate\n      if (options.validate) {\n        return this.validate(options);\n      }\n    }).then(() => {\n      // Run before hook\n      if (options.hooks) {\n        const beforeHookValues = _.pick(this.dataValues, options.fields);\n        let ignoreChanged = _.difference(this.changed(), options.fields); // In case of update where it's only supposed to update the passed values and the hook values\n        let hookChanged;\n        let afterHookValues;\n\n        if (updatedAtAttr && options.fields.indexOf(updatedAtAttr) !== -1) {\n          ignoreChanged = _.without(ignoreChanged, updatedAtAttr);\n        }\n\n        return this.constructor.runHooks('before' + hook, this, options)\n          .then(() => {\n            if (options.defaultFields && !this.isNewRecord) {\n              afterHookValues = _.pick(this.dataValues, _.difference(this.changed(), ignoreChanged));\n\n              hookChanged = [];\n              for (const key of Object.keys(afterHookValues)) {\n                if (afterHookValues[key] !== beforeHookValues[key]) {\n                  hookChanged.push(key);\n                }\n              }\n\n              options.fields = _.uniq(options.fields.concat(hookChanged));\n            }\n\n            if (hookChanged) {\n              if (options.validate) {\n              // Validate again\n\n                options.skip = _.difference(Object.keys(this.constructor.rawAttributes), hookChanged);\n                return this.validate(options).then(() => {\n                  delete options.skip;\n                });\n              }\n            }\n          });\n      }\n    }).then(() => {\n      if (!options.fields.length) return this;\n      if (!this.isNewRecord) return this;\n      if (!this._options.include || !this._options.include.length) return this;\n\n      // Nested creation for BelongsTo relations\n      return Promise.map(this._options.include.filter(include => include.association instanceof BelongsTo), include => {\n        const instance = this.get(include.as);\n        if (!instance) return Promise.resolve();\n\n        const includeOptions =  _(Utils.cloneDeep(include))\n          .omit(['association'])\n          .defaults({\n            transaction: options.transaction,\n            logging: options.logging,\n            parentRecord: this\n          }).value();\n\n        return instance.save(includeOptions).then(() => this[include.association.accessors.set](instance, {save: false, logging: options.logging}));\n      });\n    }).then(() => {\n      const realFields = options.fields.filter(field => !this.constructor._isVirtualAttribute(field));\n      if (!realFields.length) return this;\n      if (!this.changed() && !this.isNewRecord) return this;\n\n      const versionFieldName = _.get(this.constructor.rawAttributes[versionAttr], 'field') || versionAttr;\n      let values = Utils.mapValueFieldNames(this.dataValues, options.fields, this.constructor);\n      let query = null;\n      let args = [];\n      let where;\n\n      if (this.isNewRecord) {\n        query = 'insert';\n        args = [this, this.constructor.getTableName(options), values, options];\n      } else {\n        where = this.where(true);\n        where = Utils.mapValueFieldNames(where, Object.keys(where), this.constructor);\n        if (versionAttr) {\n          values[versionFieldName] += 1;\n        }\n        query = 'update';\n        args = [this, this.constructor.getTableName(options), values, where, options];\n      }\n\n      return this.sequelize.getQueryInterface()[query].apply(this.sequelize.getQueryInterface(), args)\n        .then(results => {\n          const result = _.head(results);\n          const rowsUpdated = results[1];\n\n          if (versionAttr) {\n            // Check to see that a row was updated, otherwise it's an optimistic locking error.\n            if (rowsUpdated < 1) {\n              throw new sequelizeErrors.OptimisticLockError({\n                modelName: this.constructor.name,\n                values,\n                where\n              });\n            } else {\n              result.dataValues[versionAttr] = values[versionFieldName];\n            }\n          }\n\n          // Transfer database generated values (defaults, autoincrement, etc)\n          for (const attr of Object.keys(this.constructor.rawAttributes)) {\n            if (this.constructor.rawAttributes[attr].field &&\n                values[this.constructor.rawAttributes[attr].field] !== undefined &&\n                this.constructor.rawAttributes[attr].field !== attr\n            ) {\n              values[attr] = values[this.constructor.rawAttributes[attr].field];\n              delete values[this.constructor.rawAttributes[attr].field];\n            }\n          }\n          values = _.extend(values, result.dataValues);\n\n          result.dataValues = _.extend(result.dataValues, values);\n          return result;\n        })\n        .tap(() => {\n          if (!wasNewRecord) return this;\n          if (!this._options.include || !this._options.include.length) return this;\n\n          // Nested creation for HasOne/HasMany/BelongsToMany relations\n          return Promise.map(this._options.include.filter(include => !(include.association instanceof BelongsTo)), include => {\n            let instances = this.get(include.as);\n\n            if (!instances) return Promise.resolve();\n            if (!Array.isArray(instances)) instances = [instances];\n            if (!instances.length) return Promise.resolve();\n\n            const includeOptions =  _(Utils.cloneDeep(include))\n              .omit(['association'])\n              .defaults({\n                transaction: options.transaction,\n                logging: options.logging,\n                parentRecord: this\n              }).value();\n\n            // Instances will be updated in place so we can safely treat HasOne like a HasMany\n            return Promise.map(instances, instance => {\n              if (include.association instanceof BelongsToMany) {\n                return instance.save(includeOptions).then(() => {\n                  const values = {};\n                  values[include.association.foreignKey] = this.get(this.constructor.primaryKeyAttribute, {raw: true});\n                  values[include.association.otherKey] = instance.get(instance.constructor.primaryKeyAttribute, {raw: true});\n                  // Include values defined in the scope of the association\n                  _.assign(values, include.association.through.scope);\n                  return include.association.throughModel.create(values, includeOptions);\n                });\n              } else {\n                instance.set(include.association.foreignKey, this.get(this.constructor.primaryKeyAttribute, {raw: true}));\n                return instance.save(includeOptions);\n              }\n            });\n          });\n        })\n        .tap(result => {\n          // Run after hook\n          if (options.hooks) {\n            return this.constructor.runHooks('after' + hook, result, options);\n          }\n        })\n        .then(result => {\n          for (const field of options.fields) {\n            result._previousDataValues[field] = result.dataValues[field];\n            this.changed(field, false);\n          }\n          this.isNewRecord = false;\n          return result;\n        });\n    });\n  }\n\n  /**\n  * Refresh the current instance in-place, i.e. update the object with current data from the DB and return the same object.\n  * This is different from doing a `find(Instance.id)`, because that would create and return a new instance. With this method,\n  * all references to the Instance are updated with the new data and no new objects are created.\n  *\n  * @see {@link Model.findAll}\n  * @param {Object} [options] Options that are passed on to `Model.find`\n  * @param {Function} [options.logging=false] A function that gets executed while running the query to log the sql.\n  *\n  * @return {Promise<this>}\n  */\n  reload(options) {\n    options = _.defaults({}, options, {\n      where: this.where(),\n      include: this._options.include || null\n    });\n\n    return this.constructor.findOne(options)\n      .tap(reload => {\n        if (!reload) {\n          throw new sequelizeErrors.InstanceError(\n            'Instance could not be reloaded because it does not exist anymore (find call returned null)'\n          );\n        }\n      })\n      .then(reload => {\n      // update the internal options of the instance\n        this._options = reload._options;\n        // re-set instance values\n        this.set(reload.dataValues, {\n          raw: true,\n          reset: true && !options.attributes\n        });\n        return this;\n      });\n  }\n\n  /**\n  * Validate the attributes of this instance according to validation rules set in the model definition.\n  *\n  * The promise fulfills if and only if validation successful; otherwise it rejects an Error instance containing { field name : [error msgs] } entries.\n  *\n  * @param {Object} [options] Options that are passed to the validator\n  * @param {Array} [options.skip] An array of strings. All properties that are in this array will not be validated\n  * @param {Array} [options.fields] An array of strings. Only the properties that are in this array will be validated\n  * @param {Boolean} [options.hooks=true] Run before and after validate hooks\n  *\n  * @return {Promise<undefined>}\n  */\n  validate(options) {\n    return new InstanceValidator(this, options).validate();\n  }\n\n  /**\n   * This is the same as calling `set` and then calling `save` but it only saves the\n   * exact values passed to it, making it more atomic and safer.\n   *\n   * @see {@link Model#set}\n   * @see {@link Model#save}\n   * @param {Object} updates See `set`\n   * @param {Object} options See `save`\n   *\n   * @return {Promise<this>}\n   */\n  update(values, options) {\n    const changedBefore = this.changed() || [];\n\n    options = options || {};\n    if (Array.isArray(options)) options = {fields: options};\n\n    options = Utils.cloneDeep(options);\n    const setOptions = Utils.cloneDeep(options);\n    setOptions.attributes = options.fields;\n    this.set(values, setOptions);\n\n    // Now we need to figure out which fields were actually affected by the setter.\n    const sideEffects = _.without.apply(this, [this.changed() || []].concat(changedBefore));\n    const fields = _.union(Object.keys(values), sideEffects);\n\n    if (!options.fields) {\n      options.fields = _.intersection(fields, this.changed());\n      options.defaultFields = options.fields;\n    }\n\n    return this.save(options);\n  }\n\n  /**\n   * Destroy the row corresponding to this instance. Depending on your setting for paranoid, the row will either be completely deleted, or have its deletedAt timestamp set to the current time.\n   *\n   * @param {Object}      [options={}]\n   * @param {Boolean}     [options.force=false] If set to true, paranoid models will actually be deleted\n   * @param {Function}    [options.logging=false] A function that gets executed while running the query to log the sql.\n   * @param {Transaction} [options.transaction]\n   * @param  {String}       [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)\n   *\n   * @return {Promise<undefined>}\n   */\n\n  destroy(options) {\n    options = Utils._.extend({\n      hooks: true,\n      force: false\n    }, options);\n\n    return Promise.try(() => {\n      // Run before hook\n      if (options.hooks) {\n        return this.constructor.runHooks('beforeDestroy', this, options);\n      }\n    }).then(() => {\n      const where = this.where(true);\n\n      if (this.constructor._timestampAttributes.deletedAt && options.force === false) {\n        const attribute = this.constructor.rawAttributes[this.constructor._timestampAttributes.deletedAt];\n        const field = attribute.field || this.constructor._timestampAttributes.deletedAt;\n        const values = {};\n\n        values[field] = new Date();\n        where[field] = attribute.hasOwnProperty('defaultValue') ? attribute.defaultValue : null;\n\n        this.setDataValue(field, values[field]);\n\n        return this.sequelize.getQueryInterface().update(\n          this, this.constructor.getTableName(options), values, where, _.defaults({ hooks: false }, options)\n        ).then(results => {\n          const rowsUpdated = results[1];\n          if (this.constructor._versionAttribute && rowsUpdated < 1) {\n            throw new sequelizeErrors.OptimisticLockError({\n              modelName: this.constructor.name,\n              values,\n              where\n            });\n          }\n          return _.head(results);\n        });\n      } else {\n        return this.sequelize.getQueryInterface().delete(this, this.constructor.getTableName(options), where, _.assign({ type: QueryTypes.DELETE, limit: null }, options));\n      }\n    }).tap(() => {\n      // Run after hook\n      if (options.hooks) {\n        return this.constructor.runHooks('afterDestroy', this, options);\n      }\n    });\n  }\n\n  /**\n   * Helper method to determine if a instance is \"soft deleted\".  This is\n   * particularly useful if the implementer renamed the `deletedAt` attribute\n   * to something different.  This method requires `paranoid` to be enabled.\n   *\n   * @returns {Boolean}\n   */\n  isSoftDeleted() {\n    if (!this.constructor._timestampAttributes.deletedAt) {\n      throw new Error('Model is not paranoid');\n    }\n\n    const deletedAtAttribute = this.constructor.rawAttributes[this.constructor._timestampAttributes.deletedAt];\n    const defaultValue = deletedAtAttribute.hasOwnProperty('defaultValue') ? deletedAtAttribute.defaultValue : null;\n    const deletedAt = this.get(this.constructor._timestampAttributes.deletedAt);\n    const isSet = deletedAt !== defaultValue;\n\n    // No need to check the value of deletedAt if it's equal to the default\n    // value.  If so return the inverse of `isNotSet` since we are asking if\n    // the model *is* soft-deleted.\n    if (!isSet) {\n      return isSet;\n    }\n\n    const now = moment();\n    const deletedAtIsInTheFuture = moment(deletedAt).isAfter(now);\n\n    // If deletedAt is a datetime in the future then the model is *not* soft-deleted.\n    // Therefore, return the inverse of `deletedAtIsInTheFuture`.\n    return !deletedAtIsInTheFuture;\n  }\n\n  /**\n   * Restore the row corresponding to this instance. Only available for paranoid models.\n   *\n   * @param {Object}      [options={}]\n   * @param {Function}    [options.logging=false] A function that gets executed while running the query to log the sql.\n   * @param {Transaction} [options.transaction]\n   *\n   * @return {Promise<undefined>}\n   */\n  restore(options) {\n    if (!this.constructor._timestampAttributes.deletedAt) throw new Error('Model is not paranoid');\n\n    options = Utils._.extend({\n      hooks: true,\n      force: false\n    }, options);\n\n    return Promise.try(() => {\n      // Run before hook\n      if (options.hooks) {\n        return this.constructor.runHooks('beforeRestore', this, options);\n      }\n    }).then(() => {\n      const deletedAtCol = this.constructor._timestampAttributes.deletedAt;\n      const deletedAtAttribute = this.constructor.rawAttributes[deletedAtCol];\n      const deletedAtDefaultValue = deletedAtAttribute.hasOwnProperty('defaultValue') ? deletedAtAttribute.defaultValue : null;\n\n      this.setDataValue(deletedAtCol, deletedAtDefaultValue);\n      return this.save(_.extend({}, options, {hooks : false, omitNull : false}));\n    }).tap(() => {\n      // Run after hook\n      if (options.hooks) {\n        return this.constructor.runHooks('afterRestore', this, options);\n      }\n    });\n  }\n\n  /**\n   * Increment the value of one or more columns. This is done in the database, which means it does not use the values currently stored on the Instance. The increment is done using a\n   * ```sql\n   * SET column = column + X\n   * ```\n   * query. To get the correct value after an increment into the Instance you should do a reload.\n   *\n   *```js\n  * instance.increment('number') // increment number by 1\n  * instance.increment(['number', 'count'], { by: 2 }) // increment number and count by 2\n  * instance.increment({ answer: 42, tries: 1}, { by: 2 }) // increment answer by 42, and tries by 1.\n  *                                                        // `by` is ignored, since each column has its own value\n  * ```\n  *\n  * @see {@link Model#reload}\n  * @param {String|Array|Object} fields If a string is provided, that column is incremented by the value of `by` given in options. If an array is provided, the same is true for each column. If and object is provided, each column is incremented by the value given.\n  * @param {Object} [options]\n  * @param {Integer} [options.by=1] The number to increment by\n  * @param {Boolean} [options.silent=false] If true, the updatedAt timestamp will not be updated.\n  * @param {Function} [options.logging=false] A function that gets executed while running the query to log the sql.\n  * @param {Transaction} [options.transaction]\n  * @param  {String}       [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)\n  *\n  * @return {Promise<this>}\n  * @since 4.0.0\n  */\n  increment(fields, options) {\n    const identifier = this.where();\n\n    options = Utils.cloneDeep(options);\n    options.where = _.extend({}, options.where, identifier);\n    options.instance = this;\n\n    return this.constructor.increment(fields, options).return(this);\n  }\n\n  /**\n   * Decrement the value of one or more columns. This is done in the database, which means it does not use the values currently stored on the Instance. The decrement is done using a\n   * ```sql\n   * SET column = column - X\n   * ```\n   * query. To get the correct value after an decrement into the Instance you should do a reload.\n   *\n   * ```js\n   * instance.decrement('number') // decrement number by 1\n   * instance.decrement(['number', 'count'], { by: 2 }) // decrement number and count by 2\n   * instance.decrement({ answer: 42, tries: 1}, { by: 2 }) // decrement answer by 42, and tries by 1.\n   *                                                        // `by` is ignored, since each column has its own value\n   * ```\n   *\n   * @see {@link Model#reload}\n   * @param {String|Array|Object} fields If a string is provided, that column is decremented by the value of `by` given in options. If an array is provided, the same is true for each column. If and object is provided, each column is decremented by the value given\n   * @param {Object} [options]\n   * @param {Integer} [options.by=1] The number to decrement by\n   * @param {Boolean} [options.silent=false] If true, the updatedAt timestamp will not be updated.\n   * @param {Function} [options.logging=false] A function that gets executed while running the query to log the sql.\n   * @param {Transaction} [options.transaction]\n   * @param  {String}       [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)\n   *\n   * @return {Promise}\n   */\n  decrement(fields, options) {\n    options = _.defaults({ increment: false }, options, {\n      by: 1\n    });\n\n    return this.increment(fields, options);\n  }\n\n  /**\n   * Check whether this and `other` Instance refer to the same row\n   *\n   * @param {Model} other\n   * @return {Boolean}\n   */\n  equals(other) {\n\n    if (!other || !other.constructor) {\n      return false;\n    }\n\n    if (!(other instanceof this.constructor)) {\n      return false;\n    }\n\n    return Utils._.every(this.constructor.primaryKeyAttributes, attribute => this.get(attribute, {raw: true}) === other.get(attribute, {raw: true}));\n  }\n\n  /**\n   * Check if this is equal to one of `others` by calling equals\n   *\n   * @param {Array} others\n   * @return {Boolean}\n   */\n  equalsOneOf(others) {\n    return _.some(others, other => this.equals(other));\n  }\n\n  setValidators(attribute, validators) {\n    this.validators[attribute] = validators;\n  }\n\n  /**\n   * Convert the instance to a JSON representation. Proxies to calling `get` with no keys. This means get all values gotten from the DB, and apply all custom getters.\n   *\n   * @see {@link Model#get}\n   * @return {object}\n   */\n  toJSON() {\n    return Utils._.clone(\n      this.get({\n        plain: true\n      })\n    );\n  }\n\n  /**\n   * Creates a 1:m association between this (the source) and the provided target. The foreign key is added on the target.\n   *\n   * @param {Model}               target\n   * @param {object}              [options]\n   * @param {boolean}             [options.hooks=false] Set to true to run before-/afterDestroy hooks when an associated model is deleted because of a cascade. For example if `User.hasOne(Profile, {onDelete: 'cascade', hooks:true})`, the before-/afterDestroy hooks for profile will be called when a user is deleted. Otherwise the profile will be deleted without invoking any hooks\n   * @param {string|object}       [options.as] The alias of this model. If you provide a string, it should be plural, and will be singularized using node.inflection. If you want to control the singular version yourself, provide an object with `plural` and `singular` keys. See also the `name` option passed to `sequelize.define`. If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the association, you should provide the same alias when eager loading and when getting associated models. Defaults to the pluralized name of target\n   * @param {string|object}       [options.foreignKey] The name of the foreign key in the target table or an object representing the type definition for the foreign column (see `Sequelize.define` for syntax). When using an object, you can add a `name` property to set the name of the column. Defaults to the name of source + primary key of source\n   * @param {string}              [options.sourceKey] The name of the field to use as the key for the association in the source table. Defaults to the primary key of the source table\n   * @param {object}              [options.scope] A key/value set that will be used for association create and find defaults on the target. (sqlite not supported for N:M)\n   * @param {string}              [options.onDelete='SET&nbsp;NULL|CASCADE'] SET NULL if foreignKey allows nulls, CASCADE if otherwise\n   * @param {string}              [options.onUpdate='CASCADE']\n   * @param {boolean}             [options.constraints=true] Should on update and on delete constraints be enabled on the foreign key.\n   * @returns {HasMany}\n   * @example\n   * User.hasMany(Profile) // This will add userId to the profile table\n   */\n  static hasMany(target, options) {} // eslint-disable-line\n\n\n  /**\n   * Create an N:M association with a join table. Defining `through` is required.\n   *\n   * @param {Model}               target\n   * @param {object}              options\n   * @param {boolean}             [options.hooks=false] Set to true to run before-/afterDestroy hooks when an associated model is deleted because of a cascade. For example if `User.hasOne(Profile, {onDelete: 'cascade', hooks:true})`, the before-/afterDestroy hooks for profile will be called when a user is deleted. Otherwise the profile will be deleted without invoking any hooks\n   * @param {Model|string|object} options.through The name of the table that is used to join source and target in n:m associations. Can also be a sequelize model if you want to define the junction table yourself and add extra attributes to it.\n   * @param {Model}               [options.through.model] The model used to join both sides of the N:M association.\n   * @param {object}              [options.through.scope] A key/value set that will be used for association create and find defaults on the through model. (Remember to add the attributes to the through model)\n   * @param {boolean}             [options.through.unique=true] If true a unique key will be generated from the foreign keys used (might want to turn this off and create specific unique keys when using scopes)\n   * @param {string|object}       [options.as] The alias of this association. If you provide a string, it should be plural, and will be singularized using node.inflection. If you want to control the singular version yourself, provide an object with `plural` and `singular` keys. See also the `name` option passed to `sequelize.define`. If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the association, you should provide the same alias when eager loading and when getting associated models. Defaults to the pluralized name of target\n   * @param {string|object}       [options.foreignKey] The name of the foreign key in the join table (representing the source model) or an object representing the type definition for the foreign column (see `Sequelize.define` for syntax). When using an object, you can add a `name` property to set the name of the column. Defaults to the name of source + primary key of source\n   * @param {string|object}       [options.otherKey] The name of the foreign key in the join table (representing the target model) or an object representing the type definition for the other column (see `Sequelize.define` for syntax). When using an object, you can add a `name` property to set the name of the column. Defaults to the name of target + primary key of target\n   * @param {object}              [options.scope] A key/value set that will be used for association create and find defaults on the target. (sqlite not supported for N:M)\n   * @param {boolean}             [options.timestamps=sequelize.options.timestamps] Should the join model have timestamps\n   * @param {string}              [options.onDelete='SET&nbsp;NULL|CASCADE'] Cascade if this is a n:m, and set null if it is a 1:m\n   * @param {string}              [options.onUpdate='CASCADE']\n   * @param {boolean}             [options.constraints=true] Should on update and on delete constraints be enabled on the foreign key.\n   * @return {BelongsToMany}\n   * @example\n   * // Automagically generated join model\n   * User.belongsToMany(Project, { through: 'UserProjects' })\n   * Project.belongsToMany(User, { through: 'UserProjects' })\n   *\n   * // Join model with additional attributes\n   * const UserProjects = sequelize.define('UserProjects', {\n   *   started: Sequelize.BOOLEAN\n   * })\n   * User.belongsToMany(Project, { through: UserProjects })\n   * Project.belongsToMany(User, { through: UserProjects })\n   */\n  static belongsToMany(target, options) {} // eslint-disable-line\n\n  /**\n   * Creates an association between this (the source) and the provided target. The foreign key is added on the target.\n   *\n   * @param {Model}           target\n   * @param {object}          [options]\n   * @param {boolean}         [options.hooks=false] Set to true to run before-/afterDestroy hooks when an associated model is deleted because of a cascade. For example if `User.hasOne(Profile, {onDelete: 'cascade', hooks:true})`, the before-/afterDestroy hooks for profile will be called when a user is deleted. Otherwise the profile will be deleted without invoking any hooks\n   * @param {string}          [options.as] The alias of this model, in singular form. See also the `name` option passed to `sequelize.define`. If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the association, you should provide the same alias when eager loading and when getting associated models. Defaults to the singularized name of target\n   * @param {string|object}   [options.foreignKey] The name of the foreign key in the target table or an object representing the type definition for the foreign column (see `Sequelize.define` for syntax). When using an object, you can add a `name` property to set the name of the column. Defaults to the name of source + primary key of source\n   * @param {string}          [options.onDelete='SET&nbsp;NULL|CASCADE'] SET NULL if foreignKey allows nulls, CASCADE if otherwise\n   * @param {string}          [options.onUpdate='CASCADE']\n   * @param {boolean}         [options.constraints=true] Should on update and on delete constraints be enabled on the foreign key.\n   * @returns {HasOne}\n   * @example\n   * User.hasOne(Profile) // This will add userId to the profile table\n   */\n  static hasOne(target, options) {} // eslint-disable-line\n\n\n  /**\n   * Creates an association between this (the source) and the provided target. The foreign key is added on the source.\n   *\n   * @param {Model}           target\n   * @param {object}          [options]\n   * @param {boolean}         [options.hooks=false] Set to true to run before-/afterDestroy hooks when an associated model is deleted because of a cascade. For example if `User.hasOne(Profile, {onDelete: 'cascade', hooks:true})`, the before-/afterDestroy hooks for profile will be called when a user is deleted. Otherwise the profile will be deleted without invoking any hooks\n   * @param {string}          [options.as] The alias of this model, in singular form. See also the `name` option passed to `sequelize.define`. If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the association, you should provide the same alias when eager loading and when getting associated models. Defaults to the singularized name of target\n   * @param {string|object}   [options.foreignKey] The name of the foreign key in the source table or an object representing the type definition for the foreign column (see `Sequelize.define` for syntax). When using an object, you can add a `name` property to set the name of the column. Defaults to the name of target + primary key of target\n   * @param {string}          [options.targetKey] The name of the field to use as the key for the association in the target table. Defaults to the primary key of the target table\n   * @param {string}          [options.onDelete='SET&nbsp;NULL|NO&nbsp;ACTION'] SET NULL if foreignKey allows nulls, NO ACTION if otherwise\n   * @param {string}          [options.onUpdate='CASCADE']\n   * @param {boolean}         [options.constraints=true] Should on update and on delete constraints be enabled on the foreign key.\n   * @returns {BelongsTo}\n   * @example\n   * Profile.belongsTo(User) // This will add userId to the profile table\n   */\n  static belongsTo(target, options) {} // eslint-disable-line\n}\n\n// Aliases\nModel.prototype.updateAttributes = Model.prototype.update;\n\nModel._conformOptions = Model._conformOptions;\nModel._validateIncludedElements = Model._validateIncludedElements;\nModel._expandIncludeAll = Model._expandIncludeAll;\nModel.findByPrimary = Model.findById;\nModel.find = Model.findOne;\nModel.findAndCountAll = Model.findAndCount;\nModel.findOrInitialize = Model.findOrBuild;\nModel.insertOrUpdate = Model.upsert;\n\nUtils._.extend(Model, associationsMixin);\nHooks.applyTo(Model);\n\nmodule.exports = Model;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/model.js\n// module id = 35\n// module chunks = 0","'use strict';\n\nconst Utils = require('./utils');\nconst Promise = require('./promise');\nconst debug = Utils.getLogger().debugContext('hooks');\n\nconst hookTypes = {\n  beforeValidate: {params: 2},\n  afterValidate: {params: 2},\n  validationFailed: {params: 3},\n  beforeCreate: {params: 2},\n  afterCreate: {params: 2},\n  beforeDestroy: {params: 2},\n  afterDestroy: {params: 2},\n  beforeRestore: {params: 2},\n  afterRestore: {params: 2},\n  beforeUpdate: {params: 2},\n  afterUpdate: {params: 2},\n  beforeSave: {params: 2, proxies: ['beforeUpdate', 'beforeCreate']},\n  afterSave: {params: 2, proxies: ['afterUpdate', 'afterCreate']},\n  beforeUpsert: {params: 2},\n  afterUpsert: {params: 2},\n  beforeBulkCreate: {params: 2},\n  afterBulkCreate: {params: 2},\n  beforeBulkDestroy: {params: 1},\n  afterBulkDestroy: {params: 1},\n  beforeBulkRestore: {params: 1},\n  afterBulkRestore: {params: 1},\n  beforeBulkUpdate: {params: 1},\n  afterBulkUpdate: {params: 1},\n  beforeFind: {params: 1},\n  beforeFindAfterExpandIncludeAll: {params: 1},\n  beforeFindAfterOptions: {params: 1},\n  afterFind: {params: 2},\n  beforeCount: {params: 1},\n  beforeDefine: {params: 2, sync: true},\n  afterDefine: {params: 1, sync: true},\n  beforeInit: {params: 2, sync: true},\n  afterInit: {params: 1, sync: true},\n  beforeConnect: {params: 1},\n  afterConnect: {params: 2},\n  beforeSync: {params: 1},\n  afterSync: {params: 1},\n  beforeBulkSync: {params: 1},\n  afterBulkSync: {params: 1}\n};\nexports.hooks = hookTypes;\n\nconst hookAliases = {\n  beforeDelete: 'beforeDestroy',\n  afterDelete: 'afterDestroy',\n  beforeBulkDelete: 'beforeBulkDestroy',\n  afterBulkDelete: 'afterBulkDestroy',\n  beforeConnection: 'beforeConnect'\n};\nexports.hookAliases = hookAliases;\n\n/**\n * get array of current hook and its proxied hooks combined\n * @private\n */\nconst getProxiedHooks = hookType =>\n  hookTypes[hookType].proxies\n    ? hookTypes[hookType].proxies.concat(hookType)\n    : [hookType]\n;\n\nconst Hooks = {\n  replaceHookAliases(hooks) {\n    Utils._.each(hooks, (hooksArray, name) => {\n      // Does an alias for this hook name exist?\n      const realHookName = hookAliases[name];\n      if (realHookName) {\n        // Add the hooks to the actual hook\n        hooks[realHookName] = (hooks[realHookName] || []).concat(hooksArray);\n\n        // Delete the alias\n        delete hooks[name];\n      }\n    });\n\n    return hooks;\n  },\n\n  runHooks(hooks) {\n    if (!hooks) throw new Error('runHooks requires atleast 1 argument');\n\n    const hookArgs = Utils.sliceArgs(arguments, 1);\n    let hookType;\n\n    if (typeof hooks === 'string') {\n      hookType = hooks;\n      hooks = this.options.hooks[hookType] || [];\n      if (this.sequelize) hooks = hooks.concat(this.sequelize.options.hooks[hookType] || []);\n    }\n\n    if (!Array.isArray(hooks)) {\n      hooks = [hooks];\n    }\n\n    // synchronous hooks\n    if (hookTypes[hookType] && hookTypes[hookType].sync) {\n      for (let hook of hooks) {\n        if (typeof hook === 'object') {\n          hook = hook.fn;\n        }\n\n        debug(`running hook(sync) ${hookType}`);\n        hook.apply(this, hookArgs);\n      }\n      return;\n    }\n\n    // asynchronous hooks (default)\n    return Promise.each(hooks, hook => {\n      if (typeof hook === 'object') {\n        hook = hook.fn;\n      }\n\n      debug(`running hook ${hookType}`);\n      return Promise.resolve(hook.apply(this, hookArgs));\n    }).return();\n  },\n\n  hook() {\n    return Hooks.addHook.apply(this, arguments);\n  },\n\n  /**\n   * Add a hook to the model\n   *\n   * @param {String}    hookType\n   * @param {String}    [name]    Provide a name for the hook function. It can be used to remove the hook later or to order hooks based on some sort of priority system in the future.\n   * @param {Function}  fn        The hook function\n   *\n   * @memberOf Sequelize\n   * @memberOf Sequelize.Model\n   */\n  addHook(hookType, name, fn) {\n    if (typeof name === 'function') {\n      fn = name;\n      name = null;\n    }\n\n    debug(`adding hook ${hookType}`);\n    hookType = hookAliases[hookType] || hookType;\n\n    // check for proxies, add them too\n    hookType = getProxiedHooks(hookType);\n\n    Utils._.each(hookType, type => {\n      this.options.hooks[type] = this.options.hooks[type] || [];\n      this.options.hooks[type].push(name ? {name, fn} : fn);\n    });\n\n    return this;\n  },\n\n  /**\n   * Remove hook from the model\n   *\n   * @param {String} hookType\n   * @param {String|Function} name\n   *\n   * @memberOf Sequelize\n   * @memberOf Sequelize.Model\n   */\n  removeHook(hookType, name) {\n    hookType = hookAliases[hookType] || hookType;\n    const isReference = typeof name === 'function' ? true : false;\n\n    if (!this.hasHook(hookType)) {\n      return this;\n    }\n\n    Utils.debug(`removing hook ${hookType}`);\n\n    // check for proxies, add them too\n    hookType = getProxiedHooks(hookType);\n\n    for (const type of hookType) {\n      this.options.hooks[type] = this.options.hooks[type].filter(hook => {\n        if (isReference && typeof hook === 'function') {\n          return hook !== name; // check if same method\n        } else if (!isReference && typeof hook === 'object') {\n          return hook.name !== name;\n        }\n        return true;\n      });\n    }\n\n    return this;\n  },\n\n  /**\n   * Check whether the mode has any hooks of this type\n   *\n   * @param {String}  hookType\n   *\n   * @alias hasHooks\n   * @memberOf Sequelize\n   * @memberOf Sequelize.Model\n   */\n  hasHook(hookType) {\n    return this.options.hooks[hookType] && !!this.options.hooks[hookType].length;\n  }\n};\nHooks.hasHooks = Hooks.hasHook;\n\n\nfunction applyTo(target) {\n  Utils._.mixin(target, Hooks);\n\n  const allHooks = Object.keys(hookTypes).concat(Object.keys(hookAliases));\n  for (const hook of allHooks) {\n    target[hook] = function(name, callback) {\n      return this.addHook(hook, name, callback);\n    };\n  }\n}\nexports.applyTo = applyTo;\n\n/**\n * A hook that is run before validation\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with instance, options\n * @name beforeValidate\n * @memberOf Sequelize.Model\n */\n\n/**\n * A hook that is run after validation\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with instance, options\n * @name afterValidate\n * @memberOf Sequelize.Model\n */\n\n/**\n * A hook that is run when validation fails\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with instance, options, error. Error is the\n * SequelizeValidationError. If the callback throws an error, it will replace the original validation error.\n * @name validationFailed\n * @memberOf Sequelize.Model\n */\n\n/**\n * A hook that is run before creating a single instance\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with attributes, options\n * @name beforeCreate\n * @memberOf Sequelize.Model\n */\n\n/**\n * A hook that is run after creating a single instance\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with attributes, options\n * @name afterCreate\n * @memberOf Sequelize.Model\n */\n\n/**\n * A hook that is run before creating or updating a single instance, It proxies `beforeCreate` and `beforeUpdate`\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with attributes, options\n * @name beforeSave\n * @memberOf Sequelize.Model\n */\n\n/**\n * A hook that is run before upserting\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with attributes, options\n * @name beforeUpsert\n * @memberOf Sequelize.Model\n */\n\n/**\n * A hook that is run after upserting\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with attributes, options\n * @name afterUpsert\n * @memberOf Sequelize.Model\n */\n\n/**\n  * A hook that is run after creating or updating a single instance, It proxies `afterCreate` and `afterUpdate`\n  * @param {String}   name\n  * @param {Function} fn   A callback function that is called with attributes, options\n  * @name afterSave\n  * @memberOf Sequelize.Model\n  */\n\n/**\n * A hook that is run before destroying a single instance\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with instance, options\n *\n * @name beforeDestroy\n * @alias beforeDelete\n * @memberOf Sequelize.Model\n */\n\n/**\n * A hook that is run after destroying a single instance\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with instance, options\n *\n * @name afterDestroy\n * @alias afterDelete\n * @memberOf Sequelize.Model\n */\n\n/**\n * A hook that is run before restoring a single instance\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with instance, options\n *\n * @name beforeRestore\n * @memberOf Sequelize.Model\n */\n\n/**\n * A hook that is run after restoring a single instance\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with instance, options\n *\n * @name afterRestore\n * @memberOf Sequelize.Model\n */\n\n/**\n * A hook that is run before updating a single instance\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with instance, options\n * @name beforeUpdate\n * @memberOf Sequelize.Model\n */\n\n/**\n * A hook that is run after updating a single instance\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with instance, options\n * @name afterUpdate\n * @memberOf Sequelize.Model\n */\n\n/**\n * A hook that is run before creating instances in bulk\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with instances, options\n * @name beforeBulkCreate\n * @memberOf Sequelize.Model\n */\n\n/**\n * A hook that is run after creating instances in bulk\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with instances, options\n * @name afterBulkCreate\n * @memberOf Sequelize.Model\n */\n\n/**\n * A hook that is run before destroying instances in bulk\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with options\n *\n * @name beforeBulkDestroy\n * @alias beforeBulkDelete\n * @memberOf Sequelize.Model\n */\n\n/**\n * A hook that is run after destroying instances in bulk\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with options\n *\n * @name afterBulkDestroy\n * @alias afterBulkDelete\n * @memberOf Sequelize.Model\n */\n\n/**\n * A hook that is run before restoring instances in bulk\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with options\n *\n * @name beforeBulkRestore\n * @memberOf Sequelize.Model\n */\n\n/**\n * A hook that is run after restoring instances in bulk\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with options\n *\n * @name afterBulkRestore\n * @memberOf Sequelize.Model\n */\n\n/**\n * A hook that is run before updating instances in bulk\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with options\n * @name beforeBulkUpdate\n * @memberOf Sequelize.Model\n */\n\n/**\n * A hook that is run after updating instances in bulk\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with options\n * @name afterBulkUpdate\n * @memberOf Sequelize.Model\n */\n\n/**\n * A hook that is run before a find (select) query\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with options\n * @name beforeFind\n * @memberOf Sequelize.Model\n */\n\n/**\n * A hook that is run before a find (select) query, after any { include: {all: ...} } options are expanded\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with options\n * @name beforeFindAfterExpandIncludeAll\n * @memberOf Sequelize.Model\n */\n\n/**\n * A hook that is run before a find (select) query, after all option parsing is complete\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with options\n * @name beforeFindAfterOptions\n * @memberOf Sequelize.Model\n */\n\n/**\n * A hook that is run after a find (select) query\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with instance(s), options\n * @name afterFind\n * @memberOf Sequelize.Model\n */\n\n/**\n * A hook that is run before a count query\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with options\n * @name beforeCount\n * @memberOf Sequelize.Model\n */\n\n/**\n * A hook that is run before a define call\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with attributes, options\n * @name beforeDefine\n * @memberOf Sequelize\n */\n\n/**\n * A hook that is run after a define call\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with factory\n * @name afterDefine\n * @memberOf Sequelize\n */\n\n/**\n * A hook that is run before Sequelize() call\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with config, options\n * @name beforeInit\n * @memberOf Sequelize\n */\n\n/**\n * A hook that is run after Sequelize() call\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with sequelize\n * @name afterInit\n * @memberOf Sequelize\n */\n\n/**\n * A hook that is run before a connection is created\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with config passed to connection\n * @name beforeConnect\n * @memberOf Sequelize\n */\n\n/**\n * A hook that is run after a connection is created\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with the connection object and thye config passed to connection\n * @name afterConnect\n * @memberOf Sequelize\n */\n\n/**\n * A hook that is run before Model.sync call\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with options passed to Model.sync\n * @name beforeSync\n * @memberOf Sequelize\n */\n\n/**\n * A hook that is run after Model.sync call\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with options passed to Model.sync\n * @name afterSync\n * @memberOf Sequelize\n */\n\n/**\n  * A hook that is run before sequelize.sync call\n  * @param {String}   name\n  * @param {Function} fn   A callback function that is called with options passed to sequelize.sync\n  * @name beforeBulkSync\n  * @memberOf Sequelize\n  */\n\n/**\n  * A hook that is run after sequelize.sync call\n  * @param {String}   name\n  * @param {Function} fn   A callback function that is called with options passed to sequelize.sync\n  * @name afterBulkSync\n  * @memberOf Sequelize\n  */\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/hooks.js\n// module id = 36\n// module chunks = 0","module.exports = require(\"tedious\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"tedious\"\n// module id = 37\n// module chunks = 0","'use strict';\n\nconst Utils = require('../../utils');\nconst AbstractQueryGenerator = require('../abstract/query-generator');\n\nconst QueryGenerator = {\n  __proto__: AbstractQueryGenerator,\n  dialect: 'mysql',\n\n  createSchema() {\n    return 'SHOW TABLES';\n  },\n\n  showSchemasQuery() {\n    return 'SHOW TABLES';\n  },\n\n  versionQuery() {\n    return 'SELECT VERSION() as `version`';\n  },\n\n  createTableQuery(tableName, attributes, options) {\n    options = Utils._.extend({\n      engine: 'InnoDB',\n      charset: null,\n      rowFormat: null\n    }, options || {});\n\n    const query = 'CREATE TABLE IF NOT EXISTS <%= table %> (<%= attributes%>) ENGINE=<%= engine %><%= comment %><%= charset %><%= collation %><%= initialAutoIncrement %><%= rowFormat %>';\n    const primaryKeys = [];\n    const foreignKeys = {};\n    const attrStr = [];\n\n    for (const attr in attributes) {\n      if (attributes.hasOwnProperty(attr)) {\n        const dataType = attributes[attr];\n        let match;\n\n        if (Utils._.includes(dataType, 'PRIMARY KEY')) {\n          primaryKeys.push(attr);\n\n          if (Utils._.includes(dataType, 'REFERENCES')) {\n            // MySQL doesn't support inline REFERENCES declarations: move to the end\n            match = dataType.match(/^(.+) (REFERENCES.*)$/);\n            attrStr.push(this.quoteIdentifier(attr) + ' ' + match[1].replace(/PRIMARY KEY/, ''));\n            foreignKeys[attr] = match[2];\n          } else {\n            attrStr.push(this.quoteIdentifier(attr) + ' ' + dataType.replace(/PRIMARY KEY/, ''));\n          }\n        } else if (Utils._.includes(dataType, 'REFERENCES')) {\n          // MySQL doesn't support inline REFERENCES declarations: move to the end\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(this.quoteIdentifier(attr) + ' ' + match[1]);\n          foreignKeys[attr] = match[2];\n        } else {\n          attrStr.push(this.quoteIdentifier(attr) + ' ' + dataType);\n        }\n      }\n    }\n\n    const values = {\n      table: this.quoteTable(tableName),\n      attributes: attrStr.join(', '),\n      comment: options.comment && Utils._.isString(options.comment) ? ' COMMENT ' + this.escape(options.comment) : '',\n      engine: options.engine,\n      charset: options.charset ? ' DEFAULT CHARSET=' + options.charset : '',\n      collation: options.collate ? ' COLLATE ' + options.collate : '',\n      rowFormat: options.rowFormat ? ' ROW_FORMAT=' + options.rowFormat : '',\n      initialAutoIncrement: options.initialAutoIncrement ? ' AUTO_INCREMENT=' + options.initialAutoIncrement : ''\n    };\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\n\n    if (options.uniqueKeys) {\n      Utils._.each(options.uniqueKeys, (columns, indexName) => {\n        if (!columns.singleField) { // If it's a single field its handled in column def, not as an index\n          if (!Utils._.isString(indexName)) {\n            indexName = 'uniq_' + tableName + '_' + columns.fields.join('_');\n          }\n          values.attributes += ', UNIQUE ' + this.quoteIdentifier(indexName) + ' (' + Utils._.map(columns.fields, this.quoteIdentifier).join(', ') + ')';\n        }\n      });\n    }\n\n    if (pkString.length > 0) {\n      values.attributes += ', PRIMARY KEY (' + pkString + ')';\n    }\n\n    for (const fkey in foreignKeys) {\n      if (foreignKeys.hasOwnProperty(fkey)) {\n        values.attributes += ', FOREIGN KEY (' + this.quoteIdentifier(fkey) + ') ' + foreignKeys[fkey];\n      }\n    }\n\n    return Utils._.template(query)(values).trim() + ';';\n  },\n\n  showTablesQuery() {\n    return 'SHOW TABLES;';\n  },\n\n  addColumnQuery(table, key, dataType) {\n    const definition = this.attributeToSQL(dataType, {\n      context: 'addColumn',\n      tableName: table,\n      foreignKey: key\n    });\n    return `ALTER TABLE ${this.quoteTable(table)} ADD ${this.quoteIdentifier(key)} ${definition};`;\n  },\n\n  removeColumnQuery(tableName, attributeName) {\n    return `ALTER TABLE ${this.quoteTable(tableName)} DROP ${this.quoteIdentifier(attributeName)};`;\n  },\n\n  changeColumnQuery(tableName, attributes) {\n    const attrString = [];\n    const constraintString = [];\n\n    for (const attributeName in attributes) {\n      let definition = attributes[attributeName];\n      if (definition.match(/REFERENCES/)) {\n        const fkName = this.quoteIdentifier(tableName + '_' + attributeName + '_foreign_idx');\n        const attrName = this.quoteIdentifier(attributeName);\n        definition = definition.replace(/.+?(?=REFERENCES)/, '');\n        constraintString.push(`${fkName} FOREIGN KEY (${attrName}) ${definition}`);\n      } else {\n        attrString.push('`' + attributeName + '` `' + attributeName + '` ' + definition);\n      }\n    }\n\n    let finalQuery = '';\n    if (attrString.length) {\n      finalQuery += 'CHANGE ' + attrString.join(', ');\n      finalQuery += constraintString.length ? ' ' : '';\n    }\n    if (constraintString.length) {\n      finalQuery += 'ADD CONSTRAINT ' + constraintString.join(', ');\n    }\n\n    return `ALTER TABLE ${this.quoteTable(tableName)} ${finalQuery};`;\n  },\n\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const attrString = [];\n\n    for (const attrName in attributes) {\n      const definition = attributes[attrName];\n      attrString.push('`' + attrBefore + '` `' + attrName + '` ' + definition);\n    }\n\n    return `ALTER TABLE ${this.quoteTable(tableName)} CHANGE ${attrString.join(', ')};`;\n  },\n\n  upsertQuery(tableName, insertValues, updateValues, where, model, options) {\n    options.onDuplicate = 'UPDATE ';\n\n    options.onDuplicate += Object.keys(updateValues).map(key => {\n      key = this.quoteIdentifier(key);\n      return key + '=VALUES(' + key +')';\n    }).join(', ');\n\n    return this.insertQuery(tableName, insertValues, model.rawAttributes, options);\n  },\n\n  deleteQuery(tableName, where, options) {\n    options = options || {};\n\n    const table = this.quoteTable(tableName);\n    if (options.truncate === true) {\n      // Truncate does not allow LIMIT and WHERE\n      return 'TRUNCATE ' + table;\n    }\n\n    where = this.getWhereConditions(where);\n    let limit = '';\n\n    if (Utils._.isUndefined(options.limit)) {\n      options.limit = 1;\n    }\n\n    if (options.limit) {\n      limit = ' LIMIT ' + this.escape(options.limit);\n    }\n\n    let query = 'DELETE FROM ' + table;\n    if (where) query += ' WHERE ' + where;\n    query += limit;\n\n    return query;\n  },\n\n  showIndexesQuery(tableName, options) {\n    return 'SHOW INDEX FROM ' + this.quoteTable(tableName) + ((options || {}).database ? ' FROM `' + options.database + '`' : '');\n  },\n\n  showConstraintsQuery(tableName, constraintName) {\n    let sql = [\n      'SELECT CONSTRAINT_CATALOG AS constraintCatalog,',\n      'CONSTRAINT_NAME AS constraintName,',\n      'CONSTRAINT_SCHEMA AS constraintSchema,',\n      'CONSTRAINT_TYPE AS constraintType,',\n      'TABLE_NAME AS tableName,',\n      'TABLE_SCHEMA AS tableSchema',\n      'from INFORMATION_SCHEMA.TABLE_CONSTRAINTS',\n      `WHERE table_name='${tableName}'`\n    ].join(' ');\n\n    if (constraintName) {\n      sql += ` AND constraint_name = '${constraintName}'`;\n    }\n\n    return sql + ';';\n  },\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(tableName + '_' + indexNameOrAttributes.join('_'));\n    }\n\n    return `DROP INDEX ${this.quoteIdentifier(indexName)} ON ${this.quoteTable(tableName)}`;\n  },\n\n  attributeToSQL(attribute, options) {\n    if (!Utils._.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n\n    let template = attribute.type.toString({ escape: this.escape.bind(this) });\n\n    if (attribute.allowNull === false) {\n      template += ' NOT NULL';\n    }\n\n    if (attribute.autoIncrement) {\n      template += ' auto_increment';\n    }\n\n    // Blobs/texts cannot have a defaultValue\n    if (attribute.type !== 'TEXT' && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ' DEFAULT ' + this.escape(attribute.defaultValue);\n    }\n\n    if (attribute.unique === true) {\n      template += ' UNIQUE';\n    }\n\n    if (attribute.primaryKey) {\n      template += ' PRIMARY KEY';\n    }\n\n    if (attribute.after) {\n      template += ' AFTER ' + this.quoteIdentifier(attribute.after);\n    }\n\n    if (attribute.references) {\n\n      if (options && options.context === 'addColumn' && options.foreignKey) {\n        const attrName = this.quoteIdentifier(options.foreignKey);\n        const fkName = this.quoteIdentifier(`${options.tableName}_${attrName}_foreign_idx`);\n\n        template += `, ADD CONSTRAINT ${fkName} FOREIGN KEY (${attrName})`;\n      }\n\n      template += ' REFERENCES ' + this.quoteTable(attribute.references.model);\n\n      if (attribute.references.key) {\n        template += ' (' + this.quoteIdentifier(attribute.references.key) + ')';\n      } else {\n        template += ' (' + this.quoteIdentifier('id') + ')';\n      }\n\n      if (attribute.onDelete) {\n        template += ' ON DELETE ' + attribute.onDelete.toUpperCase();\n      }\n\n      if (attribute.onUpdate) {\n        template += ' ON UPDATE ' + attribute.onUpdate.toUpperCase();\n      }\n    }\n\n    return template;\n  },\n\n  attributesToSQL(attributes, options) {\n    const result = {};\n\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n\n    return result;\n  },\n\n  quoteIdentifier(identifier) {\n    if (identifier === '*') return identifier;\n    return Utils.addTicks(Utils.removeTicks(identifier, '`'), '`');\n  },\n\n  /**\n   * Generates an SQL query that returns all foreign keys of a table.\n   *\n   * @param  {String} tableName  The name of the table.\n   * @param  {String} schemaName The name of the schema.\n   * @return {String}            The generated sql query.\n   * @private\n   */\n  getForeignKeysQuery(tableName, schemaName) {\n    return \"SELECT CONSTRAINT_NAME as constraint_name FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE where TABLE_NAME = '\" + tableName + /* jshint ignore: line */\n      \"' AND CONSTRAINT_NAME!='PRIMARY' AND CONSTRAINT_SCHEMA='\" + schemaName + \"' AND REFERENCED_TABLE_NAME IS NOT NULL;\"; /* jshint ignore: line */\n  },\n\n  /**\n   * Generates an SQL query that returns the foreign key constraint of a given column.\n   *\n   * @param  {String} tableName  The name of the table.\n   * @param  {String} columnName The name of the column.\n   * @return {String}            The generated sql query.\n   * @private\n   */\n  getForeignKeyQuery(table, columnName) {\n    let tableName = table.tableName || table;\n    if (table.schema) {\n      tableName = table.schema + '.' + tableName;\n    }\n    return 'SELECT CONSTRAINT_NAME as constraint_name'\n      + ' FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE'\n      + ' WHERE (REFERENCED_TABLE_NAME = ' + wrapSingleQuote(tableName)\n      + ' AND REFERENCED_COLUMN_NAME = ' + wrapSingleQuote(columnName)\n      + ') OR (TABLE_NAME = ' + wrapSingleQuote(tableName)\n      + ' AND COLUMN_NAME = ' + wrapSingleQuote(columnName)\n      + ')';\n  },\n\n  /**\n   * Generates an SQL query that removes a foreign key from a table.\n   *\n   * @param  {String} tableName  The name of the table.\n   * @param  {String} foreignKey The name of the foreign key constraint.\n   * @return {String}            The generated sql query.\n   * @private\n   */\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return 'ALTER TABLE ' + this.quoteTable(tableName) + ' DROP FOREIGN KEY ' + this.quoteIdentifier(foreignKey) + ';';\n  }\n};\n\n// private methods\nfunction wrapSingleQuote(identifier) {\n  return Utils.addTicks(identifier, '\\'');\n}\n\nmodule.exports = QueryGenerator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/dialects/mysql/query-generator.js\n// module id = 38\n// module chunks = 0","import qiniu from './qiniu'\n\nexport default qiniu;\n\n\n\n// WEBPACK FOOTER //\n// ./server/lib/publish/index.js","import __ from '../constants'\nimport models from '../models'\n\nexport default class {\n  constructor() {\n    this.url = '/page/:id';\n  }\n\n  async delete(ctx) {\n    let { id } = ctx.params;\n\n    await models.pages.update(\n      {\n        is_delete: 1\n      },\n      {\n        where: {\n          id: id\n        }\n      }\n    );\n\n    await models.changelog.create({\n      action: 3,\n      page_id: id,\n      items: null,\n      create_by: ctx.state.user.id\n    });\n\n    ctx.body = {\n      message: \"Delete success\"\n    };\n  }\n\n  async get(ctx) {\n    let { id } = ctx.params;\n\n    let result = await models.pages.findAll(\n      {\n        where: {\n          is_delete: 0,\n          id: id\n        }\n      }\n    );\n\n    let page = result[0];\n    if (!page)\n      throw {\n        status: 404,\n        name: \"PAGES_NOT_FOUND\",\n        message: \"page is not found\"\n      };\n\n    try {\n      if (page.items) page.items = JSON.parse(page.items);\n      if (page.config) page.config = JSON.parse(page.config);\n    } catch (error) {\n      throw {\n        status: 500,\n        name: \"JSON_PARSE_ERROR\",\n        message: \"json parse error\"\n      };\n    }\n\n    ctx.body = page;\n  }\n\n  async put(ctx) {\n    let { id } = ctx.params;\n    let { body } = ctx.request;\n    let change = Object.create(null);\n    let count = [\"title\", \"config\", \"items\"].reduce((count, name) => {\n      if (!(name in body)) return count;\n      change[name] = body[name];\n      return count + 1;\n    }, 0);\n\n    if (count === 0)\n      throw {\n        status: 400,\n        name: \"ERR\",\n        message: \"require `title` or/and `items` in request body\"\n      };\n\n    change.title = change.title.trim();\n\n    if (!change.title)\n      throw { status: 400, name: \"ERROR_PARAMS\", message: \"Title 不能为空\" };\n\n    if (\"items\" in change) {\n      change.items = JSON.stringify(change.items);\n      if (change.items.length > __.VALUE_MAX_LENGTH) throw __.VALUE_TOO_LONG;\n    }\n    if (\"config\" in change) {\n      change.config = JSON.stringify(change.config);\n    }\n\n    let [page] = await models.pages.findAll({\n      attributes: ['is_delete', 'items'],\n      where: {\n        id: id\n      }\n    })\n\n    if (!page || page.is_delete)\n        throw {\n          status: 404,\n          name: \"PAGE_NOT_FOUND\",\n          message: \"page is not found\"\n        };\n\n    await models.pages.update(\n      change,\n      {\n        where: {\n          id: id\n        }\n      }\n    );\n\n    let changed = [\"title\", \"config\", \"items\"].reduce((changed, name) => {\n      return page[name] !== change[name] ? changed + 1 : changed;\n    }, 0);\n    if (changed > 0) {\n      await models.changelog.create({\n        action: 2,\n        page_id: id,\n        items: change.items,\n        create_by: ctx.state.user.id\n      });\n    }\n\n    ctx.body = {\n      message: \"Save success\"\n    };\n  }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./server/controllers/page.js","export default {\n  VALUE_MAX_LENGTH: 10240,\n  VALUE_TOO_LONG: {\n                    status: 400,\n                    message: 'Value 不能大于 10240 个字符',\n                    name: 'VALUE_TOO_LONG'\n                  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./server/constants.js","module.exports = require(\"koa-passport\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"koa-passport\"\n// module id = 42\n// module chunks = 0","import Koa from 'koa'\nimport { Nuxt, Builder } from 'nuxt'\nimport apiRoute from './lib/api'\nimport models from './models'\n\nconst app = new Koa()\nconst host = process.env.HOST || '127.0.0.1'\nconst port = process.env.PORT || 3000\n\napp.keys = ['i-love-piper']\napp.use(require('koa-session')({}, app))\napp.use(require('koa-bodyparser')())\n\n// authentication\nrequire('./lib/passport')\nconst passport = require('koa-passport')\napp.use(passport.initialize())\napp.use(passport.session())\n\nconst router = require('koa-router')()\n\nrouter.get('/auth/github',\n  passport.authenticate('github')\n)\n\nrouter.get('/auth/github/callback',\n  passport.authenticate('github', {\n    successRedirect: '/',\n    // TODO: login failure page\n    failureRedirect: '/login'\n  })\n)\n\napp.use(router.routes())\napp.use(apiRoute.routes())\n\napp.use(ctx => {\n  ctx.status = 200 // koa defaults to 404 when it sees that status is unset\n\n  return new Promise((resolve, reject) => {\n    ctx.res.on('close', resolve)\n    ctx.res.on('finish', resolve)\n    nuxt.render(ctx.req, ctx.res, promise => {\n      // nuxt.render passes a rejected promise into callback on error.\n      promise.then(resolve).catch(reject)\n    })\n  })\n})\n\n// Import and Set Nuxt.js options\nlet config = require('../nuxt.config.js')\nconfig.dev = !(app.env === 'production')\n\n// Instantiate nuxt.js\nconst nuxt = new Nuxt(config)\n\n// Build in development\nif (config.dev) {\n  const builder = new Builder(nuxt)\n  builder.build().catch(e => {\n    console.error(e) // eslint-disable-line no-console\n    process.exit(1)\n  })\n}\n\nmodels.sequelize.sync().then(function(){\n  app.listen(port, host)\n  console.log('Server listening on ' + host + ':' + port) // eslint-disable-line no-console\n}).catch(function(err){\n  console.error(new Error(err))\n});\n\n\n\n// WEBPACK FOOTER //\n// ./server/index.js","module.exports = require(\"koa\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"koa\"\n// module id = 44\n// module chunks = 0","module.exports = require(\"nuxt\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"nuxt\"\n// module id = 45\n// module chunks = 0","import KoaRouter from 'koa-router'\nimport fs from 'fs'\nimport path from 'path'\n\nimport changelogs from '../controllers/changelogs'\nimport count from '../controllers/count'\nimport files from '../controllers/files'\nimport page from '../controllers/page'\nimport pages from '../controllers/pages'\nimport publish from '../controllers/publish'\nimport users from '../controllers/users'\n\nconst apiRouter = new KoaRouter({ prefix: '/api' });\n\n[changelogs, count, files, page, pages, publish, users].forEach(function(klass) {\n  let controller = new klass();\n  for (let method of [ 'options', 'get', 'post', 'delete', 'put' ]) {\n    if (method in controller) {\n      // apiRouter[method](controller.url, async (ctx) => {\n      //   if (ctx.isAuthenticated()) {\n      //     return await controller[method](ctx)\n      //   } else {\n      //     throw {\n      //       status: 401,\n      //       name: 'NOT_LOGIN',\n      //       message: 'not login'\n      //     }\n      //   }\n      // });\n      // TODO: ctx.isAuthenticated\n      apiRouter[method](controller.url, async (ctx) => await controller[method](ctx));\n    }\n  }\n});\n\napiRouter.get('/logout', (ctx) => {\n  ctx.logout()\n  ctx.body = {\n    message: 'success'\n  }\n})\n\nexport default apiRouter\n\n\n\n// WEBPACK FOOTER //\n// ./server/lib/api.js","module.exports = require(\"regenerator-runtime\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"regenerator-runtime\"\n// module id = 47\n// module chunks = 0","import models from '../models'\n\nexport default class {\n  constructor() {\n    this.url = '/changelogs';\n  }\n\n  async get(ctx) {\n    let { page, size, title, action } = ctx.query;\n    page = parseInt(page, 10)\n    size = parseInt(size, 10)\n    let start = (page - 1) * size;\n    let limit = size;\n    let where = {};\n    if (title) {\n      where['$page.title$'] = {\n        $like: `%${title}%`\n      }\n    }\n    if (action && action != 0) {\n      where['action'] = action\n    }\n\n    let result = await models.changelog.findAndCountAll({\n      attributes: ['action', 'create_at'],\n      include: [\n        {\n          model: models.pages,\n          attributes: ['title']\n        },\n        {\n          model: models.users,\n          attributes: ['name']\n        }\n      ],\n      offset: start,\n      limit: limit,\n      where: where,\n      order: [['create_at', 'DESC']]\n    });\n\n    ctx.body = {\n      total: result.count,\n      page: page,\n      size: size,\n      data: result.rows\n    }\n  }\n\n};\n\n\n\n// WEBPACK FOOTER //\n// ./server/controllers/changelogs.js","'use strict';\n\n/**\n  * The entry point.\n  *\n  * @module Sequelize\n  */\nmodule.exports = require('./lib/sequelize');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/index.js\n// module id = 49\n// module chunks = 0","'use strict';\n\nconst url = require('url');\nconst Path = require('path');\nconst retry = require('retry-as-promised');\nconst clsBluebird = require('cls-bluebird');\nconst Utils = require('./utils');\nconst Model = require('./model');\nconst DataTypes = require('./data-types');\nconst Deferrable = require('./deferrable');\nconst ModelManager = require('./model-manager');\nconst QueryInterface = require('./query-interface');\nconst Transaction = require('./transaction');\nconst QueryTypes = require('./query-types');\nconst sequelizeErrors = require('./errors');\nconst Promise = require('./promise');\nconst Hooks = require('./hooks');\nconst Association = require('./associations/index');\nconst Validator = require('./utils/validator-extras').validator;\nconst _ = require('lodash');\n\n/**\n * This is the main class, the entry point to sequelize. To use it, you just need to import sequelize:\n *\n * ```js\n * const Sequelize = require('sequelize');\n * ```\n *\n * In addition to sequelize, the connection library for the dialect you want to use should also be installed in your project. You don't need to import it however, as sequelize will take care of that.\n */\nclass Sequelize {\n\n  /**\n   * Instantiate sequelize with name of database, username and password\n   *\n   * #### Example usage\n   *\n   * ```javascript\n   * // without password and options\n   * const sequelize = new Sequelize('database', 'username')\n   *\n   * // without options\n   * const sequelize = new Sequelize('database', 'username', 'password')\n   *\n   * // without password / with blank password\n   * const sequelize = new Sequelize('database', 'username', null, {})\n   *\n   * // with password and options\n   * const sequelize = new Sequelize('my_database', 'john', 'doe', {})\n   *\n   * // with database, username, and password in the options object\n   * const sequelize = new Sequelize({ database, username, password });\n   *\n   * // with uri\n   * const sequelize = new Sequelize('mysql://localhost:3306/database', {})\n   * ```\n   *\n   * @param {String}   [database] The name of the database\n   * @param {String}   [username=null] The username which is used to authenticate against the database.\n   * @param {String}   [password=null] The password which is used to authenticate against the database. Supports SQLCipher encryption for SQLite.\n   * @param {Object}   [options={}] An object with options.\n   * @param {String}   [options.host='localhost'] The host of the relational database.\n   * @param {Integer}  [options.port=] The port of the relational database.\n   * @param {String}   [options.username=null] The username which is used to authenticate against the database.\n   * @param {String}   [options.password=null] The password which is used to authenticate against the database.\n   * @param {String}   [options.database=null] The name of the database\n   * @param {String}   [options.dialect] The dialect of the database you are connecting to. One of mysql, postgres, sqlite and mssql.\n   * @param {String}   [options.dialectModulePath=null] If specified, load the dialect library from this path. For example, if you want to use pg.js instead of pg when connecting to a pg database, you should specify 'pg.js' here\n   * @param {Object}   [options.dialectOptions] An object of additional options, which are passed directly to the connection library\n   * @param {String}   [options.storage] Only used by sqlite. Defaults to ':memory:'\n   * @param {String}   [options.protocol='tcp'] The protocol of the relational database.\n   * @param {Object}   [options.define={}] Default options for model definitions. See sequelize.define for options\n   * @param {Object}   [options.query={}] Default options for sequelize.query\n   * @param {Object}   [options.set={}] Default options for sequelize.set\n   * @param {Object}   [options.sync={}] Default options for sequelize.sync\n   * @param {String}   [options.timezone='+00:00'] The timezone used when converting a date from the database into a JavaScript date. The timezone is also used to SET TIMEZONE when connecting to the server, to ensure that the result of NOW, CURRENT_TIMESTAMP and other time related functions have in the right timezone. For best cross platform performance use the format +/-HH:MM. Will also accept string versions of timezones used by moment.js (e.g. 'America/Los_Angeles'); this is useful to capture daylight savings time changes.\n   * @param {Function} [options.logging=console.log] A function that gets executed every time Sequelize would log something.\n   * @param {Boolean}  [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).\n   * @param {Boolean}  [options.omitNull=false] A flag that defines if null values should be passed to SQL queries or not.\n   * @param {Boolean}  [options.native=false] A flag that defines if native library shall be used or not. Currently only has an effect for postgres\n   * @param {Boolean}  [options.replication=false] Use read / write replication. To enable replication, pass an object, with two properties, read and write. Write should be an object (a single server for handling writes), and read an array of object (several servers to handle reads). Each read/write server can have the following properties: `host`, `port`, `username`, `password`, `database`\n   * @param {Object}   [options.pool={}] Should sequelize use a connection pool. Default is true\n   * @param {Integer}  [options.pool.max] Maximum number of connection in pool. Default is 5\n   * @param {Integer}  [options.pool.min] Minimum number of connection in pool. Default is 0\n   * @param {Integer}  [options.pool.idle] The maximum time, in milliseconds, that a connection can be idle before being released\n   * @param {Integer}  [options.pool.acquire] The maximum time, in milliseconds, that pool will try to get connection before throwing error\n   * @param {Function} [options.pool.validate] A function that validates a connection. Called with client. The default function checks that client is an object, and that its state is not disconnected\n   * @param {Integer}  [options.pool.evict] The time interval, in milliseconds, for evicting stale connections. The default value is 0, which disables this feature.\n   * @param {Boolean}  [options.quoteIdentifiers=true] Set to `false` to make table names and attributes case-insensitive on Postgres and skip double quoting of them.  WARNING: Setting this to false may expose vulnerabilities and is not reccomended!\n   * @param {String}   [options.transactionType='DEFERRED'] Set the default transaction type. See `Sequelize.Transaction.TYPES` for possible options. Sqlite only.\n   * @param {String}   [options.isolationLevel] Set the default transaction isolation level. See `Sequelize.Transaction.ISOLATION_LEVELS` for possible options.\n   * @param {Object}   [options.retry] Set of flags that control when a query is automatically retried.\n   * @param {Array}    [options.retry.match] Only retry a query if the error matches one of these strings.\n   * @param {Integer}  [options.retry.max] How many times a failing query is automatically retried.  Set to 0 to disable retrying on SQL_BUSY error.\n   * @param {Boolean}  [options.typeValidation=false] Run built in type validators on insert and update, e.g. validate that arguments passed to integer fields are integer-like.\n   */\n  constructor(database, username, password, options) {\n    let config;\n\n    if (arguments.length === 1 && typeof database === 'object') {\n      // new Sequelize({ ... options })\n      options = database;\n      config = _.pick(options, 'host', 'port', 'database', 'username', 'password');\n    } else if (arguments.length === 1 && typeof database === 'string' || arguments.length === 2 && typeof username === 'object') {\n      // new Sequelize(URI, { ... options })\n\n      config = {};\n      options = username || {};\n\n      const urlParts = url.parse(arguments[0]);\n\n      options.dialect = urlParts.protocol.replace(/:$/, '');\n      options.host = urlParts.hostname;\n\n      if (options.dialect === 'sqlite' && urlParts.pathname && urlParts.pathname.indexOf('/:memory') !== 0) {\n        const path = Path.join(options.host, urlParts.pathname);\n        options.storage = options.storage || path;\n      }\n\n      if (urlParts.pathname) {\n        config.database = urlParts.pathname.replace(/^\\//, '');\n      }\n\n      if (urlParts.port) {\n        options.port = urlParts.port;\n      }\n\n      if (urlParts.auth) {\n        const authParts = urlParts.auth.split(':');\n\n        config.username = authParts[0];\n\n        if (authParts.length > 1)\n          config.password = authParts.slice(1).join(':');\n      }\n    } else {\n      // new Sequelize(database, username, password, { ... options })\n      options = options || {};\n      config = {database, username, password};\n    }\n\n    Sequelize.runHooks('beforeInit', config, options);\n\n    this.options = Utils._.extend({\n      dialect: null,\n      dialectModulePath: null,\n      host: 'localhost',\n      protocol: 'tcp',\n      define: {},\n      query: {},\n      sync: {},\n      timezone:'+00:00',\n      logging: console.log,\n      omitNull: false,\n      native: false,\n      replication: false,\n      ssl: undefined,\n      pool: {},\n      quoteIdentifiers: true,\n      hooks: {},\n      retry: {max: 5, match: ['SQLITE_BUSY: database is locked']},\n      transactionType: Transaction.TYPES.DEFERRED,\n      isolationLevel: null,\n      databaseVersion: 0,\n      typeValidation: false,\n      benchmark: false\n    }, options || {});\n\n    if (!this.options.dialect) {\n      throw new Error('Dialect needs to be explicitly supplied as of v4.0.0');\n    }\n\n    if (this.options.dialect === 'postgresql') {\n      this.options.dialect = 'postgres';\n    }\n\n    if (this.options.dialect === 'sqlite' && this.options.timezone !== '+00:00') {\n      throw new Error('Setting a custom timezone is not supported by SQLite, dates are always returned as UTC. Please remove the custom timezone parameter.');\n    }\n\n    if (this.options.logging === true) {\n      Utils.deprecate('The logging-option should be either a function or false. Default: console.log');\n      this.options.logging = console.log;\n    }\n\n    this.options.hooks = this.replaceHookAliases(this.options.hooks);\n\n    if (['', null, false].indexOf(config.password) > -1 || typeof config.password === 'undefined') {\n      config.password = null;\n    }\n\n    this.config = {\n      database: config.database,\n      username: config.username,\n      password: config.password,\n      host: config.host || this.options.host,\n      port: config.port || this.options.port,\n      pool: this.options.pool,\n      protocol: this.options.protocol,\n      native: this.options.native,\n      ssl: this.options.ssl,\n      replication: this.options.replication,\n      dialectModulePath: this.options.dialectModulePath,\n      keepDefaultTimezone: this.options.keepDefaultTimezone,\n      dialectOptions: this.options.dialectOptions\n    };\n\n    let Dialect;\n    // Requiring the dialect in a switch-case to keep the\n    // require calls static. (Browserify fix)\n    switch (this.getDialect()) {\n      case 'mssql':\n        Dialect = require('./dialects/mssql');\n        break;\n      case 'mysql':\n        Dialect = require('./dialects/mysql');\n        break;\n      case 'postgres':\n        Dialect = require('./dialects/postgres');\n        break;\n      case 'sqlite':\n        Dialect = require('./dialects/sqlite');\n        break;\n      default:\n        throw new Error('The dialect ' + this.getDialect() + ' is not supported. Supported dialects: mssql, mysql, postgres, and sqlite.');\n    }\n\n    this.dialect = new Dialect(this);\n    this.dialect.QueryGenerator.typeValidation = options.typeValidation;\n\n    this.queryInterface = new QueryInterface(this);\n\n    /**\n     * Models are stored here under the name given to `sequelize.define`\n     */\n    this.models = {};\n    this.modelManager = new ModelManager(this);\n    this.connectionManager = this.dialect.connectionManager;\n\n    this.importCache = {};\n\n    this.test = {\n      _trackRunningQueries: false,\n      _runningQueries: 0,\n      trackRunningQueries() {\n        this._trackRunningQueries = true;\n      },\n      verifyNoRunningQueries() {\n        if (this._runningQueries > 0) throw new Error('Expected 0 running queries. '+this._runningQueries+' queries still running');\n      }\n    };\n\n    Sequelize.runHooks('afterInit', this);\n  }\n\n  refreshTypes() {\n    this.connectionManager.refreshTypeParser(DataTypes);\n  }\n\n  /**\n   * Returns the specified dialect.\n   *\n   * @return {String} The specified dialect.\n   */\n  getDialect() {\n    return this.options.dialect;\n  }\n\n  /**\n   * Returns an instance of QueryInterface.\n\n   * @method getQueryInterface\n   * @memberOf Sequelize\n   * @return {QueryInterface} An instance (singleton) of QueryInterface.\n   */\n  getQueryInterface() {\n    this.queryInterface = this.queryInterface || new QueryInterface(this);\n    return this.queryInterface;\n  }\n\n  /**\n   * Define a new model, representing a table in the DB.\n   *\n   * The table columns are defined by the object that is given as the second argument. Each key of the object represents a column\n   *\n   * @param {String} modelName The name of the model. The model will be stored in `sequelize.models` under this name\n   * @param {Object} attributes An object, where each attribute is a column of the table. See {@link Model.init}\n   * @param {Object} [options] These options are merged with the default define options provided to the Sequelize constructor and passed to Model.init()\n   *\n   * @see {@link Model.init} for a more comprehensive specification of the `options` and `attributes` objects.\n   * @see <a href=\"../manual/tutorial/models-definition.html\">The manual section about defining models</a>\n   * @see {@link DataTypes} For a list of possible data types\n   *\n   * @return {Model}\n   *\n   * @example\n   * sequelize.define('modelName', {\n   *     columnA: {\n   *         type: Sequelize.BOOLEAN,\n   *         validate: {\n   *           is: [\"[a-z]\",'i'],        // will only allow letters\n   *           max: 23,                  // only allow values <= 23\n   *           isIn: {\n   *             args: [['en', 'zh']],\n   *             msg: \"Must be English or Chinese\"\n   *           }\n   *         },\n   *         field: 'column_a'\n   *         // Other attributes here\n   *     },\n   *     columnB: Sequelize.STRING,\n   *     columnC: 'MY VERY OWN COLUMN TYPE'\n   * })\n   *\n   * sequelize.models.modelName // The model will now be available in models under the name given to define\n   */\n  define(modelName, attributes, options) { // testhint options:none\n    options = options || {};\n\n    options.modelName = modelName;\n    options.sequelize = this;\n\n    const model = class extends Model {};\n\n    model.init(attributes, options);\n\n\n    return model;\n  }\n\n  /**\n   * Fetch a Model which is already defined\n   *\n   * @param {String} modelName The name of a model defined with Sequelize.define\n   * @throws Will throw an error if the model is not defined (that is, if sequelize#isDefined returns false)\n   * @return {Model}\n   */\n  model(modelName) {\n    if (!this.isDefined(modelName)) {\n      throw new Error(modelName + ' has not been defined');\n    }\n\n    return this.modelManager.getModel(modelName);\n  }\n\n  /**\n   * Checks whether a model with the given name is defined\n   *\n   * @param {String} modelName The name of a model defined with Sequelize.define\n   * @return {Boolean}\n   */\n  isDefined(modelName) {\n    const models = this.modelManager.models;\n    return models.filter(model => model.name === modelName).length !== 0;\n  }\n\n  /**\n   * Imports a model defined in another file\n   *\n   * Imported models are cached, so multiple calls to import with the same path will not load the file multiple times\n   *\n   * See https://github.com/sequelize/express-example for a short example of how to define your models in separate files so that they can be imported by sequelize.import\n   * @param {String} path The path to the file that holds the model you want to import. If the part is relative, it will be resolved relatively to the calling file\n   * @return {Model}\n   */\n  import(path) {\n    // is it a relative path?\n    if (Path.normalize(path) !== Path.resolve(path)) {\n      // make path relative to the caller\n      const callerFilename = Utils.stack()[1].getFileName();\n      const callerPath = Path.dirname(callerFilename);\n\n      path = Path.resolve(callerPath, path);\n    }\n\n    if (!this.importCache[path]) {\n      let defineCall = arguments.length > 1 ? arguments[1] : require(path);\n      if (typeof defineCall === 'object') {\n        // ES6 module compatability\n        defineCall = defineCall.default;\n      }\n      this.importCache[path] = defineCall(this, DataTypes);\n    }\n\n    return this.importCache[path];\n  }\n\n  /**\n   * Execute a query on the DB, with the possibility to bypass all the sequelize goodness.\n   *\n   * By default, the function will return two arguments: an array of results, and a metadata object, containing number of affected rows etc. Use `.spread` to access the results.\n   *\n   * If you are running a type of query where you don't need the metadata, for example a `SELECT` query, you can pass in a query type to make sequelize format the results:\n   *\n   * ```js\n   * sequelize.query('SELECT...').spread((results, metadata) => {\n   *   // Raw query - use spread\n   * });\n   *\n   * sequelize.query('SELECT...', { type: sequelize.QueryTypes.SELECT }).then(results => {\n   *   // SELECT query - use then\n   * })\n   * ```\n   *\n   * @method query\n   * @param {String}          sql\n   * @param {Object}          [options={}] Query options.\n   * @param {Boolean}         [options.raw] If true, sequelize will not try to format the results of the query, or build an instance of a model from the result\n   * @param {Transaction}     [options.transaction=null] The transaction that the query should be executed under\n   * @param {QueryTypes}      [options.type='RAW'] The type of query you are executing. The query type affects how results are formatted before they are passed back. The type is a string, but `Sequelize.QueryTypes` is provided as convenience shortcuts.\n   * @param {Boolean}         [options.nest=false] If true, transforms objects with `.` separated property names into nested objects using [dottie.js](https://github.com/mickhansen/dottie.js). For example { 'user.username': 'john' } becomes { user: { username: 'john' }}. When `nest` is true, the query type is assumed to be `'SELECT'`, unless otherwise specified\n   * @param {Boolean}         [options.plain=false] Sets the query type to `SELECT` and return a single row\n   * @param {Object|Array}    [options.replacements] Either an object of named parameter replacements in the format `:param` or an array of unnamed replacements to replace `?` in your SQL.\n   * @param {Object|Array}    [options.bind] Either an object of named bind parameter in the format `_param` or an array of unnamed bind parameter to replace `$1, $2, ...` in your SQL.\n   * @param {Boolean}         [options.useMaster=false] Force the query to use the write pool, regardless of the query type.\n   * @param {Function}        [options.logging=false] A function that gets executed while running the query to log the sql.\n   * @param {new Model()}       [options.instance] A sequelize instance used to build the return instance\n   * @param {Model}           [options.model] A sequelize model used to build the returned model instances (used to be called callee)\n   * @param {Object}          [options.retry] Set of flags that control when a query is automatically retried.\n   * @param {Array}           [options.retry.match] Only retry a query if the error matches one of these strings.\n   * @param {Integer}         [options.retry.max] How many times a failing query is automatically retried.\n   * @param {String}          [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)\n   * @param {Boolean}         [options.supportsSearchPath] If false do not prepend the query with the search_path (Postgres only)\n   * @param {Boolean}          [options.mapToModel=false] Map returned fields to model's fields if `options.model` or `options.instance` is present. Mapping will occur before building the model instance.\n   * @param {Object}          [options.fieldMap] Map returned fields to arbitrary names for `SELECT` query type.\n   *\n   * @return {Promise}\n   *\n   * @see {@link Model.build} for more information about instance option.\n   */\n\n  query(sql, options) {\n    let bindParameters;\n\n    return Promise.try(() => {\n      options = _.assign({}, this.options.query, options);\n\n      if (options.instance && !options.model) {\n        options.model = options.instance.constructor;\n      }\n\n      // map raw fields to model attributes\n      if (options.mapToModel) {\n        options.fieldMap = _.get(options, 'model.fieldAttributeMap', {});\n      }\n\n      if (typeof sql === 'object') {\n        if (sql.values !== undefined) {\n          if (options.replacements !== undefined) {\n            throw new Error('Both `sql.values` and `options.replacements` cannot be set at the same time');\n          }\n          options.replacements = sql.values;\n        }\n\n        if (sql.bind !== undefined) {\n          if (options.bind !== undefined) {\n            throw new Error('Both `sql.bind` and `options.bind` cannot be set at the same time');\n          }\n          options.bind = sql.bind;\n        }\n\n        if (sql.query !== undefined) {\n          sql = sql.query;\n        }\n      }\n\n      sql = sql.trim();\n\n      if (!options.instance && !options.model) {\n        options.raw = true;\n      }\n\n      if (options.replacements && options.bind) {\n        throw new Error('Both `replacements` and `bind` cannot be set at the same time');\n      }\n\n      if (options.replacements) {\n        if (Array.isArray(options.replacements)) {\n          sql = Utils.format([sql].concat(options.replacements), this.options.dialect);\n        } else {\n          sql = Utils.formatNamedParameters(sql, options.replacements, this.options.dialect);\n        }\n      }\n\n      if (options.bind) {\n        const bindSql = this.dialect.Query.formatBindParameters(sql, options.bind, this.options.dialect);\n        sql = bindSql[0];\n        bindParameters = bindSql[1];\n      }\n\n      options = _.defaults(options, {\n        logging: this.options.hasOwnProperty('logging') ? this.options.logging : console.log,\n        searchPath: this.options.hasOwnProperty('searchPath') ? this.options.searchPath : 'DEFAULT'\n      });\n\n      if (options.transaction === undefined && Sequelize._cls) {\n        options.transaction = Sequelize._cls.get('transaction');\n      }\n\n      if (!options.type) {\n        if (options.model || options.nest || options.plain) {\n          options.type = QueryTypes.SELECT;\n        } else {\n          options.type = QueryTypes.RAW;\n        }\n      }\n\n      if (options.transaction && options.transaction.finished) {\n        const error = new Error(options.transaction.finished+' has been called on this transaction('+options.transaction.id+'), you can no longer use it. (The rejected query is attached as the \\'sql\\' property of this error)');\n        error.sql = sql;\n        return Promise.reject(error);\n      }\n\n      if (this.test._trackRunningQueries) {\n        this.test._runningQueries++;\n      }\n\n      //if dialect doesn't support search_path or dialect option\n      //to prepend searchPath is not true delete the searchPath option\n      if (!this.dialect.supports.searchPath || !this.options.dialectOptions || !this.options.dialectOptions.prependSearchPath ||\n        options.supportsSearchPath === false) {\n        delete options.searchPath;\n      } else if (!options.searchPath) {\n        //if user wants to always prepend searchPath (dialectOptions.preprendSearchPath = true)\n        //then set to DEFAULT if none is provided\n        options.searchPath = 'DEFAULT';\n      }\n      return options.transaction ? options.transaction.connection : this.connectionManager.getConnection(options);\n    }).then(connection => {\n      const query = new this.dialect.Query(connection, this, options);\n\n      return retry(() => query.run(sql, bindParameters).finally(() => {\n        if (!options.transaction) {\n          return this.connectionManager.releaseConnection(connection);\n        }\n      }), Utils._.extend(this.options.retry, options.retry || {}));\n    }).finally(() => {\n      if (this.test._trackRunningQueries) {\n        this.test._runningQueries--;\n      }\n    });\n  }\n\n  /**\n   * Execute a query which would set an environment or user variable. The variables are set per connection, so this function needs a transaction.\n   * Only works for MySQL.\n   *\n   * @method set\n   * @param {Object}        variables Object with multiple variables.\n   * @param {Object}        options Query options.\n   * @param {Transaction}   options.transaction The transaction that the query should be executed under\n   *\n   * @memberof Sequelize\n   * @return {Promise}\n   */\n  set(variables, options) {\n\n    // Prepare options\n    options = Utils._.extend({}, this.options.set, typeof options === 'object' && options || {});\n\n    if (this.options.dialect !== 'mysql') {\n      throw new Error('sequelize.set is only supported for mysql');\n    }\n    if (!options.transaction || !(options.transaction instanceof Transaction) ) {\n      throw new TypeError('options.transaction is required');\n    }\n\n    // Override some options, since this isn't a SELECT\n    options.raw = true;\n    options.plain = true;\n    options.type = 'SET';\n\n    // Generate SQL Query\n    const query =\n      'SET '+\n      Utils._.map(variables, (v, k) => '@'+k +' := '+ (typeof v === 'string' ? '\"'+v+'\"' : v)).join(', ');\n\n    return this.query(query, options);\n  }\n\n  /**\n   * Escape value.\n   *\n   * @param {String} value\n   * @return {String}\n   */\n  escape(value) {\n    return this.getQueryInterface().escape(value);\n  }\n\n  /**\n   * Create a new database schema.\n   *\n   * Note, that this is a schema in the [postgres sense of the word](http://www.postgresql.org/docs/9.1/static/ddl-schemas.html),\n   * not a database table. In mysql and sqlite, this command will do nothing.\n   *\n   * @see {@link Model.schema}\n   * @param {String} schema Name of the schema\n   * @param {Object} options={}\n   * @param {Boolean|function} options.logging A function that logs sql queries, or false for no logging\n   * @return {Promise}\n   */\n  createSchema(schema, options) {\n    return this.getQueryInterface().createSchema(schema, options);\n  }\n\n  /**\n   * Show all defined schemas\n   *\n   * Note, that this is a schema in the [postgres sense of the word](http://www.postgresql.org/docs/9.1/static/ddl-schemas.html),\n   * not a database table. In mysql and sqlite, this will show all tables.\n   * @param {Object} options={}\n   * @param {Boolean|function} options.logging A function that logs sql queries, or false for no logging\n   * @return {Promise}\n   */\n  showAllSchemas(options) {\n    return this.getQueryInterface().showAllSchemas(options);\n  }\n\n  /**\n   * Drop a single schema\n   *\n   * Note, that this is a schema in the [postgres sense of the word](http://www.postgresql.org/docs/9.1/static/ddl-schemas.html),\n   * not a database table. In mysql and sqlite, this drop a table matching the schema name\n   * @param {String} schema Name of the schema\n   * @param {Object} options={}\n   * @param {Boolean|function} options.logging A function that logs sql queries, or false for no logging\n   * @return {Promise}\n   */\n  dropSchema(schema, options) {\n    return this.getQueryInterface().dropSchema(schema, options);\n  }\n\n  /**\n   * Drop all schemas\n   *\n   * Note,that this is a schema in the [postgres sense of the word](http://www.postgresql.org/docs/9.1/static/ddl-schemas.html),\n   * not a database table. In mysql and sqlite, this is the equivalent of drop all tables.\n   * @param {Object} options={}\n   * @param {Boolean|function} options.logging A function that logs sql queries, or false for no logging\n   * @return {Promise}\n   */\n  dropAllSchemas(options) {\n    return this.getQueryInterface().dropAllSchemas(options);\n  }\n\n  /**\n   * Sync all defined models to the DB.\n   *\n   * @param {Object} [options={}]\n   * @param {Boolean} [options.force=false] If force is true, each Model will run `DROP TABLE IF EXISTS`, before it tries to create its own table\n   * @param {RegExp} [options.match] Match a regex against the database name before syncing, a safety check for cases where force: true is used in tests but not live code\n   * @param {Boolean|function} [options.logging=console.log] A function that logs sql queries, or false for no logging\n   * @param {String} [options.schema='public'] The schema that the tables should be created in. This can be overriden for each table in sequelize.define\n   * @param  {String} [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)\n   * @param {Boolean} [options.hooks=true] If hooks is true then beforeSync, afterSync, beforBulkSync, afterBulkSync hooks will be called\n   * @param {Boolean} [options.alter=false] Alters tables to fit models. Not recommended for production use. Deletes data in columns that were removed or had their type changed in the model.\n   * @return {Promise}\n   */\n  sync(options) {\n\n    options = _.clone(options) || {};\n    options.hooks = options.hooks === undefined ? true : !!options.hooks;\n    options = Utils._.defaults(options, this.options.sync, this.options);\n\n    if (options.match) {\n      if (!options.match.test(this.config.database)) {\n        return Promise.reject(new Error('Database does not match sync match parameter'));\n      }\n    }\n\n    return Promise.try(() => {\n      if (options.hooks) {\n        return this.runHooks('beforeBulkSync', options);\n      }\n    }).then(() => {\n      if (options.force) {\n        return this.drop(options);\n      }\n    }).then(() => {\n      const models = [];\n\n      // Topologically sort by foreign key constraints to give us an appropriate\n      // creation order\n      this.modelManager.forEachModel(model => {\n        if (model) {\n          models.push(model);\n        } else {\n          // DB should throw an SQL error if referencing inexistant table\n        }\n      });\n\n      return Promise.each(models, model => model.sync(options));\n    }).then(() => {\n      if (options.hooks) {\n        return this.runHooks('afterBulkSync', options);\n      }\n    }).return(this);\n  }\n\n  /**\n   * Truncate all tables defined through the sequelize models. This is done\n   * by calling Model.truncate() on each model.\n   *\n   * @param {object} [options] The options passed to Model.destroy in addition to truncate\n   * @param {Boolean|function} [options.transaction]\n   * @param {Boolean|function} [options.logging] A function that logs sql queries, or false for no logging\n   * @return {Promise}\n   *\n   * @see {@link Model.truncate} for more information\n   */\n  truncate(options) {\n    const models = [];\n\n    this.modelManager.forEachModel(model => {\n      if (model) {\n        models.push(model);\n      }\n    }, { reverse: false });\n\n    const truncateModel = model => model.truncate(options);\n\n    if (options && options.cascade) {\n      return Promise.each(models, truncateModel);\n    } else {\n      return Promise.map(models, truncateModel);\n    }\n  }\n\n  /**\n   * Drop all tables defined through this sequelize instance. This is done by calling Model.drop on each model\n   * @see {@link Model.drop} for options\n   *\n   * @param {object} options  The options passed to each call to Model.drop\n   * @param {Boolean|function} options.logging A function that logs sql queries, or false for no logging\n   * @return {Promise}\n   */\n  drop(options) {\n    const models = [];\n\n    this.modelManager.forEachModel(model => {\n      if (model) {\n        models.push(model);\n      }\n    }, { reverse: false });\n\n    return Promise.each(models, model => model.drop(options));\n  }\n\n  /**\n   * Test the connection by trying to authenticate\n   *\n   * @error 'Invalid credentials' if the authentication failed (even if the database did not respond at all...)\n   * @return {Promise}\n   */\n  authenticate(options) {\n    return this.query('SELECT 1+1 AS result', Utils._.assign({ raw: true, plain: true }, options)).return();\n  }\n\n  databaseVersion(options) {\n    return this.getQueryInterface().databaseVersion(options);\n  }\n\n  /**\n   * Creates an object representing a database function. This can be used in search queries, both in where and order parts, and as default values in column definitions.\n   * If you want to refer to columns in your function, you should use `sequelize.col`, so that the columns are properly interpreted as columns and not a strings.\n   *\n   * Convert a user's username to upper case\n   * ```js\n   * instance.updateAttributes({\n   *   username: self.sequelize.fn('upper', self.sequelize.col('username'))\n   * })\n   * ```\n   *\n   * @see {@link Model.findAll}\n   * @see {@link Sequelize.define}\n   * @see {@link Sequelize.col}\n   * @method fn\n   *\n   * @param {String} fn The function you want to call\n   * @param {any} args All further arguments will be passed as arguments to the function\n   *\n   * @since v2.0.0-dev3\n   * @memberof Sequelize\n   * @return {Sequelize.fn}\n   * @example <caption>Convert a user's username to upper case</caption>\n   * instance.updateAttributes({\n   *   username: self.sequelize.fn('upper', self.sequelize.col('username'))\n   * })\n   */\n  static fn(fn) {\n    return new Utils.Fn(fn, Utils.sliceArgs(arguments, 1));\n  }\n\n  /**\n   * Creates an object which represents a column in the DB, this allows referencing another column in your query. This is often useful in conjunction with `sequelize.fn`, since raw string arguments to fn will be escaped.\n   * @see {@link Sequelize#fn}\n   *\n   * @method col\n   * @param {String} col The name of the column\n   * @since v2.0.0-dev3\n   * @memberof Sequelize\n   * @return {Sequelize.col}\n   */\n  static col(col) {\n    return new Utils.Col(col);\n  }\n\n  /**\n   * Creates an object representing a call to the cast function.\n   *\n   * @method cast\n   * @param {any} val The value to cast\n   * @param {String} type The type to cast it to\n   * @since v2.0.0-dev3\n   * @memberof Sequelize\n   * @return {Sequelize.cast}\n   */\n  static cast(val, type) {\n    return new Utils.Cast(val, type);\n  }\n\n  /**\n   * Creates an object representing a literal, i.e. something that will not be escaped.\n   *\n   * @method literal\n   * @param {any} val\n   * @alias asIs\n   * @since v2.0.0-dev3\n   * @memberof Sequelize\n   * @return {Sequelize.literal}\n   */\n  static literal(val) {\n    return new Utils.Literal(val);\n  }\n\n  /**\n   * An AND query\n   * @see {@link Model.findAll}\n   *\n   * @method and\n   * @param {String|Object} args Each argument will be joined by AND\n   * @since v2.0.0-dev3\n   * @memberof Sequelize\n   * @return {Sequelize.and}\n   */\n  static and() {\n    return { $and: Utils.sliceArgs(arguments) };\n  }\n\n  /**\n   * An OR query\n   * @see {@link Model.findAll}\n   *\n   * @method or\n   * @param {String|Object} args Each argument will be joined by OR\n   * @since v2.0.0-dev3\n   * @memberof Sequelize\n   * @return {Sequelize.or}\n   */\n  static or() {\n    return { $or: Utils.sliceArgs(arguments) };\n  }\n\n  /**\n   * Creates an object representing nested where conditions for postgres's json data-type.\n   * @see {@link Model.findAll}\n   *\n   * @method json\n   * @param {String|Object} conditions A hash containing strings/numbers or other nested hash, a string using dot notation or a string using postgres json syntax.\n   * @param {String|Number|Boolean} [value] An optional value to compare against. Produces a string of the form \"<json path> = '<value>'\".\n   * @memberof Sequelize\n   * @return {Sequelize.json}\n   */\n  static json(conditionsOrPath, value) {\n    return new Utils.Json(conditionsOrPath, value);\n  }\n\n  /**\n   * A way of specifying attr = condition.\n   *\n   * The attr can either be an object taken from `Model.rawAttributes` (for example `Model.rawAttributes.id` or `Model.rawAttributes.name`). The\n   * attribute should be defined in your model definition. The attribute can also be an object from one of the sequelize utility functions (`sequelize.fn`, `sequelize.col` etc.)\n   *\n   * For string attributes, use the regular `{ where: { attr: something }}` syntax. If you don't want your string to be escaped, use `sequelize.literal`.\n   *\n   * @see {@link Model.findAll}\n   *\n   * @param {Object} attr The attribute, which can be either an attribute object from `Model.rawAttributes` or a sequelize object, for example an instance of `sequelize.fn`. For simple string attributes, use the POJO syntax\n   * @param {string} [comparator='=']\n   * @param {String|Object} logic The condition. Can be both a simply type, or a further condition (`$or`, `$and`, `.literal` etc.)\n   * @alias condition\n   * @since v2.0.0-dev3\n   */\n  static where(attr, comparator, logic) {\n    return new Utils.Where(attr, comparator, logic);\n  }\n\n  /**\n   * Start a transaction. When using transactions, you should pass the transaction in the options argument in order for the query to happen under that transaction\n   *\n   * ```js\n   * sequelize.transaction().then(transaction => {\n   *   return User.find(..., {transaction})\n   *     .then(user => user.updateAttributes(..., {transaction}))\n   *     .then(() => transaction.commit())\n   *     .catch(() => transaction.rollback());\n   * })\n   * ```\n   *\n   * A syntax for automatically committing or rolling back based on the promise chain resolution is also supported:\n   *\n   * ```js\n   * sequelize.transaction(transaction => { // Note that we use a callback rather than a promise.then()\n   *   return User.find(..., {transaction})\n   *     .then(user => user.updateAttributes(..., {transaction}))\n   * }).then(() => {\n   *   // Committed\n   * }).catch(err => {\n   *   // Rolled back\n   *   console.error(err);\n   * });\n   * ```\n   *\n   * If you have [CLS](https://github.com/othiym23/node-continuation-local-storage) enabled, the transaction will automatically be passed to any query that runs within the callback.\n   * To enable CLS, add it do your project, create a namespace and set it on the sequelize constructor:\n   *\n   * ```js\n   * const cls = require('continuation-local-storage');\n   * const ns = cls.createNamespace('....');\n   * const Sequelize = require('sequelize');\n   * Sequelize.useCLS(ns);\n   * ```\n   * Note, that CLS is enabled for all sequelize instances, and all instances will share the same namespace\n   *\n   * @see {@link Transaction}\n   * @param {Object}   [options={}]\n   * @param {Boolean}  [options.autocommit]\n   * @param {String}   [options.type='DEFERRED'] See `Sequelize.Transaction.TYPES` for possible options. Sqlite only.\n   * @param {String}   [options.isolationLevel] See `Sequelize.Transaction.ISOLATION_LEVELS` for possible options\n   * @param {Function} [options.logging=false] A function that gets executed while running the query to log the sql.\n   * @param {Function} [autoCallback] The callback is called with the transaction object, and should return a promise. If the promise is resolved, the transaction commits; if the promise rejects, the transaction rolls back\n   * @return {Promise}\n   */\n  transaction(options, autoCallback) {\n    if (typeof options === 'function') {\n      autoCallback = options;\n      options = undefined;\n    }\n    // testhint argsConform.end\n\n    const transaction = new Transaction(this, options);\n\n    if (!autoCallback) return transaction.prepareEnvironment().return(transaction);\n\n    // autoCallback provided\n    return Sequelize._clsRun(() => {\n      return transaction.prepareEnvironment()\n        .then(() => autoCallback(transaction))\n        .tap(() => transaction.commit())\n        .catch(err => {\n          // Rollback transaction if not already finished (commit, rollback, etc)\n          // and reject with original error (ignore any error in rollback)\n          return Promise.try(() => {\n            if (!transaction.finished) return transaction.rollback().catch(() => {});\n          }).throw(err);\n        });\n    });\n  }\n\n  /**\n   * Use CLS with Sequelize.\n   * CLS namespace provided is stored as `Sequelize._cls`\n   * and bluebird Promise is patched to use the namespace, using `cls-bluebird` module.\n   *\n   * @param {Object}   ns   CLS namespace\n   * @returns {Object}      Sequelize constructor\n   */\n  static useCLS(ns) {\n    // check `ns` is valid CLS namespace\n    if (!ns || typeof ns !== 'object' || typeof ns.bind !== 'function' || typeof ns.run !== 'function') throw new Error('Must provide CLS namespace');\n\n    // save namespace as `Sequelize._cls`\n    this._cls = ns;\n\n    // patch bluebird to bind all promise callbacks to CLS namespace\n    clsBluebird(ns, Promise);\n\n    // return Sequelize for chaining\n    return this;\n  }\n\n  /**\n   * Run function in CLS context.\n   * If no CLS context in use, just runs the function normally\n   *\n   * @private\n   * @param {Function} fn Function to run\n   * @returns {*} Return value of function\n   */\n  static _clsRun(fn) {\n    const ns = Sequelize._cls;\n    if (!ns) return fn();\n\n    let res;\n    ns.run(context => res = fn(context));\n    return res;\n  }\n\n  /*\n   * Getter/setter for `Sequelize.cls`\n   * To maintain backward compatibility with Sequelize v3.x\n   * Calling the\n   */\n  static get cls() {\n    Utils.deprecate('Sequelize.cls is deprecated and will be removed in a future version. Keep track of the CLS namespace you use in your own code.');\n    return this._cls;\n  }\n\n  static set cls(ns) {\n    Utils.deprecate('Sequelize.cls should not be set directly. Use Sequelize.useCLS().');\n    this.useCLS(ns);\n  }\n\n  log() {\n    let options;\n    let args = Utils.sliceArgs(arguments);\n    const last = Utils._.last(args);\n\n    if (last && Utils._.isPlainObject(last) && last.hasOwnProperty('logging')) {\n      options = last;\n\n      // remove options from set of logged arguments if options.logging is equal to console.log\n      if (options.logging === console.log) {\n        args.splice(args.length-1, 1);\n      }\n    } else {\n      options = this.options;\n    }\n\n    if (options.logging) {\n      if (options.logging === true) {\n        Utils.deprecate('The logging-option should be either a function or false. Default: console.log');\n        options.logging = console.log;\n      }\n\n      // second argument is sql-timings, when benchmarking option enabled\n      if ((this.options.benchmark || options.benchmark) && options.logging === console.log) {\n        args = [args[0] + ' Elapsed time: ' + args[1] + 'ms'];\n      }\n\n      options.logging.apply(null, args);\n    }\n  }\n\n  /**\n   * Close all connections used by this sequelize instance, and free all references so the instance can be garbage collected.\n   *\n   * Normally this is done on process exit, so you only need to call this method if you are creating multiple instances, and want\n   * to garbage collect some of them.\n   */\n  close() {\n    this.connectionManager.close();\n  }\n\n  normalizeDataType(Type) {\n    let type = typeof Type === 'function' ? new Type() : Type;\n    const dialectTypes = this.dialect.DataTypes || {};\n\n    if (dialectTypes[type.key]) {\n      type = dialectTypes[type.key].extend(type);\n    }\n\n    if (type instanceof DataTypes.ARRAY && dialectTypes[type.type.key]) {\n      type.type = dialectTypes[type.type.key].extend(type.type);\n    }\n    return type;\n  }\n  normalizeAttribute(attribute) {\n    if (!Utils._.isPlainObject(attribute)) {\n      attribute = { type: attribute };\n    }\n\n    if (!attribute.type) return attribute;\n\n    attribute.type = this.normalizeDataType(attribute.type);\n\n    if (attribute.hasOwnProperty('defaultValue')) {\n      if (typeof attribute.defaultValue === 'function' && (\n        attribute.defaultValue === DataTypes.NOW ||\n          attribute.defaultValue === DataTypes.UUIDV1 ||\n          attribute.defaultValue === DataTypes.UUIDV4\n      )) {\n        attribute.defaultValue = new attribute.defaultValue();\n      }\n    }\n\n    if (attribute.type instanceof DataTypes.ENUM) {\n      // The ENUM is a special case where the type is an object containing the values\n      if (attribute.values) {\n        attribute.type.values = attribute.type.options.values = attribute.values;\n      } else {\n        attribute.values = attribute.type.values;\n      }\n\n      if (!attribute.values.length) {\n        throw new Error('Values for ENUM have not been defined.');\n      }\n    }\n\n    return attribute;\n  }\n}\n\n// Aliases\nSequelize.prototype.fn = Sequelize.fn;\nSequelize.prototype.col = Sequelize.col;\nSequelize.prototype.cast = Sequelize.cast;\nSequelize.prototype.literal = Sequelize.asIs = Sequelize.prototype.asIs = Sequelize.literal;\nSequelize.prototype.and = Sequelize.and;\nSequelize.prototype.or = Sequelize.or;\nSequelize.prototype.json = Sequelize.json;\nSequelize.prototype.where = Sequelize.condition = Sequelize.prototype.condition = Sequelize.where;\nSequelize.prototype.validate = Sequelize.prototype.authenticate;\n\n/**\n * Sequelize version number.\n */\nSequelize.version = require('../package.json').version;\n\nSequelize.options = {hooks: {}};\n\n/**\n * A reference to Sequelize constructor from sequelize. Useful for accessing DataTypes, Errors etc.\n * @see {@link Sequelize}\n */\nSequelize.prototype.Sequelize = Sequelize;\n\n/**\n * @private\n */\nSequelize.prototype.Utils = Sequelize.Utils = Utils;\n\n/**\n * A handy reference to the bluebird Promise class\n */\nSequelize.prototype.Promise = Sequelize.Promise = Promise;\n\n/**\n * Available query types for use with `sequelize.query`\n * @see {@link QueryTypes}\n */\nSequelize.prototype.QueryTypes = Sequelize.QueryTypes = QueryTypes;\n\n/**\n * Exposes the validator.js object, so you can extend it with custom validation functions. The validator is exposed both on the instance, and on the constructor.\n * @see https://github.com/chriso/validator.js\n */\nSequelize.prototype.Validator = Sequelize.Validator = Validator;\n\nSequelize.prototype.Model = Sequelize.Model = Model;\n\nSequelize.DataTypes = DataTypes;\nfor (const dataType in DataTypes) {\n  Sequelize[dataType] = DataTypes[dataType];\n}\n\n/**\n * A reference to the sequelize transaction class. Use this to access isolationLevels and types when creating a transaction\n * @see {@link Transaction}\n * @see {@link Sequelize.transaction}\n */\nSequelize.prototype.Transaction = Sequelize.Transaction = Transaction;\n\n/**\n * A reference to the deferrable collection. Use this to access the different deferrable options.\n * @see {@link Transaction.Deferrable}\n * @see {@link Sequelize#transaction}\n */\nSequelize.prototype.Deferrable = Sequelize.Deferrable = Deferrable;\n\n/**\n * A reference to the sequelize association class.\n * @see {@link Association}\n */\nSequelize.prototype.Association = Sequelize.Association = Association;\n\n/**\n * Provide alternative version of `inflection` module to be used by `Utils.pluralize` etc.\n * @param {Object} _inflection - `inflection` module\n */\nSequelize.useInflection = Utils.useInflection;\n\n/**\n * Allow hooks to be defined on Sequelize + on sequelize instance as universal hooks to run on all models\n * and on Sequelize/sequelize methods e.g. Sequelize(), Sequelize#define()\n */\nHooks.applyTo(Sequelize);\nHooks.applyTo(Sequelize.prototype);\n\n/**\n * Expose various errors available\n */\nfor (const error of Object.keys(sequelizeErrors)) {\n  if (sequelizeErrors[error] === sequelizeErrors.BaseError) {\n    Sequelize.prototype.Error = Sequelize.Error = sequelizeErrors.BaseError;\n  } else {\n    Sequelize.prototype[error] = Sequelize[error] = sequelizeErrors[error];\n  }\n}\n\nmodule.exports = Sequelize;\nmodule.exports.Sequelize = Sequelize;\nmodule.exports.default = Sequelize;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/sequelize.js\n// module id = 50\n// module chunks = 0","module.exports = require(\"url\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"url\"\n// module id = 51\n// module chunks = 0","module.exports = require(\"retry-as-promised\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"retry-as-promised\"\n// module id = 52\n// module chunks = 0","module.exports = require(\"cls-bluebird\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"cls-bluebird\"\n// module id = 53\n// module chunks = 0","module.exports = require(\"terraformer-wkt-parser\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"terraformer-wkt-parser\"\n// module id = 54\n// module chunks = 0","'use strict';\n\n/**\n * Sequelize provides a host of custom error classes, to allow you to do easier debugging. All of these errors are exposed on the sequelize object and the sequelize constructor.\n * All sequelize errors inherit from the base JS error object.\n *\n * This means that errors can be accessed using `Sequelize.ValidationError` or `sequelize.ValidationError`\n * The Base Error all Sequelize Errors inherit from.\n */\nclass BaseError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'SequelizeBaseError';\n    this.message = message;\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\nexports.BaseError = BaseError;\n\n/**\n * Scope Error. Thrown when the sequelize cannot query the specified scope.\n */\nclass SequelizeScopeError extends BaseError {\n  constructor(parent) {\n    super(parent);\n    this.name = 'SequelizeScopeError';\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\nexports.SequelizeScopeError = SequelizeScopeError;\n\n/**\n * Validation Error. Thrown when the sequelize validation has failed. The error contains an `errors` property,\n * which is an array with 1 or more ValidationErrorItems, one for each validation that failed.\n *\n * @param {string} message Error message\n * @param {Array} [errors] Array of ValidationErrorItem objects describing the validation errors\n *\n * @property errors An array of ValidationErrorItems\n */\nclass ValidationError extends BaseError {\n  constructor(message, errors) {\n    super(message);\n    this.name = 'SequelizeValidationError';\n    this.message = 'Validation Error';\n    /**\n     *\n     * @type {ValidationErrorItem[]}\n     */\n    this.errors = errors || [];\n\n    // Use provided error message if available...\n    if (message) {\n      this.message = message;\n\n      // ... otherwise create a concatenated message out of existing errors.\n    } else if (this.errors.length > 0 && this.errors[0].message) {\n      this.message = this.errors.map(err => err.type + ': ' + err.message).join(',\\n');\n    }\n    Error.captureStackTrace(this, this.constructor);\n  }\n\n  /**\n   * Gets all validation error items for the path / field specified.\n   *\n   * @param {string} path The path to be checked for error items\n   * @returns {ValidationErrorItem[]} Validation error items for the specified path\n   */\n  get(path) {\n    return this.errors.reduce((reduced, error) => {\n      if (error.path === path) {\n        reduced.push(error);\n      }\n      return reduced;\n    }, []);\n  }\n}\nexports.ValidationError = ValidationError;\n\n/**\n * Thrown when attempting to update a stale model instance\n */\nclass OptimisticLockError extends BaseError {\n  constructor(options) {\n    options = options || {};\n    options.message = options.message || 'Attempting to update a stale model instance: ' + options.modelName;\n    super(options);\n    this.name = 'SequelizeOptimisticLockError';\n    this.message = options.message;\n    /**\n     * The name of the model on which the update was attempted\n     * @type {string}\n     */\n    this.modelName = options.modelName;\n    /**\n     * The values of the attempted update\n     * @type {object}\n     */\n    this.values = options.values;\n    /**\n     *\n     * @type {object}\n     */\n    this.where = options.where;\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\nexports.OptimisticLockError = OptimisticLockError;\n\n/**\n * A base class for all database related errors.\n */\nclass DatabaseError extends BaseError {\n  constructor(parent) {\n    super(parent.message);\n    this.name = 'SequelizeDatabaseError';\n    /**\n     * @type {Error}\n     */\n    this.parent = parent;\n    /**\n     * @type {Error}\n     */\n    this.original = parent;\n    /**\n     * The SQL that triggered the error\n     * @type {string}\n     */\n    this.sql = parent.sql;\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\nexports.DatabaseError = DatabaseError;\n\n/**\n * Thrown when a database query times out because of a deadlock\n */\nclass TimeoutError extends DatabaseError {\n  constructor(parent) {\n    super(parent);\n    this.name = 'SequelizeTimeoutError';\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\nexports.TimeoutError = TimeoutError;\n\n/**\n * Thrown when a unique constraint is violated in the database\n */\nclass UniqueConstraintError extends ValidationError {\n  constructor(options) {\n    options = options || {};\n    options.parent = options.parent || { sql: '' };\n    options.message = options.message || options.parent.message || 'Validation Error';\n    options.errors = options.errors || {};\n    super(options.message, options.errors);\n\n    this.name = 'SequelizeUniqueConstraintError';\n    this.message = options.message;\n    this.errors = options.errors;\n    this.fields = options.fields;\n    this.parent = options.parent;\n    this.original = options.parent;\n    this.sql = options.parent.sql;\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\nexports.UniqueConstraintError = UniqueConstraintError;\n\n/**\n * Thrown when a foreign key constraint is violated in the database\n */\nclass ForeignKeyConstraintError extends DatabaseError {\n  constructor(options) {\n    options = options || {};\n    options.parent = options.parent || { sql: '' };\n\n    super(options.parent);\n    this.name = 'SequelizeForeignKeyConstraintError';\n\n    this.message = options.message || options.parent.message || 'Database Error';\n    this.fields = options.fields;\n    this.table = options.table;\n    this.value = options.value;\n    this.index = options.index;\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\nexports.ForeignKeyConstraintError = ForeignKeyConstraintError;\n\n/**\n * Thrown when an exclusion constraint is violated in the database\n */\nclass ExclusionConstraintError extends DatabaseError {\n  constructor(options) {\n    options = options || {};\n    options.parent = options.parent || { sql: '' };\n\n    super(options.parent);\n    this.name = 'SequelizeExclusionConstraintError';\n\n    this.message = options.message || options.parent.message;\n    this.constraint = options.constraint;\n    this.fields = options.fields;\n    this.table = options.table;\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\nexports.ExclusionConstraintError = ExclusionConstraintError;\n\n/**\n * Thrown when constraint name is not found in the database\n */\nclass UnknownConstraintError extends DatabaseError {\n  constructor(message) {\n    const parent = { message };\n    super(parent);\n    this.name = 'SequelizeUnknownConstraintError';\n    this.message = message || 'The specified constraint does not exist';\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\nexports.UnknownConstraintError = UnknownConstraintError;\n\n/**\n * Validation Error Item\n * Instances of this class are included in the `ValidationError.errors` property.\n *\n * @param {string} message An error message\n * @param {string} type The type of the validation error\n * @param {string} path The field that triggered the validation error\n * @param {string} value The value that generated the error\n */\nclass ValidationErrorItem {\n  constructor(message, type, path, value) {\n    this.message = message || '';\n    this.type = type || null;\n    this.path = path || null;\n    this.value = value !== undefined ? value : null;\n    //This doesn't need captureStackTrace because its not a subclass of Error\n  }\n}\nexports.ValidationErrorItem = ValidationErrorItem;\n\n/**\n * A base class for all connection related errors.\n */\nclass ConnectionError extends BaseError {\n  constructor(parent) {\n    super(parent ? parent.message : '');\n    this.name = 'SequelizeConnectionError';\n    /**\n     * The connection specific error which triggered this one\n     * @type {Error}\n     */\n    this.parent = parent;\n    this.original = parent;\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\nexports.ConnectionError = ConnectionError;\n\n/**\n * Thrown when a connection to a database is refused\n */\nclass ConnectionRefusedError extends ConnectionError {\n  constructor(parent) {\n    super(parent);\n    this.name = 'SequelizeConnectionRefusedError';\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\nexports.ConnectionRefusedError = ConnectionRefusedError;\n\n/**\n * Thrown when a connection to a database is refused due to insufficient privileges\n */\nclass AccessDeniedError extends ConnectionError {\n  constructor(parent) {\n    super(parent);\n    this.name = 'SequelizeAccessDeniedError';\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\nexports.AccessDeniedError = AccessDeniedError;\n\n/**\n * Thrown when a connection to a database has a hostname that was not found\n */\nclass HostNotFoundError extends ConnectionError {\n  constructor(parent) {\n    super(parent);\n    this.name = 'SequelizeHostNotFoundError';\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\nexports.HostNotFoundError = HostNotFoundError;\n\n/**\n * Thrown when a connection to a database has a hostname that was not reachable\n */\nclass HostNotReachableError extends ConnectionError {\n  constructor(parent) {\n    super(parent);\n    this.name = 'SequelizeHostNotReachableError';\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\nexports.HostNotReachableError = HostNotReachableError;\n\n/**\n * Thrown when a connection to a database has invalid values for any of the connection parameters\n */\nclass InvalidConnectionError extends ConnectionError {\n  constructor(parent) {\n    super(parent);\n    this.name = 'SequelizeInvalidConnectionError';\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\nexports.InvalidConnectionError = InvalidConnectionError;\n\n/**\n * Thrown when a connection to a database times out\n */\nclass ConnectionTimedOutError extends ConnectionError {\n  constructor(parent) {\n    super(parent);\n    this.name = 'SequelizeConnectionTimedOutError';\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\nexports.ConnectionTimedOutError = ConnectionTimedOutError;\n\n/**\n * Thrown when a some problem occurred with Instance methods (see message for details)\n */\nclass InstanceError extends BaseError {\n  constructor(message) {\n    super(message);\n    this.name = 'SequelizeInstanceError';\n    this.message = message;\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\nexports.InstanceError = InstanceError;\n\n/**\n * Thrown when a record was not found, Usually used with rejectOnEmpty mode (see message for details)\n */\nclass EmptyResultError extends BaseError {\n  constructor(message) {\n    super(message);\n    this.name = 'SequelizeEmptyResultError';\n    this.message = message;\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\nexports.EmptyResultError = EmptyResultError;\n\n/**\n * Thrown when an include statement is improperly constructed (see message for details)\n */\nclass EagerLoadingError extends BaseError {\n  constructor(message) {\n    super(message);\n    this.name = 'SequelizeEagerLoadingError';\n    this.message = message;\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\nexports.EagerLoadingError = EagerLoadingError;\n\n/**\n * Thrown when an association is improperly constructed (see message for details)\n */\nclass AssociationError extends BaseError {\n  constructor(message) {\n    super(message);\n    this.name = 'SequelizeAssociationError';\n    this.message = message;\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\nexports.AssociationError = AssociationError;\n/**\n * Thrown when a query is passed invalid options (see message for details)\n */\nclass QueryError extends BaseError {\n  constructor(message) {\n    super(message);\n    this.name = 'SequelizeQueryError';\n    this.message = message;\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\nexports.QueryError = QueryError;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/errors/index.js\n// module id = 55\n// module chunks = 0","module.exports = require(\"validator\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"validator\"\n// module id = 56\n// module chunks = 0","'use strict';\n\nconst _ = require('lodash');\nconst wkx = require('wkx');\nconst inherits = require('../../utils/inherits');\n\nmodule.exports = BaseTypes => {\n  const warn = BaseTypes.ABSTRACT.warn.bind(undefined, 'http://www.postgresql.org/docs/9.4/static/datatype.html');\n\n  BaseTypes.UUID.types.postgres = {\n    oids: [2950],\n    array_oids: [2951]\n  };\n\n  BaseTypes.JSON.types.postgres = {\n    oids: [114],\n    array_oids: [199]\n  };\n\n  BaseTypes.JSONB.types.postgres = {\n    oids: [3802],\n    array_oids: [3807]\n  };\n\n  BaseTypes.TIME.types.postgres = {\n    oids: [1083],\n    array_oids: [1183]\n  };\n\n  function DATEONLY() {\n    if (!(this instanceof DATEONLY)) return new DATEONLY();\n    BaseTypes.DATEONLY.apply(this, arguments);\n  }\n  inherits(DATEONLY, BaseTypes.DATEONLY);\n\n  DATEONLY.parse = function parse(value) {\n    return value;\n  };\n\n  BaseTypes.DATEONLY.types.postgres = {\n    oids: [1082],\n    array_oids: [1182]\n  };\n\n  function DECIMAL(precision, scale) {\n    if (!(this instanceof DECIMAL)) return new DECIMAL(precision, scale);\n    BaseTypes.DECIMAL.apply(this, arguments);\n  }\n  inherits(DECIMAL, BaseTypes.DECIMAL);\n\n  DECIMAL.parse = function parse(value) {\n    return value;\n  };\n\n  // numeric\n  BaseTypes.DECIMAL.types.postgres = {\n    oids: [1700],\n    array_oids: [1231]\n  };\n\n  function STRING(length, binary) {\n    if (!(this instanceof STRING)) return new STRING(length, binary);\n    BaseTypes.STRING.apply(this, arguments);\n  }\n  inherits(STRING, BaseTypes.STRING);\n\n  STRING.prototype.toSql = function toSql() {\n    if (this._binary) {\n      return 'BYTEA';\n    }\n    return BaseTypes.STRING.prototype.toSql.call(this);\n  };\n\n  BaseTypes.STRING.types.postgres = {\n    oids: [1043],\n    array_oids: [1015]\n  };\n\n  function TEXT(length) {\n    if (!(this instanceof TEXT)) return new TEXT(length);\n    BaseTypes.TEXT.apply(this, arguments);\n  }\n  inherits(TEXT, BaseTypes.TEXT);\n\n  TEXT.prototype.toSql = function toSql() {\n    if (this._length) {\n      warn('PostgreSQL does not support TEXT with options. Plain `TEXT` will be used instead.');\n      this._length = undefined;\n    }\n    return 'TEXT';\n  };\n\n  BaseTypes.TEXT.types.postgres = {\n    oids: [25],\n    array_oids: [1009]\n  };\n\n  function CHAR(length, binary) {\n    if (!(this instanceof CHAR)) return new CHAR(length, binary);\n    BaseTypes.CHAR.apply(this, arguments);\n  }\n  inherits(CHAR, BaseTypes.CHAR);\n\n  CHAR.prototype.toSql = function toSql() {\n    if (this._binary) {\n      return 'BYTEA';\n    }\n    return BaseTypes.CHAR.prototype.toSql.call(this);\n  };\n\n  BaseTypes.CHAR.types.postgres = {\n    oids: [18, 1042],\n    array_oids: [1002, 1014]\n  };\n\n  function BOOLEAN() {\n    if (!(this instanceof BOOLEAN)) return new BOOLEAN();\n    BaseTypes.BOOLEAN.apply(this, arguments);\n  }\n  inherits(BOOLEAN, BaseTypes.BOOLEAN);\n\n  BOOLEAN.prototype.toSql = function toSql() {\n    return 'BOOLEAN';\n  };\n\n  BaseTypes.BOOLEAN.types.postgres = {\n    oids: [16],\n    array_oids: [1000]\n  };\n\n  function DATE(length) {\n    if (!(this instanceof DATE)) return new DATE(length);\n    BaseTypes.DATE.apply(this, arguments);\n  }\n  inherits(DATE, BaseTypes.DATE);\n\n  DATE.prototype.toSql = function toSql() {\n    return 'TIMESTAMP WITH TIME ZONE';\n  };\n\n  BaseTypes.DATE.types.postgres = {\n    oids: [1184],\n    array_oids: [1185]\n  };\n\n  function INTEGER(length) {\n    if (!(this instanceof INTEGER)) return new INTEGER(length);\n    BaseTypes.INTEGER.apply(this, arguments);\n\n    // POSTGRES does not support any parameters for integer\n    if (this._length || this.options.length || this._unsigned || this._zerofill) {\n      warn('PostgreSQL does not support INTEGER with options. Plain `INTEGER` will be used instead.');\n      this._length = undefined;\n      this.options.length = undefined;\n      this._unsigned = undefined;\n      this._zerofill = undefined;\n    }\n  }\n  inherits(INTEGER, BaseTypes.INTEGER);\n\n  INTEGER.parse = function parse(value) {\n    return parseInt(value, 10);\n  };\n\n  // int4\n  BaseTypes.INTEGER.types.postgres = {\n    oids: [23],\n    array_oids: [1007]\n  };\n\n  function BIGINT(length) {\n    if (!(this instanceof BIGINT)) return new BIGINT(length);\n    BaseTypes.BIGINT.apply(this, arguments);\n\n    // POSTGRES does not support any parameters for bigint\n    if (this._length || this.options.length || this._unsigned || this._zerofill) {\n      warn('PostgreSQL does not support BIGINT with options. Plain `BIGINT` will be used instead.');\n      this._length = undefined;\n      this.options.length = undefined;\n      this._unsigned = undefined;\n      this._zerofill = undefined;\n    }\n  }\n  inherits(BIGINT, BaseTypes.BIGINT);\n\n  // int8\n  BaseTypes.BIGINT.types.postgres = {\n    oids: [20],\n    array_oids: [1016]\n  };\n\n  function REAL(length, decimals) {\n    if (!(this instanceof REAL)) return new REAL(length, decimals);\n    BaseTypes.REAL.apply(this, arguments);\n\n    // POSTGRES does not support any parameters for real\n    if (this._length || this.options.length || this._unsigned || this._zerofill) {\n      warn('PostgreSQL does not support REAL with options. Plain `REAL` will be used instead.');\n      this._length = undefined;\n      this.options.length = undefined;\n      this._unsigned = undefined;\n      this._zerofill = undefined;\n    }\n  }\n  inherits(REAL, BaseTypes.REAL);\n\n  // float4\n  BaseTypes.REAL.types.postgres = {\n    oids: [700],\n    array_oids: [1021]\n  };\n\n  function DOUBLE(length, decimals) {\n    if (!(this instanceof DOUBLE)) return new DOUBLE(length, decimals);\n    BaseTypes.DOUBLE.apply(this, arguments);\n\n    // POSTGRES does not support any parameters for double\n    if (this._length || this.options.length || this._unsigned || this._zerofill) {\n      warn('PostgreSQL does not support DOUBLE with options. Plain `DOUBLE` will be used instead.');\n      this._length = undefined;\n      this.options.length = undefined;\n      this._unsigned = undefined;\n      this._zerofill = undefined;\n    }\n  }\n  inherits(DOUBLE, BaseTypes.DOUBLE);\n\n  // float8\n  BaseTypes.DOUBLE.types.postgres = {\n    oids: [701],\n    array_oids: [1022]\n  };\n\n  function FLOAT(length, decimals) {\n    if (!(this instanceof FLOAT)) return new FLOAT(length, decimals);\n    BaseTypes.FLOAT.apply(this, arguments);\n\n    // POSTGRES does only support lengths as parameter.\n    // Values between 1-24 result in REAL\n    // Values between 25-53 result in DOUBLE PRECISION\n    // If decimals are provided remove these and print a warning\n    if (this._decimals) {\n      warn('PostgreSQL does not support FLOAT with decimals. Plain `FLOAT` will be used instead.');\n      this._length = undefined;\n      this.options.length = undefined;\n      this._decimals = undefined;\n    }\n    if (this._unsigned) {\n      warn('PostgreSQL does not support FLOAT unsigned. `UNSIGNED` was removed.');\n      this._unsigned = undefined;\n    }\n    if (this._zerofill) {\n      warn('PostgreSQL does not support FLOAT zerofill. `ZEROFILL` was removed.');\n      this._zerofill = undefined;\n    }\n  }\n  inherits(FLOAT, BaseTypes.FLOAT);\n  delete FLOAT.parse; // Float has no separate type in PG\n\n  function BLOB(length) {\n    if (!(this instanceof BLOB)) return new BLOB(length);\n    BaseTypes.BLOB.apply(this, arguments);\n  }\n  inherits(BLOB, BaseTypes.BLOB);\n\n  BLOB.prototype.toSql = function toSql() {\n    if (this._length) {\n      warn('PostgreSQL does not support BLOB (BYTEA) with options. Plain `BYTEA` will be used instead.');\n      this._length = undefined;\n    }\n    return 'BYTEA';\n  };\n\n  BLOB.prototype._hexify = function _hexify(hex) {\n    // bytea hex format http://www.postgresql.org/docs/current/static/datatype-binary.html\n    return \"E'\\\\\\\\x\" + hex + \"'\";\n  };\n\n  BaseTypes.BLOB.types.postgres = {\n    oids: [17],\n    array_oids: [1001]\n  };\n\n  function GEOMETRY(type, srid) {\n    if (!(this instanceof GEOMETRY)) return new GEOMETRY(type, srid);\n    BaseTypes.GEOMETRY.apply(this, arguments);\n  }\n  inherits(GEOMETRY, BaseTypes.GEOMETRY);\n\n  GEOMETRY.prototype.toSql = function toSql() {\n    let result = this.key;\n\n    if (this.type) {\n      result += '(' + this.type;\n\n      if (this.srid) {\n        result += ',' + this.srid;\n      }\n\n      result += ')';\n    }\n\n    return result;\n  };\n\n  BaseTypes.GEOMETRY.types.postgres = {\n    oids: [],\n    array_oids: []\n  };\n\n  GEOMETRY.parse = GEOMETRY.prototype.parse = function parse(value) {\n    const b = new Buffer(value, 'hex');\n    return wkx.Geometry.parse(b).toGeoJSON();\n  };\n\n  GEOMETRY.prototype._stringify = function _stringify(value, options) {\n    return 'ST_GeomFromGeoJSON(' + options.escape(JSON.stringify(value)) + ')';\n  };\n\n  function GEOGRAPHY(type, srid) {\n    if (!(this instanceof GEOGRAPHY)) return new GEOGRAPHY(type, srid);\n    BaseTypes.GEOGRAPHY.apply(this, arguments);\n  }\n  inherits(GEOGRAPHY, BaseTypes.GEOGRAPHY);\n\n  GEOGRAPHY.prototype.toSql = function toSql() {\n    let result = 'GEOGRAPHY';\n\n    if (this.type) {\n      result += '(' + this.type;\n\n      if (this.srid) {\n        result += ',' + this.srid;\n      }\n\n      result += ')';\n    }\n\n    return result;\n  };\n\n  BaseTypes.GEOGRAPHY.types.postgres = {\n    oids: [],\n    array_oids: []\n  };\n\n  GEOGRAPHY.parse = GEOGRAPHY.prototype.parse = function parse(value) {\n    const b = new Buffer(value, 'hex');\n    return wkx.Geometry.parse(b).toGeoJSON();\n  };\n\n  GEOGRAPHY.prototype._stringify = function _stringify(value, options) {\n    return 'ST_GeomFromGeoJSON(' + options.escape(JSON.stringify(value)) + ')';\n  };\n\n  let hstore;\n  function HSTORE() {\n    if (!(this instanceof HSTORE)) return new HSTORE();\n    BaseTypes.HSTORE.apply(this, arguments);\n\n    if (!hstore) {\n      // All datatype files are loaded at import - make sure we don't load the hstore parser before a hstore is instantiated\n      hstore = require('./hstore');\n    }\n  }\n  inherits(HSTORE, BaseTypes.HSTORE);\n\n  HSTORE.parse = function parse(value) {\n    if (!hstore) {\n      // All datatype files are loaded at import - make sure we don't load the hstore parser before a hstore is instantiated\n      hstore = require('./hstore');\n    }\n    return hstore.parse(value);\n  };\n\n  HSTORE.prototype.escape = false;\n  HSTORE.prototype._stringify = function _stringify(value) {\n    if (!hstore) {\n      // All datatype files are loaded at import - make sure we don't load the hstore parser before a hstore is instantiated\n      hstore = require('./hstore');\n    }\n    return \"'\" + hstore.stringify(value) + \"'\";\n  };\n\n  BaseTypes.HSTORE.types.postgres = {\n    oids: [],\n    array_oids: []\n  };\n\n  function RANGE(subtype) {\n    if (!(this instanceof RANGE)) return new RANGE(subtype);\n    BaseTypes.RANGE.apply(this, arguments);\n  }\n  inherits(RANGE, BaseTypes.RANGE);\n\n  RANGE.oid_map = {\n    3904: 23, // int4\n    3905: 23,\n    3906: 1700, // Numeric\n    3907: 1700,\n    3908: 1114, // timestamp\n    3909: 1114,\n    3910: 1184, // timestamptz\n    3911: 1184,\n    3912: 1082, // date\n    3913: 1082,\n    3926: 20,    // int8\n    3927: 20\n  };\n\n  const range = require('./range');\n  RANGE.parse = function parse(value, oid, getTypeParser) {\n    const parser = getTypeParser(RANGE.oid_map[oid]);\n\n    return range.parse(value, parser);\n  };\n\n  RANGE.prototype.escape = false;\n  RANGE.prototype._stringify = function _stringify(values, options) {\n    if (!Array.isArray(values)) {\n      return \"'\" + this.options.subtype.stringify(values, options) + \"'::\" +\n        this.toCastType();\n    }\n    const valuesStringified = values.map(value => {\n      if (_.includes([null, -Infinity, Infinity], value)) {\n        // Pass through \"unbounded\" bounds unchanged\n        return value;\n      } else if (this.options.subtype.stringify) {\n        return this.options.subtype.stringify(value, options);\n      } else {\n        return options.escape(value);\n      }\n    });\n\n    // Array.map does not preserve extra array properties\n    valuesStringified.inclusive = values.inclusive;\n\n    return  '\\'' + range.stringify(valuesStringified) + '\\'';\n  };\n\n  BaseTypes.RANGE.types.postgres = {\n    oids: [3904, 3906, 3908, 3910, 3912, 3926],\n    array_oids: [3905, 3907, 3909, 3911, 3913, 3927]\n  };\n\n  BaseTypes.ARRAY.prototype.escape = false;\n  BaseTypes.ARRAY.prototype._stringify = function _stringify(values, options) {\n    let str = 'ARRAY[' + values.map(value => {\n      if (this.type && this.type.stringify) {\n        value = this.type.stringify(value, options);\n\n        if (this.type.escape === false) {\n          return value;\n        }\n      }\n      return options.escape(value);\n    }, this).join(',') + ']';\n\n    if (this.type) {\n      str += '::' + this.toSql();\n    }\n\n    return str;\n  };\n\n  const exports = {\n    DECIMAL,\n    BLOB,\n    STRING,\n    CHAR,\n    TEXT,\n    INTEGER,\n    BOOLEAN,\n    DATE,\n    DATEONLY,\n    BIGINT,\n    REAL,\n    'DOUBLE PRECISION': DOUBLE,\n    FLOAT,\n    GEOMETRY,\n    GEOGRAPHY,\n    HSTORE,\n    RANGE\n  };\n\n  _.forIn(exports, (DataType, key) => {\n    if (!DataType.key) DataType.key = key;\n    if (!DataType.extend) {\n      DataType.extend = oldType => new DataType(oldType.options);\n    }\n  });\n\n  return exports;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/dialects/postgres/data-types.js\n// module id = 57\n// module chunks = 0","module.exports = require(\"pg-hstore\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"pg-hstore\"\n// module id = 58\n// module chunks = 0","'use strict';\n\nconst _ = require('lodash');\n\nfunction stringifyRangeBound(bound) {\n  if (bound === null) {\n    return '' ;\n  } else if (bound === Infinity || bound === -Infinity) {\n    return bound.toString().toLowerCase();\n  } else {\n    return JSON.stringify(bound);\n  }\n}\n\nfunction parseRangeBound(bound, parseType) {\n  if (!bound) {\n    return null;\n  } else if (bound === 'infinity') {\n    return Infinity;\n  } else if (bound === '-infinity') {\n    return -Infinity;\n  } else {\n    return parseType(bound);\n  }\n}\n\nfunction stringify(data) {\n  if (data === null) return null;\n\n  if (!_.isArray(data)) throw new Error('range must be an array');\n  if (!data.length) return 'empty';\n  if (data.length !== 2) throw new Error('range array length must be 0 (empty) or 2 (lower and upper bounds)');\n\n  if (data.hasOwnProperty('inclusive')) {\n    if (data.inclusive === false) data.inclusive = [false, false];\n    else if (!data.inclusive) data.inclusive = [true, false];\n    else if (data.inclusive === true) data.inclusive = [true, true];\n  } else {\n    data.inclusive = [true, false];\n  }\n\n  _.each(data, (value, index) => {\n    if (_.isObject(value)) {\n      if (value.hasOwnProperty('inclusive')) data.inclusive[index] = !!value.inclusive;\n      if (value.hasOwnProperty('value')) data[index] = value.value;\n    }\n  });\n\n  const lowerBound = stringifyRangeBound(data[0]);\n  const upperBound = stringifyRangeBound(data[1]);\n\n  return (data.inclusive[0] ? '[' : '(') + lowerBound + ',' + upperBound + (data.inclusive[1] ? ']' : ')');\n}\nexports.stringify = stringify;\n\nfunction parse(value, parser) {\n  if (value === null) return null;\n  if (value === 'empty') {\n    const empty = [];\n    empty.inclusive = [];\n    return empty;\n  }\n\n  let result = value\n    .substring(1, value.length - 1)\n    .split(',', 2);\n\n  if (result.length !== 2) return value;\n\n  result = result.map(value => parseRangeBound(value, parser));\n\n  result.inclusive = [value[0] === '[', value[value.length - 1] === ']'];\n\n  return result;\n}\nexports.parse = parse;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/dialects/postgres/range.js\n// module id = 59\n// module chunks = 0","'use strict';\n\nconst wkx = require('wkx');\nconst _ = require('lodash');\nconst moment = require('moment-timezone');\nconst inherits = require('../../utils/inherits');\n\nmodule.exports = BaseTypes => {\n  BaseTypes.ABSTRACT.prototype.dialectTypes = 'https://dev.mysql.com/doc/refman/5.7/en/data-types.html';\n\n  BaseTypes.DATE.types.mysql = ['DATETIME'];\n  BaseTypes.STRING.types.mysql = ['VAR_STRING'];\n  BaseTypes.CHAR.types.mysql = ['STRING'];\n  BaseTypes.TEXT.types.mysql = ['BLOB'];\n  BaseTypes.INTEGER.types.mysql = ['LONG'];\n  BaseTypes.BIGINT.types.mysql = ['LONGLONG'];\n  BaseTypes.FLOAT.types.mysql = ['FLOAT'];\n  BaseTypes.TIME.types.mysql = ['TIME'];\n  BaseTypes.DATEONLY.types.mysql = ['DATE'];\n  BaseTypes.BOOLEAN.types.mysql = ['TINY'];\n  BaseTypes.BLOB.types.mysql = ['TINYBLOB', 'BLOB', 'LONGBLOB'];\n  BaseTypes.DECIMAL.types.mysql = ['NEWDECIMAL'];\n  BaseTypes.UUID.types.mysql = false;\n  BaseTypes.ENUM.types.mysql = false;\n  BaseTypes.REAL.types.mysql = ['DOUBLE'];\n  BaseTypes.DOUBLE.types.mysql = ['DOUBLE'];\n  BaseTypes.GEOMETRY.types.mysql = ['GEOMETRY'];\n\n  function BLOB(length) {\n    if (!(this instanceof BLOB)) return new BLOB(length);\n    BaseTypes.BLOB.apply(this, arguments);\n  }\n  inherits(BLOB, BaseTypes.BLOB);\n\n  BLOB.parse = function(value, options, next) {\n    const data = next();\n\n    if (Buffer.isBuffer(data) && data.length === 0) {\n      return null;\n    }\n\n    return data;\n  };\n\n  function DECIMAL(precision, scale) {\n    if (!(this instanceof DECIMAL)) return new DECIMAL(precision, scale);\n    BaseTypes.DECIMAL.apply(this, arguments);\n  }\n  inherits(DECIMAL, BaseTypes.DECIMAL);\n\n  DECIMAL.prototype.toSql = function toSql() {\n    let definition = BaseTypes.DECIMAL.prototype.toSql.apply(this);\n\n    if (this._unsigned) {\n      definition += ' UNSIGNED';\n    }\n\n    if (this._zerofill) {\n      definition += ' ZEROFILL';\n    }\n\n    return definition;\n  };\n\n  function DATE(length) {\n    if (!(this instanceof DATE)) return new DATE(length);\n    BaseTypes.DATE.apply(this, arguments);\n  }\n  inherits(DATE, BaseTypes.DATE);\n\n  DATE.prototype.toSql = function toSql() {\n    return 'DATETIME' + (this._length ? '(' + this._length + ')' : '');\n  };\n\n  DATE.prototype._stringify = function _stringify(date, options) {\n    date = BaseTypes.DATE.prototype._applyTimezone(date, options);\n    // Fractional DATETIMEs only supported on MySQL 5.6.4+\n    if (this._length) {\n      return date.format('YYYY-MM-DD HH:mm:ss.SSS');\n    }\n\n    return date.format('YYYY-MM-DD HH:mm:ss');\n  };\n\n  DATE.parse = function parse(value, options) {\n    value = value.string();\n\n    if (value === null) {\n      return value;\n    }\n\n    if (moment.tz.zone(options.timezone)) {\n      value = moment.tz(value, options.timezone).toDate();\n    } else {\n      value = new Date(value + ' ' + options.timezone);\n    }\n\n    return value;\n  };\n\n  function DATEONLY() {\n    if (!(this instanceof DATEONLY)) return new DATEONLY();\n    BaseTypes.DATEONLY.apply(this, arguments);\n  }\n  inherits(DATEONLY, BaseTypes.DATEONLY);\n\n  DATEONLY.parse = function parse(value) {\n    return value.string();\n  };\n\n  function UUID() {\n    if (!(this instanceof UUID)) return new UUID();\n    BaseTypes.UUID.apply(this, arguments);\n  }\n  inherits(UUID, BaseTypes.UUID);\n\n  UUID.prototype.toSql = function toSql() {\n    return 'CHAR(36) BINARY';\n  };\n\n\n  const SUPPORTED_GEOMETRY_TYPES = ['POINT', 'LINESTRING', 'POLYGON'];\n\n  function GEOMETRY(type, srid) {\n    if (!(this instanceof GEOMETRY)) return new GEOMETRY(type, srid);\n    BaseTypes.GEOMETRY.apply(this, arguments);\n\n    if (_.isEmpty(this.type)) {\n      this.sqlType = this.key;\n    } else if (_.includes(SUPPORTED_GEOMETRY_TYPES, this.type)) {\n      this.sqlType = this.type;\n    } else {\n      throw new Error('Supported geometry types are: ' + SUPPORTED_GEOMETRY_TYPES.join(', '));\n    }\n  }\n  inherits(GEOMETRY, BaseTypes.GEOMETRY);\n\n  GEOMETRY.parse = GEOMETRY.prototype.parse = function parse(value) {\n    value = value.buffer();\n\n    // Empty buffer, MySQL doesn't support POINT EMPTY\n    // check, https://dev.mysql.com/worklog/task/?id=2381\n    if (value.length === 0) {\n      return null;\n    }\n\n    // For some reason, discard the first 4 bytes\n    value = value.slice(4);\n\n    return wkx.Geometry.parse(value).toGeoJSON();\n  };\n\n  GEOMETRY.prototype.toSql = function toSql() {\n    return this.sqlType;\n  };\n\n  function ENUM() {\n    if (!(this instanceof ENUM)) {\n      const obj = Object.create(ENUM.prototype);\n      ENUM.apply(obj, arguments);\n      return obj;\n    }\n    BaseTypes.ENUM.apply(this, arguments);\n  }\n  inherits(ENUM, BaseTypes.ENUM);\n\n  ENUM.prototype.toSql = function toSql(options) {\n    return 'ENUM(' + _.map(this.values, value => options.escape(value)).join(', ') + ')';\n  };\n\n  const exports = {\n    ENUM,\n    DATE,\n    DATEONLY,\n    UUID,\n    GEOMETRY,\n    DECIMAL,\n    BLOB\n  };\n\n  _.forIn(exports, (DataType, key) => {\n    if (!DataType.key) DataType.key = key;\n    if (!DataType.extend) {\n      DataType.extend = function extend(oldType) {\n        return new DataType(oldType.options);\n      };\n    }\n  });\n\n  return exports;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/dialects/mysql/data-types.js\n// module id = 60\n// module chunks = 0","'use strict';\n\nconst _ = require('lodash');\nconst inherits = require('../../utils/inherits');\n\nmodule.exports = BaseTypes => {\n  const warn = BaseTypes.ABSTRACT.warn.bind(undefined, 'https://www.sqlite.org/datatype3.html');\n\n  BaseTypes.DATE.types.sqlite = ['DATETIME'];\n  BaseTypes.STRING.types.sqlite = ['VARCHAR', 'VARCHAR BINARY'];\n  BaseTypes.CHAR.types.sqlite = ['CHAR', 'CHAR BINARY'];\n  BaseTypes.TEXT.types.sqlite = ['TEXT'];\n  BaseTypes.INTEGER.types.sqlite = ['INTEGER'];\n  BaseTypes.BIGINT.types.sqlite = ['BIGINT'];\n  BaseTypes.FLOAT.types.sqlite = ['FLOAT'];\n  BaseTypes.TIME.types.sqlite = ['TIME'];\n  BaseTypes.DATEONLY.types.sqlite = ['DATE'];\n  BaseTypes.BOOLEAN.types.sqlite = ['TINYINT'];\n  BaseTypes.BLOB.types.sqlite = ['TINYBLOB', 'BLOB', 'LONGBLOB'];\n  BaseTypes.DECIMAL.types.sqlite = ['DECIMAL'];\n  BaseTypes.UUID.types.sqlite = ['UUID'];\n  BaseTypes.ENUM.types.sqlite = false;\n  BaseTypes.REAL.types.sqlite = ['REAL'];\n  BaseTypes.DOUBLE.types.sqlite = ['DOUBLE PRECISION'];\n  BaseTypes.GEOMETRY.types.sqlite = false;\n  BaseTypes.JSON.types.sqlite = ['JSON', 'JSONB'];\n\n  function JSONTYPE() {\n    if (!(this instanceof JSONTYPE)) return new JSONTYPE();\n    BaseTypes.JSON.apply(this, arguments);\n  }\n  inherits(JSONTYPE, BaseTypes.JSON);\n\n  JSONTYPE.parse = function parse(data) {\n    return JSON.parse(data);\n  };\n\n  function DATE(length) {\n    if (!(this instanceof DATE)) return new DATE(length);\n    BaseTypes.DATE.apply(this, arguments);\n  }\n  inherits(DATE, BaseTypes.DATE);\n\n  DATE.parse = function parse(date, options) {\n    if (date.indexOf('+') === -1) {\n      // For backwards compat. Dates inserted by sequelize < 2.0dev12 will not have a timestamp set\n      return new Date(date + options.timezone);\n    } else {\n      return new Date(date); // We already have a timezone stored in the string\n    }\n  };\n\n  function DATEONLY() {\n    if (!(this instanceof DATEONLY)) return new DATEONLY();\n    BaseTypes.DATEONLY.apply(this, arguments);\n  }\n  inherits(DATEONLY, BaseTypes.DATEONLY);\n\n  DATEONLY.parse = function parse(date) {\n    return date;\n  };\n\n  function STRING(length, binary) {\n    if (!(this instanceof STRING)) return new STRING(length, binary);\n    BaseTypes.STRING.apply(this, arguments);\n  }\n  inherits(STRING, BaseTypes.STRING);\n\n  STRING.prototype.toSql = function toSql() {\n    if (this._binary) {\n      return 'VARCHAR BINARY(' + this._length + ')';\n    } else {\n      return BaseTypes.STRING.prototype.toSql.call(this);\n    }\n  };\n\n  function TEXT(length) {\n    if (!(this instanceof TEXT)) return new TEXT(length);\n    BaseTypes.TEXT.apply(this, arguments);\n  }\n  inherits(TEXT, BaseTypes.TEXT);\n\n  TEXT.prototype.toSql = function toSql() {\n    if (this._length) {\n      warn('SQLite does not support TEXT with options. Plain `TEXT` will be used instead.');\n      this._length = undefined;\n    }\n    return 'TEXT';\n  };\n\n  function CHAR(length, binary) {\n    if (!(this instanceof CHAR)) return new CHAR(length, binary);\n    BaseTypes.CHAR.apply(this, arguments);\n  }\n  inherits(CHAR, BaseTypes.CHAR);\n\n  CHAR.prototype.toSql = function toSql() {\n    if (this._binary) {\n      return 'CHAR BINARY(' + this._length + ')';\n    } else {\n      return BaseTypes.CHAR.prototype.toSql.call(this);\n    }\n  };\n\n  function NUMBER(options) {\n    if (!(this instanceof NUMBER)) return new NUMBER(options);\n    BaseTypes.NUMBER.apply(this, arguments);\n  }\n  inherits(NUMBER, BaseTypes.NUMBER);\n\n  NUMBER.prototype.toSql = function toSql() {\n    let result = this.key;\n\n    if (this._unsigned) {\n      result += ' UNSIGNED';\n    }\n    if (this._zerofill) {\n      result += ' ZEROFILL';\n    }\n\n    if (this._length) {\n      result += '(' + this._length;\n      if (typeof this._decimals === 'number') {\n        result += ',' + this._decimals;\n      }\n      result += ')';\n    }\n    return result;\n  };\n\n  function INTEGER(length) {\n    if (!(this instanceof INTEGER)) return new INTEGER(length);\n    BaseTypes.INTEGER.apply(this, arguments);\n  }\n  inherits(INTEGER, BaseTypes.INTEGER);\n\n  INTEGER.prototype.toSql = function toSql() {\n    return NUMBER.prototype.toSql.call(this);\n  };\n\n  function BIGINT(length) {\n    if (!(this instanceof BIGINT)) return new BIGINT(length);\n    BaseTypes.BIGINT.apply(this, arguments);\n  }\n  inherits(BIGINT, BaseTypes.BIGINT);\n\n  BIGINT.prototype.toSql = function toSql() {\n    return NUMBER.prototype.toSql.call(this);\n  };\n\n  function FLOAT(length, decimals) {\n    if (!(this instanceof FLOAT)) return new FLOAT(length, decimals);\n    BaseTypes.FLOAT.apply(this, arguments);\n  }\n  inherits(FLOAT, BaseTypes.FLOAT);\n  FLOAT.prototype.toSql = function toSql() {\n    return NUMBER.prototype.toSql.call(this);\n  };\n\n  function DOUBLE(length, decimals) {\n    if (!(this instanceof DOUBLE)) return new DOUBLE(length, decimals);\n    BaseTypes.DOUBLE.apply(this, arguments);\n  }\n  inherits(DOUBLE, BaseTypes.DOUBLE);\n  DOUBLE.prototype.toSql = function toSql() {\n    return NUMBER.prototype.toSql.call(this);\n  };\n\n  function REAL(length, decimals) {\n    if (!(this instanceof REAL)) return new REAL(length, decimals);\n    BaseTypes.REAL.apply(this, arguments);\n  }\n  inherits(REAL, BaseTypes.REAL);\n  REAL.prototype.toSql = function toSql() {\n    return NUMBER.prototype.toSql.call(this);\n  };\n\n  [FLOAT, DOUBLE, REAL].forEach(floating => {\n    floating.parse = function parse(value) {\n      if (_.isString(value)) {\n        if (value === 'NaN') {\n          return NaN;\n        } else if (value === 'Infinity') {\n          return Infinity;\n        } else if (value === '-Infinity') {\n          return -Infinity;\n        }\n      }\n      return value;\n    };\n  });\n\n  function ENUM() {\n    if (!(this instanceof ENUM)) {\n      const obj = Object.create(ENUM.prototype);\n      ENUM.apply(obj, arguments);\n      return obj;\n    }\n    BaseTypes.ENUM.apply(this, arguments);\n  }\n  inherits(ENUM, BaseTypes.ENUM);\n\n  ENUM.prototype.toSql = function toSql() {\n    return 'TEXT';\n  };\n\n  const exports = {\n    DATE,\n    DATEONLY,\n    STRING,\n    CHAR,\n    NUMBER,\n    FLOAT,\n    REAL,\n    'DOUBLE PRECISION': DOUBLE,\n    INTEGER,\n    BIGINT,\n    TEXT,\n    ENUM,\n    JSON: JSONTYPE\n  };\n\n  _.forIn(exports, (DataType, key) => {\n    if (!DataType.key) DataType.key = key;\n    if (!DataType.extend) {\n      DataType.extend = oldType => {\n        return new DataType(oldType.options);\n      };\n    }\n  });\n\n  return exports;\n\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/dialects/sqlite/data-types.js\n// module id = 61\n// module chunks = 0","'use strict';\n\nconst _ = require('lodash');\nconst moment = require('moment');\nconst inherits = require('../../utils/inherits');\n\nmodule.exports = BaseTypes => {\n  const warn = BaseTypes.ABSTRACT.warn.bind(undefined, 'https://msdn.microsoft.com/en-us/library/ms187752%28v=sql.110%29.aspx');\n\n  BaseTypes.DATE.types.mssql = [43];\n  BaseTypes.STRING.types.mssql = [231, 173];\n  BaseTypes.CHAR.types.mssql = [175];\n  BaseTypes.TEXT.types.mssql = false;\n  BaseTypes.INTEGER.types.mssql = [38];\n  BaseTypes.BIGINT.types.mssql = false;\n  BaseTypes.FLOAT.types.mssql = [109];\n  BaseTypes.TIME.types.mssql = [41];\n  BaseTypes.DATEONLY.types.mssql = [40];\n  BaseTypes.BOOLEAN.types.mssql = [104];\n  BaseTypes.BLOB.types.mssql = [165];\n  BaseTypes.DECIMAL.types.mssql = [106];\n  BaseTypes.UUID.types.mssql = false;\n  BaseTypes.ENUM.types.mssql = false;\n  BaseTypes.REAL.types.mssql = [109];\n  BaseTypes.DOUBLE.types.mssql = [109];\n  // BaseTypes.GEOMETRY.types.mssql = [240]; // not yet supported\n  BaseTypes.GEOMETRY.types.mssql = false;\n\n  function BLOB(length) {\n    if (!(this instanceof BLOB)) return new BLOB(length);\n    BaseTypes.BLOB.apply(this, arguments);\n  }\n  inherits(BLOB, BaseTypes.BLOB);\n\n  BLOB.prototype.toSql = function toSql() {\n    if (this._length) {\n      if (this._length.toLowerCase() === 'tiny') { // tiny = 2^8\n        warn('MSSQL does not support BLOB with the `length` = `tiny` option. `VARBINARY(256)` will be used instead.');\n        return 'VARBINARY(256)';\n      }\n      warn('MSSQL does not support BLOB with the `length` option. `VARBINARY(MAX)` will be used instead.');\n    }\n    return 'VARBINARY(MAX)';\n  };\n\n  BLOB.prototype._hexify = function _hexify(hex) {\n    return '0x' + hex;\n  };\n\n  function STRING(length, binary) {\n    if (!(this instanceof STRING)) return new STRING(length, binary);\n    BaseTypes.STRING.apply(this, arguments);\n  }\n  inherits(STRING, BaseTypes.STRING);\n\n  STRING.prototype.toSql = function toSql() {\n    if (!this._binary) {\n      return 'NVARCHAR(' + this._length + ')';\n    } else {\n      return 'BINARY(' + this._length + ')';\n    }\n  };\n\n  STRING.prototype.escape = false;\n  STRING.prototype._stringify = function _stringify(value, options) {\n    if (this._binary) {\n      return BLOB.prototype._stringify(value);\n    } else {\n      return options.escape(value);\n    }\n  };\n\n  function TEXT(length) {\n    if (!(this instanceof TEXT)) return new TEXT(length);\n    BaseTypes.TEXT.apply(this, arguments);\n  }\n  inherits(TEXT, BaseTypes.TEXT);\n\n  TEXT.prototype.toSql = function toSql() {\n    // TEXT is deprecated in mssql and it would normally be saved as a non-unicode string.\n    // Using unicode is just future proof\n    if (this._length) {\n      if (this._length.toLowerCase() === 'tiny') { // tiny = 2^8\n        warn('MSSQL does not support TEXT with the `length` = `tiny` option. `NVARCHAR(256)` will be used instead.');\n        return 'NVARCHAR(256)';\n      }\n      warn('MSSQL does not support TEXT with the `length` option. `NVARCHAR(MAX)` will be used instead.');\n    }\n    return 'NVARCHAR(MAX)';\n  };\n\n  function BOOLEAN() {\n    if (!(this instanceof BOOLEAN)) return new BOOLEAN();\n    BaseTypes.BOOLEAN.apply(this, arguments);\n  }\n  inherits(BOOLEAN, BaseTypes.BOOLEAN);\n\n  BOOLEAN.prototype.toSql = function toSql() {\n    return 'BIT';\n  };\n\n  function UUID() {\n    if (!(this instanceof UUID)) return new UUID();\n    BaseTypes.UUID.apply(this, arguments);\n  }\n  inherits(UUID, BaseTypes.UUID);\n\n  UUID.prototype.toSql = function toSql() {\n    return 'CHAR(36)';\n  };\n\n  function NOW() {\n    if (!(this instanceof NOW)) return new NOW();\n    BaseTypes.NOW.apply(this, arguments);\n  }\n  inherits(NOW, BaseTypes.NOW);\n\n  NOW.prototype.toSql = function toSql() {\n    return 'GETDATE()';\n  };\n\n  function DATE(length) {\n    if (!(this instanceof DATE)) return new DATE(length);\n    BaseTypes.DATE.apply(this, arguments);\n  }\n  inherits(DATE, BaseTypes.DATE);\n\n  DATE.prototype.toSql = function toSql() {\n    return 'DATETIMEOFFSET';\n  };\n\n  function DATEONLY() {\n    if (!(this instanceof DATEONLY)) return new DATEONLY();\n    BaseTypes.DATEONLY.apply(this, arguments);\n  }\n  inherits(DATEONLY, BaseTypes.DATEONLY);\n\n  DATEONLY.parse = function(value) {\n    return moment(value).format('YYYY-MM-DD');\n  };\n\n  function INTEGER(length) {\n    if (!(this instanceof INTEGER)) return new INTEGER(length);\n    BaseTypes.INTEGER.apply(this, arguments);\n\n    // MSSQL does not support any options for integer\n    if (this._length || this.options.length || this._unsigned || this._zerofill) {\n      warn('MSSQL does not support INTEGER with options. Plain `INTEGER` will be used instead.');\n      this._length = undefined;\n      this.options.length = undefined;\n      this._unsigned = undefined;\n      this._zerofill = undefined;\n    }\n  }\n  inherits(INTEGER, BaseTypes.INTEGER);\n\n  function BIGINT(length) {\n    if (!(this instanceof BIGINT)) return new BIGINT(length);\n    BaseTypes.BIGINT.apply(this, arguments);\n\n    // MSSQL does not support any options for bigint\n    if (this._length || this.options.length || this._unsigned || this._zerofill) {\n      warn('MSSQL does not support BIGINT with options. Plain `BIGINT` will be used instead.');\n      this._length = undefined;\n      this.options.length = undefined;\n      this._unsigned = undefined;\n      this._zerofill = undefined;\n    }\n  }\n  inherits(BIGINT, BaseTypes.BIGINT);\n\n  function REAL(length, decimals) {\n    if (!(this instanceof REAL)) return new REAL(length, decimals);\n    BaseTypes.REAL.apply(this, arguments);\n\n    // MSSQL does not support any options for real\n    if (this._length || this.options.length || this._unsigned || this._zerofill) {\n      warn('MSSQL does not support REAL with options. Plain `REAL` will be used instead.');\n      this._length = undefined;\n      this.options.length = undefined;\n      this._unsigned = undefined;\n      this._zerofill = undefined;\n    }\n  }\n  inherits(REAL, BaseTypes.REAL);\n\n  function FLOAT(length, decimals) {\n    if (!(this instanceof FLOAT)) return new FLOAT(length, decimals);\n    BaseTypes.FLOAT.apply(this, arguments);\n\n    // MSSQL does only support lengths as option.\n    // Values between 1-24 result in 7 digits precision (4 bytes storage size)\n    // Values between 25-53 result in 15 digits precision (8 bytes storage size)\n    // If decimals are provided remove these and print a warning\n    if (this._decimals) {\n      warn('MSSQL does not support Float with decimals. Plain `FLOAT` will be used instead.');\n      this._length = undefined;\n      this.options.length = undefined;\n    }\n    if (this._unsigned) {\n      warn('MSSQL does not support Float unsigned. `UNSIGNED` was removed.');\n      this._unsigned = undefined;\n    }\n    if (this._zerofill) {\n      warn('MSSQL does not support Float zerofill. `ZEROFILL` was removed.');\n      this._zerofill = undefined;\n    }\n  }\n  inherits(FLOAT, BaseTypes.FLOAT);\n\n  function ENUM() {\n    if (!(this instanceof ENUM)) {\n      const obj = Object.create(ENUM.prototype);\n      ENUM.apply(obj, arguments);\n      return obj;\n    }\n    BaseTypes.ENUM.apply(this, arguments);\n  }\n  inherits(ENUM, BaseTypes.ENUM);\n\n  ENUM.prototype.toSql = function toSql() {\n    return 'VARCHAR(255)';\n  };\n\n  const exports = {\n    BLOB,\n    BOOLEAN,\n    ENUM,\n    STRING,\n    UUID,\n    DATE,\n    DATEONLY,\n    NOW,\n    INTEGER,\n    BIGINT,\n    REAL,\n    FLOAT,\n    TEXT\n  };\n\n  _.forIn(exports, (DataType, key) => {\n    if (!DataType.key) DataType.key = key;\n    if (!DataType.extend) {\n      DataType.extend = function extend(oldType) {\n        return new DataType(oldType.options);\n      };\n    }\n  });\n\n  return exports;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/dialects/mssql/data-types.js\n// module id = 62\n// module chunks = 0","'use strict';\n\nconst _ = require('lodash');\nconst util = require('util');\nconst Utils = require('../utils');\n\nfunction validateDeprecation(value, expectation, options) {\n  if (!options.deprecated) {\n    return;\n  }\n\n  const valid = value instanceof options.deprecated || Object.prototype.toString.call(value) === Object.prototype.toString.call(options.deprecated.call());\n\n  if (valid) {\n    const message = `${util.inspect(value)} should not be of type \"${options.deprecated.name}\"`;\n    Utils.deprecate(options.deprecationWarning || message);\n  }\n\n  return valid;\n}\n\nfunction validate(value, expectation) {\n  // the second part of this check is a workaround to deal with an issue that occurs in node-webkit when\n  // using object literals.  https://github.com/sequelize/sequelize/issues/2685\n  if (value instanceof expectation || Object.prototype.toString.call(value) === Object.prototype.toString.call(expectation.call())) {\n    return true;\n  }\n\n  throw new Error(`The parameter (value: ${value}) is no ${expectation.name}`);\n}\n\nfunction check(value, expectation, options) {\n  options = _.extend({\n    deprecated: false,\n    index: null,\n    method: null,\n    optional: false\n  }, options || {});\n\n  if (!value && options.optional) {\n    return true;\n  }\n\n  if (value === undefined) {\n    throw new Error('No value has been passed.');\n  }\n\n  if (expectation === undefined) {\n    throw new Error('No expectation has been passed.');\n  }\n\n  return false\n    || validateDeprecation(value, expectation, options)\n    || validate(value, expectation, options);\n}\n\nmodule.exports = check;\nmodule.exports.check = check;\nmodule.exports.default = check;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/utils/parameter-validator.js\n// module id = 63\n// module chunks = 0","'use strict';\n\n/**\n * Sequelize module for debug and deprecation messages.\n * It require a `context` for which messages will be printed.\n *\n * @module logging\n * @private\n */\n\nconst depd = require('depd'),\n  debug = require('debug'),\n  _ = require('lodash');\n\nclass Logger {\n  constructor(config) {\n\n    this.config = _.extend({\n      context: 'sequelize',\n      debug: true\n    }, config || {});\n\n    this.depd = depd(this.config.context);\n    this.debug = debug(this.config.context);\n  }\n\n  deprecate(message) {\n    this.depd(message);\n  }\n\n  debug(message) {\n    this.config.debug && this.debug(message);\n  }\n\n  warn(message) {\n    console.warn(`(${this.config.context}) Warning: ${message}`);\n  }\n\n  debugContext(childContext) {\n    if (!childContext) {\n      throw new Error('No context supplied to debug');\n    }\n    return debug([this.config.context, childContext].join(':'));\n  }\n}\n\nmodule.exports = Logger;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/utils/logger.js\n// module id = 64\n// module chunks = 0","module.exports = require(\"depd\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"depd\"\n// module id = 65\n// module chunks = 0","module.exports = require(\"debug\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"debug\"\n// module id = 66\n// module chunks = 0","module.exports = require(\"bluebird\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"bluebird\"\n// module id = 67\n// module chunks = 0","module.exports = require(\"inflection\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"inflection\"\n// module id = 68\n// module chunks = 0","'use strict';\n\nconst validator = require('./utils/validator-extras').validator;\nconst extendModelValidations = require('./utils/validator-extras').extendModelValidations;\nconst Utils = require('./utils');\nconst sequelizeError = require('./errors');\nconst Promise = require('./promise');\nconst DataTypes = require('./data-types');\nconst _ = require('lodash');\n\n/**\n * The Main Instance Validator.\n *\n * @param {Instance} modelInstance The model instance.\n * @param {Object} options A dict with options.\n * @constructor\n * @private\n */\nclass InstanceValidator {\n\n  constructor(modelInstance, options) {\n    options = _.clone(options) || {};\n\n    if (options.fields && !options.skip) {\n      options.skip = Utils._.difference(Object.keys(modelInstance.constructor.rawAttributes), options.fields);\n    }\n\n    // assign defined and default options\n    this.options = Utils._.defaults(options, {\n      skip: [],\n      hooks: true\n    });\n\n    this.modelInstance = modelInstance;\n\n    /**\n     * Exposes a reference to validator.js. This allows you to add custom validations using `validator.extend`\n     * @name validator\n     * @private\n     */\n    this.validator = validator;\n\n    /**\n     *  All errors will be stored here from the validations.\n     *\n     * @type {Array} Will contain keys that correspond to attributes which will\n     *   be Arrays of Errors.\n     * @private\n     */\n    this.errors = [];\n\n    /**\n     * @type {boolean} Indicates if validations are in progress\n     * @private\n     */\n    this.inProgress = false;\n\n    extendModelValidations(modelInstance);\n  }\n\n  /**\n   * The main entry point for the Validation module, invoke to start the dance.\n   *\n   * @return {Promise}\n   * @private\n   */\n  _validate() {\n    if (this.inProgress) {\n      throw new Error('Validations already in progress.');\n    }\n    this.inProgress = true;\n\n    return Promise.all(\n      [this._builtinValidators(), this._customValidators()].map(promise => promise.reflect())\n    ).then(() => {\n      if (this.errors.length) {\n        throw new sequelizeError.ValidationError(null, this.errors);\n      }\n    });\n  }\n\n  /**\n   * Invoke the Validation sequence and run validation hooks if defined\n   *   - Before Validation Model Hooks\n   *   - Validation\n   *   - On validation success: After Validation Model Hooks\n   *   - On validation failure: Validation Failed Model Hooks\n   *\n   * @return {Promise}\n   * @private\n   */\n  validate() {\n    return this.options.hooks ? this._validateAndRunHooks() : this._validate();\n  }\n\n  /**\n   * Invoke the Validation sequence and run hooks\n   *   - Before Validation Model Hooks\n   *   - Validation\n   *   - On validation success: After Validation Model Hooks\n   *   - On validation failure: Validation Failed Model Hooks\n   *\n   * @return {Promise}\n   * @private\n   */\n  _validateAndRunHooks() {\n    const runHooks = this.modelInstance.constructor.runHooks.bind(this.modelInstance.constructor);\n    return runHooks('beforeValidate', this.modelInstance, this.options)\n      .then(() =>\n        this._validate()\n          .catch(error => runHooks('validationFailed', this.modelInstance, this.options, error)\n            .then(newError => { throw newError || error; }))\n      )\n      .then(() => runHooks('afterValidate', this.modelInstance, this.options))\n      .return(this.modelInstance);\n  }\n\n  /**\n   * Will run all the built-in validators.\n   *\n   * @return {Promise(Array.<Promise.PromiseInspection>)} A promise from .reflect().\n   * @private\n   */\n  _builtinValidators() {\n    // promisify all attribute invocations\n    const validators = [];\n    Utils._.forIn(this.modelInstance.rawAttributes, (rawAttribute, field) => {\n      if (this.options.skip.indexOf(field) >= 0) {\n        return;\n      }\n\n      const value = this.modelInstance.dataValues[field];\n\n      if (!rawAttribute._autoGenerated && !rawAttribute.autoIncrement) {\n        // perform validations based on schema\n        this._validateSchema(rawAttribute, field, value);\n      }\n\n      if (this.modelInstance.validators.hasOwnProperty(field)) {\n        validators.push(this._builtinAttrValidate.call(this, value, field).reflect());\n      }\n    });\n\n    return Promise.all(validators);\n  }\n\n  /**\n   * Will run all the custom validators.\n   *\n   * @return {Promise(Array.<Promise.PromiseInspection>)} A promise from .reflect().\n   * @private\n   */\n  _customValidators() {\n    const validators = [];\n    Utils._.each(this.modelInstance._modelOptions.validate, (validator, validatorType) => {\n      if (this.options.skip.indexOf(validatorType) >= 0) {\n        return;\n      }\n\n      const valprom = this._invokeCustomValidator(validator, validatorType)\n        // errors are handled in settling, stub this\n        .catch(() => {})\n        .reflect();\n\n      validators.push(valprom);\n    });\n\n    return Promise.all(validators);\n  }\n\n  /**\n   * Validate a single attribute with all the defined built-in validators.\n   *\n   * @param {*} value Anything.\n   * @param {string} field The field name.\n   * @return {Promise} A promise, will always resolve,\n   *   auto populates error on this.error local object.\n   * @private\n   */\n  _builtinAttrValidate(value, field) {\n    // check if value is null (if null not allowed the Schema pass will capture it)\n    if (value === null || typeof value === 'undefined') {\n      return Promise.resolve();\n    }\n\n    // Promisify each validator\n    const validators = [];\n    Utils._.forIn(this.modelInstance.validators[field], (test, validatorType) => {\n\n      if (['isUrl', 'isURL', 'isEmail'].indexOf(validatorType) !== -1) {\n        // Preserve backwards compat. Validator.js now expects the second param to isURL and isEmail to be an object\n        if (typeof test === 'object' && test !== null && test.msg) {\n          test = {\n            msg: test.msg\n          };\n        } else if (test === true) {\n          test = {};\n        }\n      }\n\n      // Check for custom validator.\n      if (typeof test === 'function') {\n        return validators.push(this._invokeCustomValidator(test, validatorType, true, value, field).reflect());\n      }\n\n      const validatorPromise = this._invokeBuiltinValidator(value, test, validatorType, field);\n      // errors are handled in settling, stub this\n      validatorPromise.catch(() => {});\n      validators.push(validatorPromise.reflect());\n    });\n\n    return Promise\n      .all(validators)\n      .then(results => this._handleReflectedResult(field, value, results));\n  }\n\n  /**\n   * Prepare and invoke a custom validator.\n   *\n   * @param {Function} validator The custom validator.\n   * @param {string} validatorType the custom validator type (name).\n   * @param {boolean=} optAttrDefined Set to true if custom validator was defined\n   *   from the Attribute\n   * @return {Promise} A promise.\n   * @private\n   */\n  _invokeCustomValidator(validator, validatorType, optAttrDefined, optValue, optField) {\n    let validatorFunction = null;  // the validation function to call\n    let isAsync = false;\n\n    const validatorArity = validator.length;\n    // check if validator is async and requires a callback\n    let asyncArity = 1;\n    let errorKey = validatorType;\n    let invokeArgs;\n    if (optAttrDefined) {\n      asyncArity = 2;\n      invokeArgs = optValue;\n      errorKey = optField;\n    }\n    if (validatorArity === asyncArity) {\n      isAsync = true;\n    }\n\n    if (isAsync) {\n      if (optAttrDefined) {\n        validatorFunction = Promise.promisify(validator.bind(this.modelInstance, invokeArgs));\n      } else {\n        validatorFunction = Promise.promisify(validator.bind(this.modelInstance));\n      }\n      return validatorFunction()\n        .catch(e => this._pushError(false, errorKey, e, optValue));\n    } else {\n      return Promise\n        .try(() => validator.call(this.modelInstance, invokeArgs))\n        .catch(e => this._pushError(false, errorKey, e, optValue));\n    }\n  }\n\n  /**\n   * Prepare and invoke a build-in validator.\n   *\n   * @param {*} value Anything.\n   * @param {*} test The test case.\n   * @param {string} validatorType One of known to Sequelize validators.\n   * @param {string} field The field that is being validated\n   * @return {Object} An object with specific keys to invoke the validator.\n   * @private\n   */\n  _invokeBuiltinValidator(value, test, validatorType, field) {\n    return Promise.try(() => {\n      // Cast value as string to pass new Validator.js string requirement\n      const valueString = String(value);\n      // check if Validator knows that kind of validation test\n      if (typeof validator[validatorType] !== 'function') {\n        throw new Error('Invalid validator function: ' + validatorType);\n      }\n      const validatorArgs = this._extractValidatorArgs(test, validatorType, field);\n      if (!validator[validatorType].apply(validator, [valueString].concat(validatorArgs))) {\n      // extract the error msg\n        throw new Error(test.msg || `Validation ${validatorType} on ${field} failed`);\n      }\n    });\n  }\n\n  /**\n   * Will extract arguments for the validator.\n   *\n   * @param {*} test The test case.\n   * @param {string} validatorType One of known to Sequelize validators.\n   * @param {string} field The field that is being validated.\n   * @private\n   */\n  _extractValidatorArgs(test, validatorType, field) {\n    let validatorArgs = test.args || test;\n    const isLocalizedValidator = typeof validatorArgs !== 'string' && (validatorType === 'isAlpha' || validatorType === 'isAlphanumeric' || validatorType === 'isMobilePhone');\n\n    if (!Array.isArray(validatorArgs)) {\n      if (validatorType === 'isImmutable') {\n        validatorArgs = [validatorArgs, field];\n      } else if (isLocalizedValidator || validatorType === 'isIP') {\n        validatorArgs = [];\n      } else {\n        validatorArgs = [validatorArgs];\n      }\n    } else {\n      validatorArgs = validatorArgs.slice(0);\n    }\n    return validatorArgs;\n  }\n\n  /**\n   * Will validate a single field against its schema definition (isnull).\n   *\n   * @param {Object} rawAttribute As defined in the Schema.\n   * @param {string} field The field name.\n   * @param {*} value anything.\n   * @private\n   */\n  _validateSchema(rawAttribute, field, value) {\n    let error;\n\n    if (rawAttribute.allowNull === false && (value === null || value === undefined)) {\n      const validators = this.modelInstance.validators[field];\n      const errMsg = _.get(validators, 'notNull.msg', `${field} cannot be null`);\n      error = new sequelizeError.ValidationErrorItem(errMsg, 'notNull Violation', field, value);\n      this.errors.push(error);\n    }\n\n    if (rawAttribute.type === DataTypes.STRING || rawAttribute.type instanceof DataTypes.STRING || rawAttribute.type === DataTypes.TEXT || rawAttribute.type instanceof DataTypes.TEXT) {\n      if (Array.isArray(value) || _.isObject(value) && !(value instanceof Utils.SequelizeMethod) && !Buffer.isBuffer(value)) {\n        error = new sequelizeError.ValidationErrorItem(`${field} cannot be an array or an object`, 'string violation', field, value);\n        this.errors.push(error);\n      }\n    }\n  }\n\n\n  /**\n   * Handles the returned result of a Promise.reflect.\n   *\n   * If errors are found it populates this.error.\n   *\n   * @param {string} field The attribute name.\n   * @param {string|number} value The data value.\n   * @param {Array.<Promise.PromiseInspection>} Promise inspection objects.\n   * @private\n   */\n  _handleReflectedResult(field, value, promiseInspections) {\n    for (const promiseInspection of promiseInspections) {\n      if (promiseInspection.isRejected()) {\n        const rejection = promiseInspection.error();\n        this._pushError(true, field, rejection, value);\n      }\n    }\n  }\n\n  /**\n   * Signs all errors retaining the original.\n   *\n   * @param {boolean} isBuiltin Determines if error is from builtin validator.\n   * @param {string} errorKey The error key to assign on this.errors object.\n   * @param {Error|string} rawError The original error.\n   * @param {string|number} value The data that triggered the error.\n   * @private\n   */\n  _pushError(isBuiltin, errorKey, rawError, value) {\n    const message = rawError.message || rawError || 'Validation error';\n    const error = new sequelizeError.ValidationErrorItem(message, 'Validation error', errorKey, value);\n    error[InstanceValidator.RAW_KEY_NAME] = rawError;\n\n    this.errors.push(error);\n  }\n}\n/**\n * @define {string} The error key for arguments as passed by custom validators\n * @private\n */\nInstanceValidator.RAW_KEY_NAME = '__raw';\n\nmodule.exports = InstanceValidator;\nmodule.exports.InstanceValidator = InstanceValidator;\nmodule.exports.default = InstanceValidator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/instance-validator.js\n// module id = 69\n// module chunks = 0","'use strict';\n\nconst Utils = require('./../utils');\nconst _ = require('lodash');\nconst HasOne = require('./has-one');\nconst HasMany = require('./has-many');\nconst BelongsToMany = require('./belongs-to-many');\nconst BelongsTo = require('./belongs-to');\n\nconst Mixin = {\n  hasMany(target, options) { // testhint options:none\n    if (!target || !target.prototype || !(target.prototype instanceof this.sequelize.Model)) {\n      throw new Error(this.name + '.hasMany called with something that\\'s not a subclass of Sequelize.Model');\n    }\n\n    const source = this;\n\n    // Since this is a mixin, we'll need a unique letiable name for hooks (since Model will override our hooks option)\n    options = options || {};\n    options.hooks = options.hooks === undefined ? false : Boolean(options.hooks);\n    options.useHooks = options.hooks;\n\n    options = _.extend(options, _.omit(source.options, ['hooks']));\n\n    // the id is in the foreign table or in a connecting table\n    const association = new HasMany(source, target, options);\n    source.associations[association.associationAccessor] = association;\n\n    association.injectAttributes();\n    association.mixin(source.prototype);\n\n    return association;\n  },\n\n  belongsToMany(targetModel, options) { // testhint options:none\n    if (!targetModel || !targetModel.prototype || !(targetModel.prototype instanceof this.sequelize.Model)) {\n      throw new Error(this.name + '.belongsToMany called with something that\\'s not a subclass of Sequelize.Model');\n    }\n\n    const sourceModel = this;\n\n    // Since this is a mixin, we'll need a unique letiable name for hooks (since Model will override our hooks option)\n    options = options || {};\n    options.hooks = options.hooks === undefined ? false : Boolean(options.hooks);\n    options.useHooks = options.hooks;\n    options.timestamps = options.timestamps === undefined ? this.sequelize.options.timestamps : options.timestamps;\n    options = _.extend(options, _.omit(sourceModel.options, ['hooks', 'timestamps', 'scopes', 'defaultScope']));\n\n    // the id is in the foreign table or in a connecting table\n    const association = new BelongsToMany(sourceModel, targetModel, options);\n    sourceModel.associations[association.associationAccessor] = association;\n\n    association.injectAttributes();\n    association.mixin(sourceModel.prototype);\n\n    return association;\n  },\n\n  getAssociations(target) {\n    return _.values(this.associations).filter(association => association.target.name === target.name);\n  },\n\n  getAssociationForAlias(target, alias) {\n    // Two associations cannot have the same alias, so we can use find instead of filter\n    return this.getAssociations(target).find(association => this.verifyAssociationAlias(association, alias)) || null;\n  },\n\n  verifyAssociationAlias(association, alias) {\n    if (alias) {\n      return association.as === alias;\n    } else {\n      return !association.isAliased;\n    }\n  }\n};\n\n// The logic for hasOne and belongsTo is exactly the same\nfunction singleLinked(Type) {\n  return function(target, options) { // testhint options:none\n    if (!target || !target.prototype || !(target.prototype instanceof this.sequelize.Model)) {\n      throw new Error(this.name + '.' + Utils.lowercaseFirst(Type.toString()) + ' called with something that\\'s not a subclass of Sequelize.Model');\n    }\n\n    const source = this;\n\n    // Since this is a mixin, we'll need a unique letiable name for hooks (since Model will override our hooks option)\n    options = options || {};\n    options.hooks = options.hooks === undefined ? false : Boolean(options.hooks);\n    options.useHooks = options.hooks;\n\n    // the id is in the foreign table\n    const association = new Type(source, target, _.extend(options, source.options));\n    source.associations[association.associationAccessor] = association;\n\n    association.injectAttributes();\n    association.mixin(source.prototype);\n\n    return association;\n  };\n}\n\nMixin.hasOne = singleLinked(HasOne);\n\nMixin.belongsTo = singleLinked(BelongsTo);\n\nmodule.exports = Mixin;\nmodule.exports.Mixin = Mixin;\nmodule.exports.default = Mixin;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/associations/mixin.js\n// module id = 70\n// module chunks = 0","module.exports = require(\"assert\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"assert\"\n// module id = 71\n// module chunks = 0","'use strict';\n\nconst util = require('util');\n\n\n/**\n * A collection of properties related to deferrable constraints. It can be used to\n * make foreign key constraints deferrable and to set the constraints within a\n * transaction. This is only supported in PostgreSQL.\n *\n * The foreign keys can be configured like this. It will create a foreign key\n * that will check the constraints immediately when the data was inserted.\n *\n * ```js\n * sequelize.define('Model', {\n *   foreign_id: {\n *     type: Sequelize.INTEGER,\n *     references: {\n *       model: OtherModel,\n *       key: 'id',\n *       deferrable: Sequelize.Deferrable.INITIALLY_IMMEDIATE\n *     }\n *   }\n * });\n * ```\n *\n * The constraints can be configured in a transaction like this. It will\n * trigger a query once the transaction has been started and set the constraints\n * to be checked at the very end of the transaction.\n *\n * ```js\n * sequelize.transaction({\n *   deferrable: Sequelize.Deferrable.SET_DEFERRED\n * });\n * ```\n *\n * @property INITIALLY_DEFERRED Defer constraints checks to the end of transactions.\n * @property INITIALLY_IMMEDIATE Trigger the constraint checks immediately\n * @property NOT Set the constraints to not deferred. This is the default in PostgreSQL and it make it impossible to dynamically defer the constraints within a transaction.\n * @property SET_DEFERRED\n * @property SET_IMMEDIATE\n */\nconst Deferrable = module.exports = {\n  INITIALLY_DEFERRED,\n  INITIALLY_IMMEDIATE,\n  NOT,\n  SET_DEFERRED,\n  SET_IMMEDIATE\n};\n\nfunction ABSTRACT() {}\n\nABSTRACT.prototype.toString = function() {\n  return this.toSql.apply(this, arguments);\n};\n\nfunction INITIALLY_DEFERRED() {\n  if (!(this instanceof INITIALLY_DEFERRED)) {\n    return new INITIALLY_DEFERRED();\n  }\n}\nutil.inherits(INITIALLY_DEFERRED, ABSTRACT);\n\nINITIALLY_DEFERRED.prototype.toSql = function() {\n  return 'DEFERRABLE INITIALLY DEFERRED';\n};\n\nfunction INITIALLY_IMMEDIATE() {\n  if (!(this instanceof INITIALLY_IMMEDIATE)) {\n    return new INITIALLY_IMMEDIATE();\n  }\n}\nutil.inherits(INITIALLY_IMMEDIATE, ABSTRACT);\n\nINITIALLY_IMMEDIATE.prototype.toSql = function() {\n  return 'DEFERRABLE INITIALLY IMMEDIATE';\n};\n\nfunction NOT() {\n  if (!(this instanceof NOT)) {\n    return new NOT();\n  }\n}\nutil.inherits(NOT, ABSTRACT);\n\nNOT.prototype.toSql = function() {\n  return 'NOT DEFERRABLE';\n};\n\nfunction SET_DEFERRED(constraints) {\n  if (!(this instanceof SET_DEFERRED)) {\n    return new SET_DEFERRED(constraints);\n  }\n\n  this.constraints = constraints;\n}\nutil.inherits(SET_DEFERRED, ABSTRACT);\n\nSET_DEFERRED.prototype.toSql = function(queryGenerator) {\n  return queryGenerator.setDeferredQuery(this.constraints);\n};\n\nfunction SET_IMMEDIATE(constraints) {\n  if (!(this instanceof SET_IMMEDIATE)) {\n    return new SET_IMMEDIATE(constraints);\n  }\n\n  this.constraints = constraints;\n}\nutil.inherits(SET_IMMEDIATE, ABSTRACT);\n\nSET_IMMEDIATE.prototype.toSql = function(queryGenerator) {\n  return queryGenerator.setImmediateQuery(this.constraints);\n};\n\nObject.keys(Deferrable).forEach(key => {\n  const DeferrableType = Deferrable[key];\n\n  DeferrableType.toString = function() {\n    const instance = new DeferrableType();\n    return instance.toString.apply(instance, arguments);\n  };\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/deferrable.js\n// module id = 72\n// module chunks = 0","'use strict';\n\nconst Toposort = require('toposort-class');\nconst _ = require('lodash');\n\nclass ModelManager {\n  constructor(sequelize) {\n    this.models = [];\n    this.sequelize = sequelize;\n  }\n\n  addModel(model) {\n    this.models.push(model);\n    this.sequelize.models[model.name] = model;\n\n    return model;\n  }\n\n  removeModel(modelToRemove) {\n    this.models = this.models.filter(model => model.name !== modelToRemove.name);\n\n    delete this.sequelize.models[modelToRemove.name];\n  }\n\n  getModel(against, options) {\n    options = _.defaults(options || {}, {\n      attribute: 'name'\n    });\n\n    const model = this.models.filter(model => model[options.attribute] === against);\n\n    return model ? model[0] : null;\n  }\n\n  get all() {\n    return this.models;\n  }\n\n  /**\n   * Iterate over Models in an order suitable for e.g. creating tables. Will\n   * take foreign key constraints into account so that dependencies are visited\n   * before dependents.\n   * @private\n   */\n  forEachModel(iterator, options) {\n    const models = {};\n    const sorter = new Toposort();\n    let sorted;\n    let dep;\n\n    options = _.defaults(options || {}, {\n      reverse: true\n    });\n\n    for (const model of this.models) {\n      let deps = [];\n      let tableName = model.getTableName();\n\n      if (_.isObject(tableName)) {\n        tableName = tableName.schema + '.' + tableName.tableName;\n      }\n\n      models[tableName] = model;\n\n      for (const attrName in model.rawAttributes) {\n        if (model.rawAttributes.hasOwnProperty(attrName)) {\n          const attribute = model.rawAttributes[attrName];\n\n          if (attribute.references) {\n            dep = attribute.references.model;\n\n            if (_.isObject(dep)) {\n              dep = dep.schema + '.' + dep.tableName;\n            }\n\n            deps.push(dep);\n          }\n        }\n      }\n\n      deps = deps.filter(dep => tableName !== dep);\n\n      sorter.add(tableName, deps);\n    }\n\n    sorted = sorter.sort();\n    if (options.reverse) {\n      sorted = sorted.reverse();\n    }\n    for (const name of sorted) {\n      iterator(models[name], name);\n    }\n  }\n}\n\nmodule.exports = ModelManager;\nmodule.exports.ModelManager = ModelManager;\nmodule.exports.default = ModelManager;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/model-manager.js\n// module id = 73\n// module chunks = 0","module.exports = require(\"toposort-class\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"toposort-class\"\n// module id = 74\n// module chunks = 0","'use strict';\n\nconst Utils = require('./utils');\nconst _ = require('lodash');\nconst DataTypes = require('./data-types');\nconst SQLiteQueryInterface = require('./dialects/sqlite/query-interface');\nconst MSSSQLQueryInterface = require('./dialects/mssql/query-interface');\nconst MySQLQueryInterface = require('./dialects/mysql/query-interface');\nconst Transaction = require('./transaction');\nconst Promise = require('./promise');\nconst QueryTypes = require('./query-types');\n\n/**\n * The interface that Sequelize uses to talk to all databases\n * @class QueryInterface\n * @private\n */\nclass QueryInterface {\n  constructor(sequelize) {\n    this.sequelize = sequelize;\n    this.QueryGenerator = this.sequelize.dialect.QueryGenerator;\n  }\n\n  createSchema(schema, options) {\n    options = options || {};\n    const sql = this.QueryGenerator.createSchema(schema);\n    return this.sequelize.query(sql, options);\n  }\n\n  dropSchema(schema, options) {\n    options = options || {};\n    const sql = this.QueryGenerator.dropSchema(schema);\n    return this.sequelize.query(sql, options);\n  }\n\n  dropAllSchemas(options) {\n    options = options || {};\n\n    if (!this.QueryGenerator._dialect.supports.schemas) {\n      return this.sequelize.drop(options);\n    } else {\n      return this.showAllSchemas(options).map(schemaName => this.dropSchema(schemaName, options));\n    }\n  }\n\n  showAllSchemas(options) {\n\n    options = _.assign({}, options, {\n      raw: true,\n      type: this.sequelize.QueryTypes.SELECT\n    });\n\n    const showSchemasSql = this.QueryGenerator.showSchemasQuery();\n\n    return this.sequelize.query(showSchemasSql, options).then(schemaNames => Utils._.flatten(\n      Utils._.map(schemaNames, value => value.schema_name ? value.schema_name : value)\n    ));\n  }\n\n  databaseVersion(options) {\n    return this.sequelize.query(\n      this.QueryGenerator.versionQuery(),\n      _.assign({}, options, { type: QueryTypes.VERSION })\n    );\n  }\n\n  createTable(tableName, attributes, options, model) {\n    const keys = Object.keys(attributes);\n    const keyLen = keys.length;\n    let sql = '';\n    let i = 0;\n\n    options = _.clone(options) || {};\n\n    attributes = Utils._.mapValues(attributes, attribute => {\n      if (!Utils._.isPlainObject(attribute)) {\n        attribute = { type: attribute, allowNull: true };\n      }\n\n      attribute = this.sequelize.normalizeAttribute(attribute);\n\n      return attribute;\n    });\n\n    // Postgres requires a special SQL command for enums\n    if (this.sequelize.options.dialect === 'postgres') {\n      const promises = [];\n\n      for (i = 0; i < keyLen; i++) {\n        if (attributes[keys[i]].type instanceof DataTypes.ENUM) {\n          sql = this.QueryGenerator.pgListEnums(tableName, attributes[keys[i]].field || keys[i], options);\n          promises.push(this.sequelize.query(\n            sql,\n            _.assign({}, options, { plain: true, raw: true, type: QueryTypes.SELECT })\n          ));\n        }\n      }\n\n      return Promise.all(promises).then(results => {\n        const promises = [];\n        let enumIdx = 0;\n\n        for (i = 0; i < keyLen; i++) {\n          if (attributes[keys[i]].type instanceof DataTypes.ENUM) {\n            // If the enum type doesn't exist then create it\n            if (!results[enumIdx]) {\n              sql = this.QueryGenerator.pgEnum(tableName, attributes[keys[i]].field || keys[i], attributes[keys[i]], options);\n              promises.push(this.sequelize.query(\n                sql,\n                _.assign({}, options, { raw: true })\n              ));\n            } else if (!!results[enumIdx] && !!model) {\n              const enumVals = this.QueryGenerator.fromArray(results[enumIdx].enum_value);\n              const vals = model.rawAttributes[keys[i]].values;\n\n              vals.forEach((value, idx) => {\n                // reset out after/before options since it's for every enum value\n                const valueOptions = _.clone(options);\n                valueOptions.before = null;\n                valueOptions.after = null;\n\n                if (enumVals.indexOf(value) === -1) {\n                  if (vals[idx + 1]) {\n                    valueOptions.before = vals[idx + 1];\n                  }\n                  else if (vals[idx - 1]) {\n                    valueOptions.after = vals[idx - 1];\n                  }\n                  valueOptions.supportsSearchPath = false;\n                  promises.push(this.sequelize.query(this.QueryGenerator.pgEnumAdd(tableName, keys[i], value, valueOptions), valueOptions));\n                }\n              });\n              enumIdx++;\n            }\n          }\n        }\n\n        if (!tableName.schema &&\n          (options.schema || !!model && model._schema)) {\n          tableName = this.QueryGenerator.addSchema({\n            tableName,\n            _schema: !!model && model._schema || options.schema\n          });\n        }\n\n        attributes = this.QueryGenerator.attributesToSQL(attributes, {\n          context: 'createTable'\n        });\n        sql = this.QueryGenerator.createTableQuery(tableName, attributes, options);\n\n        return Promise.all(promises).then(() => {\n          return this.sequelize.query(sql, options);\n        });\n      });\n    } else {\n      if (!tableName.schema &&\n        (options.schema || !!model && model._schema)) {\n        tableName = this.QueryGenerator.addSchema({\n          tableName,\n          _schema: !!model && model._schema || options.schema\n        });\n      }\n\n      attributes = this.QueryGenerator.attributesToSQL(attributes, {\n        context: 'createTable'\n      });\n      sql = this.QueryGenerator.createTableQuery(tableName, attributes, options);\n\n      return this.sequelize.query(sql, options);\n    }\n  }\n\n  dropTable(tableName, options) {\n    // if we're forcing we should be cascading unless explicitly stated otherwise\n    options = _.clone(options) || {};\n    options.cascade = options.cascade || options.force || false;\n\n    let sql = this.QueryGenerator.dropTableQuery(tableName, options);\n\n    return this.sequelize.query(sql, options).then(() => {\n      const promises = [];\n\n      // Since postgres has a special case for enums, we should drop the related\n      // enum type within the table and attribute\n      if (this.sequelize.options.dialect === 'postgres') {\n        const instanceTable = this.sequelize.modelManager.getModel(tableName, { attribute: 'tableName' });\n\n        if (instanceTable) {\n          const getTableName = (!options || !options.schema || options.schema === 'public' ? '' : options.schema + '_') + tableName;\n\n          const keys = Object.keys(instanceTable.rawAttributes);\n          const keyLen = keys.length;\n\n          for (let i = 0; i < keyLen; i++) {\n            if (instanceTable.rawAttributes[keys[i]].type instanceof DataTypes.ENUM) {\n              sql = this.QueryGenerator.pgEnumDrop(getTableName, keys[i]);\n              options.supportsSearchPath = false;\n              promises.push(this.sequelize.query(sql, _.assign({}, options, { raw: true })));\n            }\n          }\n        }\n      }\n\n      return Promise.all(promises).get(0);\n    });\n  }\n\n  dropAllTables(options) {\n\n    options = options || {};\n    const skip = options.skip || [];\n\n    const dropAllTables = tableNames => Promise.each(tableNames, tableName => {\n      // if tableName is not in the Array of tables names then dont drop it\n      if (skip.indexOf(tableName.tableName || tableName) === -1) {\n        return this.dropTable(tableName, _.assign({}, options, { cascade: true }) );\n      }\n    });\n\n    return this.showAllTables(options).then(tableNames => {\n      if (this.sequelize.options.dialect === 'sqlite') {\n        return this.sequelize.query('PRAGMA foreign_keys;', options).then(result => {\n          const foreignKeysAreEnabled = result.foreign_keys === 1;\n\n          if (foreignKeysAreEnabled) {\n            return this.sequelize.query('PRAGMA foreign_keys = OFF', options)\n              .then(() => dropAllTables(tableNames))\n              .then(() => this.sequelize.query('PRAGMA foreign_keys = ON', options));\n          } else {\n            return dropAllTables(tableNames);\n          }\n        });\n      } else {\n        return this.getForeignKeysForTables(tableNames, options).then(foreignKeys => {\n          const promises = [];\n\n          tableNames.forEach(tableName => {\n            let normalizedTableName = tableName;\n            if (Utils._.isObject(tableName)) {\n              normalizedTableName = tableName.schema + '.' + tableName.tableName;\n            }\n\n            foreignKeys[normalizedTableName].forEach(foreignKey => {\n              const sql = this.QueryGenerator.dropForeignKeyQuery(tableName, foreignKey);\n              promises.push(this.sequelize.query(sql, options));\n            });\n          });\n\n          return Promise.all(promises).then(() => dropAllTables(tableNames));\n        });\n      }\n    });\n  }\n\n  dropAllEnums(options) {\n    if (this.sequelize.getDialect() !== 'postgres') {\n      return Promise.resolve();\n    }\n\n    options = options || {};\n\n    return this.pgListEnums(null, options).map(result => this.sequelize.query(\n      this.QueryGenerator.pgEnumDrop(null, null, this.QueryGenerator.pgEscapeAndQuote(result.enum_name)),\n      _.assign({}, options, { raw: true })\n    ));\n  }\n\n  pgListEnums(tableName, options) {\n    options = options || {};\n    const sql = this.QueryGenerator.pgListEnums(tableName);\n    return this.sequelize.query(sql, _.assign({}, options, { plain: false, raw: true, type: QueryTypes.SELECT }));\n  }\n\n  renameTable(before, after, options) {\n    options = options || {};\n    const sql = this.QueryGenerator.renameTableQuery(before, after);\n    return this.sequelize.query(sql, options);\n  }\n\n  showAllTables(options) {\n    options = _.assign({}, options, {\n      raw: true,\n      type: QueryTypes.SHOWTABLES\n    });\n\n    const showTablesSql = this.QueryGenerator.showTablesQuery();\n    return this.sequelize.query(showTablesSql, options).then(tableNames => Utils._.flatten(tableNames));\n  }\n\n  describeTable(tableName, options) {\n    let schema = null;\n    let schemaDelimiter = null;\n\n    if (typeof options === 'string') {\n      schema = options;\n    } else if (typeof options === 'object' && options !== null) {\n      schema = options.schema || null;\n      schemaDelimiter = options.schemaDelimiter || null;\n    }\n\n    if (typeof tableName === 'object' && tableName !== null) {\n      schema = tableName.schema;\n      tableName = tableName.tableName;\n    }\n\n    const sql = this.QueryGenerator.describeTableQuery(tableName, schema, schemaDelimiter);\n\n    return this.sequelize.query(\n      sql,\n      _.assign({}, options, { type: QueryTypes.DESCRIBE })\n    ).then(data => {\n      // If no data is returned from the query, then the table name may be wrong.\n      // Query generators that use information_schema for retrieving table info will just return an empty result set,\n      // it will not throw an error like built-ins do (e.g. DESCRIBE on MySql).\n      if (Utils._.isEmpty(data)) {\n        return Promise.reject('No description found for \"' + tableName + '\" table. Check the table name and schema; remember, they _are_ case sensitive.');\n      } else {\n        return Promise.resolve(data);\n      }\n    });\n  }\n\n  addColumn(table, key, attribute, options) {\n    if (!table || !key || !attribute) {\n      throw new Error('addColumn takes atleast 3 arguments (table, attribute name, attribute definition)');\n    }\n\n    options = options || {};\n    attribute = this.sequelize.normalizeAttribute(attribute);\n    return this.sequelize.query(this.QueryGenerator.addColumnQuery(table, key, attribute), options);\n  }\n\n  removeColumn(tableName, attributeName, options) {\n    options = options || {};\n    switch (this.sequelize.options.dialect) {\n      case 'sqlite':\n        // sqlite needs some special treatment as it cannot drop a column\n        return SQLiteQueryInterface.removeColumn.call(this, tableName, attributeName, options);\n      case 'mssql':\n        // mssql needs special treatment as it cannot drop a column with a default or foreign key constraint\n        return MSSSQLQueryInterface.removeColumn.call(this, tableName, attributeName, options);\n      case 'mysql':\n        // mysql needs special treatment as it cannot drop a column with a foreign key constraint\n        return MySQLQueryInterface.removeColumn.call(this, tableName, attributeName, options);\n      default:\n        return this.sequelize.query(this.QueryGenerator.removeColumnQuery(tableName, attributeName), options);\n    }\n  }\n\n  changeColumn(tableName, attributeName, dataTypeOrOptions, options) {\n    const attributes = {};\n    options = options || {};\n\n    if (Utils._.values(DataTypes).indexOf(dataTypeOrOptions) > -1) {\n      attributes[attributeName] = { type: dataTypeOrOptions, allowNull: true };\n    } else {\n      attributes[attributeName] = dataTypeOrOptions;\n    }\n\n    attributes[attributeName].type = this.sequelize.normalizeDataType(attributes[attributeName].type);\n\n    if (this.sequelize.options.dialect === 'sqlite') {\n      // sqlite needs some special treatment as it cannot change a column\n      return SQLiteQueryInterface.changeColumn.call(this, tableName, attributes, options);\n    } else {\n      const query = this.QueryGenerator.attributesToSQL(attributes);\n      const sql = this.QueryGenerator.changeColumnQuery(tableName, query);\n\n      return this.sequelize.query(sql, options);\n    }\n  }\n\n  renameColumn(tableName, attrNameBefore, attrNameAfter, options) {\n    options = options || {};\n    return this.describeTable(tableName, options).then(data => {\n      if (!data[attrNameBefore]) {\n        throw new Error('Table ' + tableName + ' doesn\\'t have the column ' + attrNameBefore);\n      }\n\n      data = data[attrNameBefore] || {};\n\n      const _options = {};\n\n      _options[attrNameAfter] = {\n        attribute: attrNameAfter,\n        type: data.type,\n        allowNull: data.allowNull,\n        defaultValue: data.defaultValue\n      };\n\n      // fix: a not-null column cannot have null as default value\n      if (data.defaultValue === null && !data.allowNull) {\n        delete _options[attrNameAfter].defaultValue;\n      }\n\n      if (this.sequelize.options.dialect === 'sqlite') {\n        // sqlite needs some special treatment as it cannot rename a column\n        return SQLiteQueryInterface.renameColumn.call(this, tableName, attrNameBefore, attrNameAfter, options);\n      } else {\n        const sql = this.QueryGenerator.renameColumnQuery(\n          tableName,\n          attrNameBefore,\n          this.QueryGenerator.attributesToSQL(_options)\n        );\n        return this.sequelize.query(sql, options);\n      }\n    });\n  }\n\n  addIndex(tableName, attributes, options, rawTablename) {\n    // Support for passing tableName, attributes, options or tableName, options (with a fields param which is the attributes)\n    if (!Array.isArray(attributes)) {\n      rawTablename = options;\n      options = attributes;\n      attributes = options.fields;\n    }\n    // testhint argsConform.end\n\n    if (!rawTablename) {\n      // Map for backwards compat\n      rawTablename = tableName;\n    }\n\n    options = Utils.cloneDeep(options);\n    options.fields = attributes;\n    const sql = this.QueryGenerator.addIndexQuery(tableName, options, rawTablename);\n    return this.sequelize.query(sql, _.assign({}, options, { supportsSearchPath: false }));\n  }\n\n  showIndex(tableName, options) {\n    const sql = this.QueryGenerator.showIndexesQuery(tableName, options);\n    return this.sequelize.query(sql, _.assign({}, options, { type: QueryTypes.SHOWINDEXES }));\n  }\n\n  nameIndexes(indexes, rawTablename) {\n    return this.QueryGenerator.nameIndexes(indexes, rawTablename);\n  }\n\n  getForeignKeysForTables(tableNames, options) {\n    options = options || {};\n\n    if (tableNames.length === 0) {\n      return Promise.resolve({});\n    }\n\n    return Promise.map(tableNames, tableName =>\n      this.sequelize.query(this.QueryGenerator.getForeignKeysQuery(tableName, this.sequelize.config.database), options).get(0)\n    ).then(results => {\n      const result = {};\n\n      tableNames.forEach((tableName, i) => {\n        if (Utils._.isObject(tableName)) {\n          tableName = tableName.schema + '.' + tableName.tableName;\n        }\n\n        result[tableName] = Utils._.compact(results[i]).map(r => r.constraint_name);\n      });\n\n      return result;\n    });\n  }\n\n  removeIndex(tableName, indexNameOrAttributes, options) {\n    options = options || {};\n    const sql = this.QueryGenerator.removeIndexQuery(tableName, indexNameOrAttributes);\n    return this.sequelize.query(sql, options);\n  }\n\n  addConstraint(tableName, attributes, options, rawTablename) {\n    if (!Array.isArray(attributes)) {\n      rawTablename = options;\n      options = attributes;\n      attributes = options.fields;\n    }\n\n    if (!options.type) {\n      throw new Error('Constraint type must be specified through options.type');\n    }\n\n    if (!rawTablename) {\n      // Map for backwards compat\n      rawTablename = tableName;\n    }\n\n    options = Utils.cloneDeep(options);\n    options.fields = attributes;\n\n    if (this.sequelize.dialect.name === 'sqlite') {\n      return SQLiteQueryInterface.addConstraint.call(this, tableName, options, rawTablename);\n    } else {\n      const sql = this.QueryGenerator.addConstraintQuery(tableName, options, rawTablename);\n      return this.sequelize.query(sql, options);\n    }\n  }\n\n  showConstraint(tableName, options) {\n    const sql = this.QueryGenerator.showConstraintsQuery(tableName, options);\n    return this.sequelize.query(sql, Object.assign({}, options, { type: QueryTypes.SHOWCONSTRAINTS }));\n  }\n\n  removeConstraint(tableName, constraintName, options) {\n    options = options || {};\n\n    switch (this.sequelize.options.dialect) {\n      case 'mysql':\n        //Mysql does not support DROP CONSTRAINT. Instead DROP PRIMARY, FOREIGN KEY, INDEX should be used\n        return MySQLQueryInterface.removeConstraint.call(this, tableName, constraintName, options);\n      case 'sqlite':\n        return SQLiteQueryInterface.removeConstraint.call(this, tableName, constraintName, options);\n      default:\n        const sql = this.QueryGenerator.removeConstraintQuery(tableName, constraintName);\n        return this.sequelize.query(sql, options);\n    }\n  }\n\n  insert(instance, tableName, values, options) {\n    options = Utils.cloneDeep(options);\n    options.hasTrigger = instance && instance.constructor.options.hasTrigger;\n    const sql = this.QueryGenerator.insertQuery(tableName, values, instance && instance.constructor.rawAttributes, options);\n\n    options.type = QueryTypes.INSERT;\n    options.instance = instance;\n\n    return this.sequelize.query(sql, options).then(results => {\n      if (instance) results[0].isNewRecord = false;\n      return results;\n    });\n  }\n\n  upsert(tableName, valuesByField, updateValues, where, model, options) {\n    const wheres = [];\n    const attributes = Object.keys(valuesByField);\n    let indexes = [];\n    let indexFields;\n\n    options = _.clone(options);\n\n    if (!Utils._.isEmpty(where)) {\n      wheres.push(where);\n    }\n\n    // Lets combine uniquekeys and indexes into one\n    indexes = Utils._.map(model.options.uniqueKeys, value => {\n      return value.fields;\n    });\n\n    Utils._.each(model.options.indexes, value => {\n      if (value.unique) {\n        // fields in the index may both the strings or objects with an attribute property - lets sanitize that\n        indexFields = Utils._.map(value.fields, field => {\n          if (Utils._.isPlainObject(field)) {\n            return field.attribute;\n          }\n          return field;\n        });\n        indexes.push(indexFields);\n      }\n    });\n\n    for (const index of indexes) {\n      if (Utils._.intersection(attributes, index).length === index.length) {\n        where = {};\n        for (const field of index) {\n          where[field] = valuesByField[field];\n        }\n        wheres.push(where);\n      }\n    }\n\n    where = { $or: wheres };\n\n    options.type = QueryTypes.UPSERT;\n    options.raw = true;\n\n    const sql = this.QueryGenerator.upsertQuery(tableName, valuesByField, updateValues, where, model, options);\n    return this.sequelize.query(sql, options).then(rowCount => {\n      if (rowCount === undefined) {\n        return rowCount;\n      }\n\n      // MySQL returns 1 for inserted, 2 for updated http://dev.mysql.com/doc/refman/5.0/en/insert-on-duplicate.html. Postgres has been modded to do the same\n\n      return rowCount === 1;\n    });\n  }\n\n  bulkInsert(tableName, records, options, attributes) {\n    options = _.clone(options) || {};\n    options.type = QueryTypes.INSERT;\n    const sql = this.QueryGenerator.bulkInsertQuery(tableName, records, options, attributes);\n    return this.sequelize.query(sql, options).then(results => results[0]);\n  }\n\n  update(instance, tableName, values, identifier, options) {\n    options = _.clone(options || {});\n    options.hasTrigger = !!(instance && instance._modelOptions && instance._modelOptions.hasTrigger);\n\n    const sql = this.QueryGenerator.updateQuery(tableName, values, identifier, options, instance.constructor.rawAttributes);\n\n    options.type = QueryTypes.UPDATE;\n\n    options.instance = instance;\n    return this.sequelize.query(sql, options);\n  }\n\n  bulkUpdate(tableName, values, identifier, options, attributes) {\n    options = Utils.cloneDeep(options);\n    if (typeof identifier === 'object') identifier = Utils.cloneDeep(identifier);\n\n    const sql = this.QueryGenerator.updateQuery(tableName, values, identifier, options, attributes);\n    const table = Utils._.isObject(tableName) ? tableName : { tableName };\n    const model = Utils._.find(this.sequelize.modelManager.models, { tableName: table.tableName });\n\n    options.model = model;\n    return this.sequelize.query(sql, options);\n  }\n\n  delete(instance, tableName, identifier, options) {\n    const cascades = [];\n    const sql = this.QueryGenerator.deleteQuery(tableName, identifier, null, instance.constructor);\n\n    options = _.clone(options) || {};\n\n    // Check for a restrict field\n    if (!!instance.constructor && !!instance.constructor.associations) {\n      const keys = Object.keys(instance.constructor.associations);\n      const length = keys.length;\n      let association;\n\n      for (let i = 0; i < length; i++) {\n        association = instance.constructor.associations[keys[i]];\n        if (association.options && association.options.onDelete &&\n          association.options.onDelete.toLowerCase() === 'cascade' &&\n          association.options.useHooks === true) {\n          cascades.push(association.accessors.get);\n        }\n      }\n    }\n\n    return Promise.each(cascades, cascade => {\n      return instance[cascade](options).then(instances => {\n        // Check for hasOne relationship with non-existing associate (\"has zero\")\n        if (!instances) {\n          return Promise.resolve();\n        }\n\n        if (!Array.isArray(instances)) instances = [instances];\n\n        return Promise.each(instances, instance => instance.destroy(options));\n      });\n    }).then(() => {\n      options.instance = instance;\n      return this.sequelize.query(sql, options);\n    });\n  }\n\n  bulkDelete(tableName, identifier, options, model) {\n    options = Utils.cloneDeep(options);\n    options = _.defaults(options, {limit: null});\n    if (typeof identifier === 'object') identifier = Utils.cloneDeep(identifier);\n\n    const sql = this.QueryGenerator.deleteQuery(tableName, identifier, options, model);\n    return this.sequelize.query(sql, options);\n  }\n\n  select(model, tableName, options) {\n    options = Utils.cloneDeep(options);\n    options.type = QueryTypes.SELECT;\n    options.model = model;\n\n    return this.sequelize.query(\n      this.QueryGenerator.selectQuery(tableName, options, model),\n      options\n    );\n  }\n\n  increment(model, tableName, values, identifier, options) {\n    options = Utils.cloneDeep(options);\n\n    const sql = this.QueryGenerator.arithmeticQuery('+', tableName, values, identifier, options, options.attributes);\n\n    options.type = QueryTypes.UPDATE;\n    options.model = model;\n\n    return this.sequelize.query(sql, options);\n  }\n\n  decrement(model, tableName, values, identifier, options) {\n    options = Utils.cloneDeep(options);\n\n    const sql = this.QueryGenerator.arithmeticQuery('-', tableName, values, identifier, options, options.attributes);\n\n    options.type = QueryTypes.UPDATE;\n    options.model = model;\n\n    return this.sequelize.query(sql, options);\n  }\n\n  rawSelect(tableName, options, attributeSelector, Model) {\n    if (options.schema) {\n      tableName = this.QueryGenerator.addSchema({\n        tableName,\n        _schema: options.schema\n      });\n    }\n\n    options = Utils.cloneDeep(options);\n    options = _.defaults(options, {\n      raw: true,\n      plain: true,\n      type: QueryTypes.SELECT\n    });\n\n    const sql = this.QueryGenerator.selectQuery(tableName, options, Model);\n\n    if (attributeSelector === undefined) {\n      throw new Error('Please pass an attribute selector!');\n    }\n\n    return this.sequelize.query(sql, options).then(data => {\n      if (!options.plain) {\n        return data;\n      }\n\n      let result = data ? data[attributeSelector] : null;\n\n      if (options && options.dataType) {\n        const dataType = options.dataType;\n\n        if (dataType instanceof DataTypes.DECIMAL || dataType instanceof DataTypes.FLOAT) {\n          result = parseFloat(result);\n        } else if (dataType instanceof DataTypes.INTEGER || dataType instanceof DataTypes.BIGINT) {\n          result = parseInt(result, 10);\n        } else if (dataType instanceof DataTypes.DATE) {\n          if (!Utils._.isNull(result) && !Utils._.isDate(result)) {\n            result = new Date(result);\n          }\n        } else if (dataType instanceof DataTypes.STRING) {\n          // Nothing to do, result is already a string.\n        }\n      }\n\n      return result;\n    });\n  }\n\n  createTrigger(tableName, triggerName, timingType, fireOnArray, functionName, functionParams, optionsArray, options) {\n    const sql = this.QueryGenerator.createTrigger(tableName, triggerName, timingType, fireOnArray, functionName, functionParams, optionsArray);\n    options = options || {};\n    if (sql) {\n      return this.sequelize.query(sql, options);\n    } else {\n      return Promise.resolve();\n    }\n  }\n\n  dropTrigger(tableName, triggerName, options) {\n    const sql = this.QueryGenerator.dropTrigger(tableName, triggerName);\n    options = options || {};\n\n    if (sql) {\n      return this.sequelize.query(sql, options);\n    } else {\n      return Promise.resolve();\n    }\n  }\n\n  renameTrigger(tableName, oldTriggerName, newTriggerName, options) {\n    const sql = this.QueryGenerator.renameTrigger(tableName, oldTriggerName, newTriggerName);\n    options = options || {};\n\n    if (sql) {\n      return this.sequelize.query(sql, options);\n    } else {\n      return Promise.resolve();\n    }\n  }\n\n  createFunction(functionName, params, returnType, language, body, options) {\n    const sql = this.QueryGenerator.createFunction(functionName, params, returnType, language, body, options);\n    options = options || {};\n\n    if (sql) {\n      return this.sequelize.query(sql, options);\n    } else {\n      return Promise.resolve();\n    }\n  }\n\n  dropFunction(functionName, params, options) {\n    const sql = this.QueryGenerator.dropFunction(functionName, params);\n    options = options || {};\n\n    if (sql) {\n      return this.sequelize.query(sql, options);\n    } else {\n      return Promise.resolve();\n    }\n  }\n\n  renameFunction(oldFunctionName, params, newFunctionName, options) {\n    const sql = this.QueryGenerator.renameFunction(oldFunctionName, params, newFunctionName);\n    options = options || {};\n\n    if (sql) {\n      return this.sequelize.query(sql, options);\n    } else {\n      return Promise.resolve();\n    }\n  }\n\n  // Helper methods useful for querying\n\n  /**\n   * Escape an identifier (e.g. a table or attribute name). If force is true,\n   * the identifier will be quoted even if the `quoteIdentifiers` option is\n   * false.\n   * @private\n   */\n  quoteIdentifier(identifier, force) {\n    return this.QueryGenerator.quoteIdentifier(identifier, force);\n  }\n\n  quoteTable(identifier) {\n    return this.QueryGenerator.quoteTable(identifier);\n  }\n\n  /**\n   * Split an identifier into .-separated tokens and quote each part.\n   * If force is true, the identifier will be quoted even if the\n   * `quoteIdentifiers` option is false.\n   * @private\n   */\n  quoteIdentifiers(identifiers, force) {\n    return this.QueryGenerator.quoteIdentifiers(identifiers, force);\n  }\n\n  /**\n   * Escape a value (e.g. a string, number or date)\n   * @private\n   */\n  escape(value) {\n    return this.QueryGenerator.escape(value);\n  }\n\n  setAutocommit(transaction, value, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error('Unable to set autocommit for a transaction without transaction object!');\n    }\n    if (transaction.parent) {\n      // Not possible to set a separate isolation level for savepoints\n      return Promise.resolve();\n    }\n\n    options = _.assign({}, options, {\n      transaction: transaction.parent || transaction\n    });\n\n    const sql = this.QueryGenerator.setAutocommitQuery(value, {\n      parent: transaction.parent\n    });\n\n    if (!sql) return Promise.resolve();\n\n    return this.sequelize.query(sql, options);\n  }\n\n  setIsolationLevel(transaction, value, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error('Unable to set isolation level for a transaction without transaction object!');\n    }\n\n    if (transaction.parent || !value) {\n      // Not possible to set a separate isolation level for savepoints\n      return Promise.resolve();\n    }\n\n    options = _.assign({}, options, {\n      transaction: transaction.parent || transaction\n    });\n\n    const sql = this.QueryGenerator.setIsolationLevelQuery(value, {\n      parent: transaction.parent\n    });\n\n    if (!sql) return Promise.resolve();\n\n    return this.sequelize.query(sql, options);\n  }\n\n  startTransaction(transaction, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error('Unable to start a transaction without transaction object!');\n    }\n\n    options = _.assign({}, options, {\n      transaction: transaction.parent || transaction\n    });\n    options.transaction.name = transaction.parent ? transaction.name : undefined;\n    const sql = this.QueryGenerator.startTransactionQuery(transaction);\n\n    return this.sequelize.query(sql, options);\n  }\n\n  deferConstraints(transaction, options) {\n    options = _.assign({}, options, {\n      transaction: transaction.parent || transaction\n    });\n\n    const sql = this.QueryGenerator.deferConstraintsQuery(options);\n\n    if (sql) {\n      return this.sequelize.query(sql, options);\n    }\n\n    return Promise.resolve();\n  }\n\n  commitTransaction(transaction, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error('Unable to commit a transaction without transaction object!');\n    }\n    if (transaction.parent) {\n      // Savepoints cannot be committed\n      return Promise.resolve();\n    }\n\n    options = _.assign({}, options, {\n      transaction: transaction.parent || transaction,\n      supportsSearchPath: false\n    });\n\n    const sql = this.QueryGenerator.commitTransactionQuery(transaction);\n    const promise = this.sequelize.query(sql, options);\n\n    transaction.finished = 'commit';\n\n    return promise;\n  }\n\n  rollbackTransaction(transaction, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error('Unable to rollback a transaction without transaction object!');\n    }\n\n    options = _.assign({}, options, {\n      transaction: transaction.parent || transaction,\n      supportsSearchPath: false\n    });\n    options.transaction.name = transaction.parent ? transaction.name : undefined;\n    const sql = this.QueryGenerator.rollbackTransactionQuery(transaction);\n    const promise = this.sequelize.query(sql, options);\n\n    transaction.finished = 'rollback';\n\n    return promise;\n  }\n}\n\nmodule.exports = QueryInterface;\nmodule.exports.QueryInterface = QueryInterface;\nmodule.exports.default = QueryInterface;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/query-interface.js\n// module id = 75\n// module chunks = 0","'use strict';\n\nconst Utils = require('../../utils');\nconst Promise = require('../../promise');\nconst UnknownConstraintError = require('../../errors').UnknownConstraintError;\n\n/**\n Returns an object that treats SQLite's inabilities to do certain queries.\n\n @class QueryInterface\n @static\n @private\n */\n\n/**\n  A wrapper that fixes SQLite's inability to remove columns from existing tables.\n  It will create a backup of the table, drop the table afterwards and create a\n  new table with the same name but without the obsolete column.\n\n  @method removeColumn\n  @for    QueryInterface\n\n  @param  {String} tableName     The name of the table.\n  @param  {String} attributeName The name of the attribute that we want to remove.\n  @param  {Object} options\n  @param  {Boolean|Function} [options.logging] A function that logs the sql queries, or false for explicitly not logging these queries\n\n  @since 1.6.0\n  @private\n */\nfunction removeColumn(tableName, attributeName, options) {\n  options = options || {};\n\n  return this.describeTable(tableName, options).then(fields => {\n    delete fields[attributeName];\n\n    const sql = this.QueryGenerator.removeColumnQuery(tableName, fields);\n    const subQueries = sql.split(';').filter(q => q !== '');\n\n    return Promise.each(subQueries, subQuery => this.sequelize.query(subQuery + ';', Utils._.assign({raw: true}, options)));\n  });\n}\nexports.removeColumn = removeColumn;\n\n/**\n  A wrapper that fixes SQLite's inability to change columns from existing tables.\n  It will create a backup of the table, drop the table afterwards and create a\n  new table with the same name but with a modified version of the respective column.\n\n  @method changeColumn\n  @for    QueryInterface\n\n  @param  {String} tableName The name of the table.\n  @param  {Object} attributes An object with the attribute's name as key and it's options as value object.\n  @param  {Object} options\n  @param  {Boolean|Function} [options.logging] A function that logs the sql queries, or false for explicitly not logging these queries\n\n  @since 1.6.0\n  @private\n */\nfunction changeColumn(tableName, attributes, options) {\n  const attributeName = Object.keys(attributes)[0];\n  options = options || {};\n\n  return this.describeTable(tableName, options).then(fields => {\n    fields[attributeName] = attributes[attributeName];\n\n    const sql = this.QueryGenerator.removeColumnQuery(tableName, fields);\n    const subQueries = sql.split(';').filter(q => q !== '');\n\n    return Promise.each(subQueries, subQuery => this.sequelize.query(subQuery + ';', Utils._.assign({raw: true}, options)));\n  });\n}\nexports.changeColumn = changeColumn;\n\n/**\n  A wrapper that fixes SQLite's inability to rename columns from existing tables.\n  It will create a backup of the table, drop the table afterwards and create a\n  new table with the same name but with a renamed version of the respective column.\n\n  @method renameColumn\n  @for    QueryInterface\n\n  @param  {String} tableName The name of the table.\n  @param  {String} attrNameBefore The name of the attribute before it was renamed.\n  @param  {String} attrNameAfter The name of the attribute after it was renamed.\n  @param  {Object} options\n  @param  {Boolean|Function} [options.logging] A function that logs the sql queries, or false for explicitly not logging these queries\n\n  @since 1.6.0\n  @private\n */\nfunction renameColumn(tableName, attrNameBefore, attrNameAfter, options) {\n  options = options || {};\n\n  return this.describeTable(tableName, options).then(fields => {\n    fields[attrNameAfter] = Utils._.clone(fields[attrNameBefore]);\n    delete fields[attrNameBefore];\n\n    const sql = this.QueryGenerator.renameColumnQuery(tableName, attrNameBefore, attrNameAfter, fields);\n    const subQueries = sql.split(';').filter(q => q !== '');\n\n    return Promise.each(subQueries, subQuery => this.sequelize.query(subQuery + ';', Utils._.assign({raw: true}, options)));\n  });\n}\nexports.renameColumn = renameColumn;\n\nfunction removeConstraint(tableName, constraintName, options) {\n  let createTableSql;\n\n  return this.showConstraint(tableName, constraintName)\n    .then(constraints => {\n      const constraint = constraints[0];\n\n      if (constraint) {\n        createTableSql = constraint.sql;\n        constraint.constraintName = this.QueryGenerator.quoteIdentifier(constraint.constraintName);\n        let constraintSnippet = `, CONSTRAINT ${constraint.constraintName} ${constraint.constraintType} ${constraint.constraintCondition}`;\n\n        if (constraint.constraintType === 'FOREIGN KEY') {\n          const referenceTableName = this.QueryGenerator.quoteTable(constraint.referenceTableName);\n          constraint.referenceTableKeys = constraint.referenceTableKeys.map(columnName => this.QueryGenerator.quoteIdentifier(columnName));\n          const referenceTableKeys = constraint.referenceTableKeys.join(', ');\n          constraintSnippet += ` REFERENCES ${referenceTableName} (${referenceTableKeys})`;\n          constraintSnippet += ` ON UPDATE ${constraint.updateAction}`;\n          constraintSnippet += ` ON DELETE ${constraint.deleteAction}`;\n        }\n\n        createTableSql = createTableSql.replace(constraintSnippet, '');\n        createTableSql += ';';\n\n        return this.describeTable(tableName, options);\n      } else {\n        throw new UnknownConstraintError(`Constraint ${constraintName} on table ${tableName} does not exist`);\n      }\n    })\n    .then(fields => {\n      const sql = this.QueryGenerator._alterConstraintQuery(tableName, fields, createTableSql);\n      const subQueries = sql.split(';').filter(q => q !== '');\n\n      return Promise.each(subQueries, subQuery => this.sequelize.query(subQuery + ';', Utils._.assign({raw: true}, options)));\n    });\n}\nexports.removeConstraint = removeConstraint;\n\nfunction addConstraint(tableName, options) {\n  const constraintSnippet = this.QueryGenerator.getConstraintSnippet(tableName, options);\n  const describeCreateTableSql = this.QueryGenerator.describeCreateTableQuery(tableName);\n  let createTableSql;\n\n  return this.sequelize.query(describeCreateTableSql, options)\n    .then(constraints => {\n      const sql = constraints[0].sql;\n      const index = sql.length - 1;\n      //Replace ending ')' with constraint snippet - Simulates String.replaceAt\n      //http://stackoverflow.com/questions/1431094\n      createTableSql = sql.substr(0, index) +  `, ${constraintSnippet})` + sql.substr(index + 1) + ';';\n\n      return this.describeTable(tableName, options);\n    })\n    .then(fields => {\n      const sql = this.QueryGenerator._alterConstraintQuery(tableName, fields, createTableSql);\n      const subQueries = sql.split(';').filter(q => q !== '');\n\n      return Promise.each(subQueries, subQuery => this.sequelize.query(subQuery + ';', Utils._.assign({raw: true}, options)));\n    });\n}\nexports.addConstraint = addConstraint;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/dialects/sqlite/query-interface.js\n// module id = 76\n// module chunks = 0","'use strict';\n\n/**\n Returns an object that treats MSSQL's inabilities to do certain queries.\n\n @class QueryInterface\n @static\n @private\n */\n\n/**\n  A wrapper that fixes MSSQL's inability to cleanly remove columns from existing tables if they have a default constraint.\n\n  @method removeColumn\n  @for    QueryInterface\n\n  @param  {String} tableName     The name of the table.\n  @param  {String} attributeName The name of the attribute that we want to remove.\n  @param  {Object} options\n  @param  {Boolean|Function} [options.logging] A function that logs the sql queries, or false for explicitly not logging these queries\n @private\n */\nconst removeColumn = function(tableName, attributeName, options) {\n  options = Object.assign({ raw: true }, options || {});\n\n  const findConstraintSql = this.QueryGenerator.getDefaultConstraintQuery(tableName, attributeName);\n  return this.sequelize.query(findConstraintSql, options)\n    .spread(results => {\n      if (!results.length) {\n        // No default constraint found -- we can cleanly remove the column\n        return;\n      }\n      const dropConstraintSql = this.QueryGenerator.dropConstraintQuery(tableName, results[0].name);\n      return this.sequelize.query(dropConstraintSql, options);\n    })\n    .then(() => {\n      const findForeignKeySql = this.QueryGenerator.getForeignKeyQuery(tableName, attributeName);\n      return this.sequelize.query(findForeignKeySql, options);\n    })\n    .spread(results => {\n      if (!results.length) {\n        // No foreign key constraints found, so we can remove the column\n        return;\n      }\n      const dropForeignKeySql = this.QueryGenerator.dropForeignKeyQuery(tableName, results[0].constraint_name);\n      return this.sequelize.query(dropForeignKeySql, options);\n    })\n    .then(() => {\n      //Check if the current column is a primaryKey\n      const primaryKeyConstraintSql = this.QueryGenerator.getPrimaryKeyConstraintQuery(tableName, attributeName);\n      return this.sequelize.query(primaryKeyConstraintSql, options);\n    })\n    .spread(result => {\n      if (!result.length) {\n        return;\n      }\n      const dropConstraintSql = this.QueryGenerator.dropConstraintQuery(tableName, result[0].constraintName);\n      return this.sequelize.query(dropConstraintSql, options);\n    })\n    .then(() => {\n      const removeSql = this.QueryGenerator.removeColumnQuery(tableName, attributeName);\n      return this.sequelize.query(removeSql, options);\n    });\n};\n\nmodule.exports = {\n  removeColumn\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/dialects/mssql/query-interface.js\n// module id = 77\n// module chunks = 0","'use strict';\n\n/**\n Returns an object that treats MySQL's inabilities to do certain queries.\n\n @class QueryInterface\n @static\n @private\n */\n\nconst _ = require('lodash');\nconst UnknownConstraintError = require('../../errors').UnknownConstraintError;\n\n/**\n  A wrapper that fixes MySQL's inability to cleanly remove columns from existing tables if they have a foreign key constraint.\n\n  @method removeColumn\n  @for    QueryInterface\n\n  @param  {String} tableName     The name of the table.\n  @param  {String} columnName    The name of the attribute that we want to remove.\n  @param  {Object} options\n @private\n */\nfunction removeColumn(tableName, columnName, options) {\n  options = options || {};\n\n  return this.sequelize.query(\n    this.QueryGenerator.getForeignKeyQuery(tableName, columnName),\n    _.assign({ raw: true }, options)\n  )\n    .spread(results => {\n      //Exclude primary key constraint\n      if (!results.length || results[0].constraint_name === 'PRIMARY') {\n        // No foreign key constraints found, so we can remove the column\n        return;\n      }\n      return this.sequelize.query(\n        this.QueryGenerator.dropForeignKeyQuery(tableName, results[0].constraint_name),\n        _.assign({ raw: true }, options)\n      );\n    })\n    .then(() => this.sequelize.query(\n      this.QueryGenerator.removeColumnQuery(tableName, columnName),\n      _.assign({ raw: true }, options)\n    ));\n}\n\n\nfunction removeConstraint(tableName, constraintName, options) {\n  const sql = this.QueryGenerator.showConstraintsQuery(tableName, constraintName);\n\n  return this.sequelize.query(sql, Object.assign({}, options, { type: this.sequelize.QueryTypes.SHOWCONSTRAINTS }))\n    .then(constraints => {\n      const constraint = constraints[0];\n      let query;\n      if (constraint && constraint.constraintType) {\n        if (constraint.constraintType === 'FOREIGN KEY') {\n          query = this.QueryGenerator.dropForeignKeyQuery(tableName, constraintName);\n        } else {\n          query = this.QueryGenerator.removeIndexQuery(constraint.tableName, constraint.constraintName);\n        }\n      } else {\n        throw new UnknownConstraintError(`Constraint ${constraintName} on table ${tableName} does not exist`);\n      }\n\n      return this.sequelize.query(query, options);\n    });\n}\n\nexports.removeConstraint = removeConstraint;\nexports.removeColumn = removeColumn;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/dialects/mysql/query-interface.js\n// module id = 78\n// module chunks = 0","'use strict';\n\nconst Association = require('./base');\nAssociation.BelongsTo = require('./belongs-to');\nAssociation.HasOne = require('./has-one');\nAssociation.HasMany = require('./has-many');\nAssociation.BelongsToMany = require('./belongs-to-many');\n\nmodule.exports = Association;\nmodule.exports.default = Association;\nmodule.exports.Association = Association;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/associations/index.js\n// module id = 79\n// module chunks = 0","'use strict';\n\nconst _ = require('lodash');\nconst AbstractDialect = require('../abstract');\nconst ConnectionManager = require('./connection-manager');\nconst Query = require('./query');\nconst QueryGenerator = require('./query-generator');\nconst DataTypes = require('../../data-types').mssql;\n\nclass MssqlDialect extends AbstractDialect {\n  constructor(sequelize) {\n    super();\n    this.sequelize = sequelize;\n    this.connectionManager = new ConnectionManager(this, sequelize);\n    this.QueryGenerator = _.extend({}, QueryGenerator, {\n      options: sequelize.options,\n      _dialect: this,\n      sequelize\n    });\n  }\n}\n\nMssqlDialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {\n  'DEFAULT': true,\n  'DEFAULT VALUES': true,\n  'LIMIT ON UPDATE': true,\n  'ORDER NULLS': false,\n  lock: false,\n  transactions: true,\n  migrations: false,\n  upserts: true,\n  returnValues: {\n    output: true\n  },\n  schemas: true,\n  autoIncrement: {\n    identityInsert: true,\n    defaultValue: false,\n    update: false\n  },\n  constraints: {\n    restrict: false,\n    default: true\n  },\n  index: {\n    collate: false,\n    length: false,\n    parser: false,\n    type: true,\n    using: false,\n    where: true\n  },\n  NUMERIC: true,\n  tmpTableTrigger: true\n});\n\nConnectionManager.prototype.defaultVersion = '12.0.2000'; // SQL Server 2014 Express\nMssqlDialect.prototype.Query = Query;\nMssqlDialect.prototype.name = 'mssql';\nMssqlDialect.prototype.TICK_CHAR = '\"';\nMssqlDialect.prototype.TICK_CHAR_LEFT = '[';\nMssqlDialect.prototype.TICK_CHAR_RIGHT = ']';\nMssqlDialect.prototype.DataTypes = DataTypes;\n\nmodule.exports = MssqlDialect;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/dialects/mssql/index.js\n// module id = 80\n// module chunks = 0","'use strict';\n\nconst AbstractConnectionManager = require('../abstract/connection-manager');\nconst ResourceLock = require('./resource-lock');\nconst Promise = require('../../promise');\nconst Utils = require('../../utils');\nconst debug = Utils.getLogger().debugContext('connection:mssql');\nconst debugTedious = Utils.getLogger().debugContext('connection:mssql:tedious');\nconst sequelizeErrors = require('../../errors');\nconst parserStore = require('../parserStore')('mssql');\nconst _ = require('lodash');\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    super(dialect, sequelize);\n\n    this.sequelize = sequelize;\n    this.sequelize.config.port = this.sequelize.config.port || 1433;\n    try {\n      if (sequelize.config.dialectModulePath) {\n        this.lib = require(sequelize.config.dialectModulePath);\n      } else {\n        this.lib = require('tedious');\n      }\n    } catch (err) {\n      if (err.code === 'MODULE_NOT_FOUND') {\n        throw new Error('Please install tedious package manually');\n      }\n      throw err;\n    }\n  }\n\n  // Expose this as a method so that the parsing may be updated when the user has added additional, custom types\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  connect(config) {\n    return new Promise((resolve, reject) => {\n      const connectionConfig = {\n        userName: config.username,\n        password: config.password,\n        server: config.host,\n        options: {\n          port: config.port,\n          database: config.database\n        }\n      };\n\n      if (config.dialectOptions) {\n        // only set port if no instance name was provided\n        if (config.dialectOptions.instanceName) {\n          delete connectionConfig.options.port;\n        }\n\n        // The 'tedious' driver needs domain property to be in the main Connection config object\n        if (config.dialectOptions.domain) {\n          connectionConfig.domain = config.dialectOptions.domain;\n        }\n\n        for (const key of Object.keys(config.dialectOptions)) {\n          connectionConfig.options[key] = config.dialectOptions[key];\n        }\n      }\n\n      const connection = new this.lib.Connection(connectionConfig);\n      const connectionLock = new ResourceLock(connection);\n      connection.lib = this.lib;\n\n      connection.on('connect', err => {\n        if (!err) {\n          debug('connection acquired');\n          resolve(connectionLock);\n          return;\n        }\n\n        if (!err.code) {\n          reject(new sequelizeErrors.ConnectionError(err));\n          return;\n        }\n\n        switch (err.code) {\n          case 'ESOCKET':\n            if (_.includes(err.message, 'connect EHOSTUNREACH')) {\n              reject(new sequelizeErrors.HostNotReachableError(err));\n            } else if (_.includes(err.message, 'connect ENETUNREACH')) {\n              reject(new sequelizeErrors.HostNotReachableError(err));\n            } else if (_.includes(err.message, 'connect EADDRNOTAVAIL')) {\n              reject(new sequelizeErrors.HostNotReachableError(err));\n            } else if (_.includes(err.message, 'getaddrinfo ENOTFOUND')) {\n              reject(new sequelizeErrors.HostNotFoundError(err));\n            } else if (_.includes(err.message, 'connect ECONNREFUSED')) {\n              reject(new sequelizeErrors.ConnectionRefusedError(err));\n            } else {\n              reject(new sequelizeErrors.ConnectionError(err));\n            }\n            break;\n          case 'ER_ACCESS_DENIED_ERROR':\n          case 'ELOGIN':\n            reject(new sequelizeErrors.AccessDeniedError(err));\n            break;\n          case 'EINVAL':\n            reject(new sequelizeErrors.InvalidConnectionError(err));\n            break;\n          default:\n            reject(new sequelizeErrors.ConnectionError(err));\n            break;\n        }\n      });\n      \n      if (config.dialectOptions && config.dialectOptions.debug) {\n        connection.on('debug', debugTedious);        \n      }\n\n      if (config.pool.handleDisconnects) {\n        connection.on('error', err => {\n          switch (err.code) {\n            case 'ESOCKET':\n            case 'ECONNRESET':\n              this.pool.destroy(connectionLock);\n          }\n        });\n      }\n\n    });\n  }\n\n  disconnect(connectionLock) {\n    const connection = connectionLock.unwrap();\n\n    // Dont disconnect a connection that is already disconnected\n    if (connection.closed) {\n      return Promise.resolve();\n    }\n\n    return new Promise(resolve => {\n      connection.on('end', resolve);\n      connection.close();\n      debug('connection closed');\n    });\n  }\n\n  validate(connectionLock) {\n    const connection = connectionLock.unwrap();\n    return connection && connection.loggedIn;\n  }\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/dialects/mssql/connection-manager.js\n// module id = 81\n// module chunks = 0","module.exports = require(\"generic-pool\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"generic-pool\"\n// module id = 82\n// module chunks = 0","module.exports = require(\"timers\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"timers\"\n// module id = 83\n// module chunks = 0","'use strict';\n\nconst Promise = require('../../promise');\n\nfunction ResourceLock(resource) {\n  this.resource = resource;\n  this.previous = Promise.resolve(resource);\n}\n\nResourceLock.prototype.unwrap = function() {\n  return this.resource;\n};\n\nResourceLock.prototype.lock = function() {\n  const lock = this.previous;\n  let resolve;\n\n  this.previous = new Promise(r => {\n    resolve = r;\n  });\n\n  return lock.disposer(resolve);\n};\n\nmodule.exports = ResourceLock;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/dialects/mssql/resource-lock.js\n// module id = 84\n// module chunks = 0","function webpackEmptyContext(req) {\n\tthrow new Error(\"Cannot find module '\" + req + \"'.\");\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 85;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/dialects/mssql\n// module id = 85\n// module chunks = 0","'use strict';\n\nconst Utils = require('../../utils');\nconst debug = Utils.getLogger().debugContext('sql:mssql');\nconst Promise = require('../../promise');\nconst AbstractQuery = require('../abstract/query');\nconst sequelizeErrors = require('../../errors.js');\nconst parserStore = require('../parserStore')('mssql');\nconst _ = require('lodash');\nconst TYPES = require('tedious').TYPES;\n\nclass Query extends AbstractQuery {\n  constructor(connection, sequelize, options) {\n    super();\n    this.connection = connection;\n    this.instance = options.instance;\n    this.model = options.model;\n    this.sequelize = sequelize;\n    this.options = Utils._.extend({\n      logging: console.log,\n      plain: false,\n      raw: false\n    }, options || {});\n\n    this.checkLoggingOption();\n  }\n\n  getInsertIdField() {\n    return 'id';\n  }\n\n  getSQLTypeFromJsType(value) {\n    const paramType = {type: TYPES.VarChar, typeOptions: {} };\n    paramType.type = TYPES.NVarChar;\n    if (typeof value === 'number') {\n      if (Number.isInteger(value)) {\n        paramType.type = TYPES.Int;\n      } else {\n        paramType.type = TYPES.Numeric;\n        //Default to a reasonable numeric precision/scale pending more sophisticated logic\n        paramType.typeOptions = {precision: 30, scale: 15};\n      }\n    }\n    return paramType;\n  }\n\n  _run(connection, sql, parameters) {\n    this.sql = sql;\n\n    //do we need benchmark for this query execution\n    const benchmark = this.sequelize.options.benchmark || this.options.benchmark;\n    let queryBegin;\n    if (benchmark) {\n      queryBegin = Date.now();\n    } else {\n      this.sequelize.log('Executing (' + (this.connection.uuid || 'default') + '): ' + this.sql, this.options);\n    }\n\n    debug(`executing(${this.connection.uuid || 'default'}) : ${this.sql}`);\n\n    return new Promise((resolve, reject) => {\n      // TRANSACTION SUPPORT\n      if (_.startsWith(this.sql, 'BEGIN TRANSACTION')) {\n        connection.beginTransaction(err => {\n          if (err) {\n            reject(this.formatError(err));\n          } else {\n            resolve(this.formatResults());\n          }\n        }, this.options.transaction.name, Utils.mapIsolationLevelStringToTedious(this.options.isolationLevel, connection.lib));\n      } else if (_.startsWith(this.sql, 'COMMIT TRANSACTION')) {\n        connection.commitTransaction(err => {\n          if (err) {\n            reject(this.formatError(err));\n          } else {\n            resolve(this.formatResults());\n          }\n        });\n      } else if (_.startsWith(this.sql, 'ROLLBACK TRANSACTION')) {\n        connection.rollbackTransaction(err => {\n          if (err) {\n            reject(this.formatError(err));\n          } else {\n            resolve(this.formatResults());\n          }\n        }, this.options.transaction.name);\n      } else if (_.startsWith(this.sql, 'SAVE TRANSACTION')) {\n        connection.saveTransaction(err => {\n          if (err) {\n            reject(this.formatError(err));\n          } else {\n            resolve(this.formatResults());\n          }\n        }, this.options.transaction.name);\n      } else {\n        const results = [];\n        const request = new connection.lib.Request(this.sql, (err, rowCount) => {\n\n          debug(`executed(${this.connection.uuid || 'default'}) : ${this.sql}`);\n\n          if (benchmark) {\n            this.sequelize.log('Executed (' + (this.connection.uuid || 'default') + '): ' + this.sql, Date.now() - queryBegin, this.options);\n          }\n\n          if (err) {\n            err.sql = sql;\n            reject(this.formatError(err));\n          } else {\n            resolve(this.formatResults(results, rowCount));\n          }\n        });\n\n        if (parameters) {\n          _.forOwn(parameters, (value, key) => {\n            const paramType = this.getSQLTypeFromJsType(value);\n            request.addParameter(key, paramType.type, value, paramType.typeOptions);\n          });\n        }\n\n        request.on('row', columns => {\n          const row = {};\n          for (const column of columns) {\n            const typeid = column.metadata.type.id;\n            const parse = parserStore.get(typeid);\n            let value = column.value;\n\n            if (value !== null & !!parse) {\n              value = parse(value);\n            }\n            row[column.metadata.colName] = value;\n          }\n\n          results.push(row);\n        });\n\n        connection.execSql(request);\n      }\n    });\n  }\n\n  run(sql, parameters) {\n    return Promise.using(this.connection.lock(), connection => this._run(connection, sql, parameters));\n  }\n\n  static formatBindParameters(sql, values, dialect) {\n    const bindParam = {};\n    let i = 0;\n    const seen = {};\n    const replacementFunc = (match, key, values) => {\n      if (seen[key] !== undefined) {\n        return seen[key];\n      }\n      if (values[key] !== undefined) {\n        i = i + 1;\n        bindParam[key] = values[key];\n        seen[key] = '$' + i;\n        return '@' + key;\n      }\n      return undefined;\n    };\n    sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];\n\n    return [sql, bindParam];\n  }\n\n  /**\n   * High level function that handles the results of a query execution.\n   *\n   *\n   * Example:\n   *  query.formatResults([\n   *    {\n   *      id: 1,              // this is from the main table\n   *      attr2: 'snafu',     // this is from the main table\n   *      Tasks.id: 1,        // this is from the associated table\n   *      Tasks.title: 'task' // this is from the associated table\n   *    }\n   *  ])\n   *\n   * @param {Array} data - The result of the query execution.\n   * @private\n   */\n  formatResults(data, rowCount) {\n    let result = this.instance;\n    if (this.isInsertQuery(data)) {\n      this.handleInsertQuery(data);\n\n      if (!this.instance) {\n        if (this.options.plain) {\n          // NOTE: super contrived. This just passes the newly added query-interface\n          //       test returning only the PK. There isn't a way in MSSQL to identify\n          //       that a given return value is the PK, and we have no schema information\n          //       because there was no calling Model.\n          const record = data[0];\n          result = record[Object.keys(record)[0]];\n        } else {\n          result = data;\n        }\n      }\n    }\n\n    if (this.isShowTablesQuery()) {\n      result = this.handleShowTablesQuery(data);\n    } else if (this.isDescribeQuery()) {\n      result = {};\n      for (const _result of data) {\n        if (_result.Default) {\n          _result.Default = _result.Default.replace(\"('\", '').replace(\"')\", '').replace(/'/g, '');\n        }\n\n        result[_result.Name] = {\n          type: _result.Type.toUpperCase(),\n          allowNull: _result.IsNull === 'YES' ? true : false,\n          defaultValue: _result.Default,\n          primaryKey: _result.Constraint === 'PRIMARY KEY'\n        };\n      }\n    } else if (this.isShowIndexesQuery()) {\n      result = this.handleShowIndexesQuery(data);\n    } else if (this.isSelectQuery()) {\n      result = this.handleSelectQuery(data);\n    } else if (this.isUpsertQuery()) {\n      //Use the same return value as that of MySQL & Postgres\n      if (data[0].$action === 'INSERT') {\n        result = 1;\n      } else {\n        result = 2;\n      }\n    } else if (this.isCallQuery()) {\n      result = data[0];\n    } else if (this.isBulkUpdateQuery()) {\n      result = data.length;\n    } else if (this.isBulkDeleteQuery()) {\n      result = data[0] && data[0].AFFECTEDROWS;\n    } else if (this.isVersionQuery()) {\n      result = data[0].version;\n    } else if (this.isForeignKeysQuery()) {\n      result = data;\n    } else if (this.isInsertQuery() || this.isUpdateQuery()) {\n      result = [result, rowCount];\n    } else if (this.isShowConstraintsQuery()) {\n      result = this.handleShowConstraintsQuery(data);\n    } else if (this.isRawQuery()) {\n      // MSSQL returns row data and metadata (affected rows etc) in a single object - let's standarize it, sorta\n      result = [data, data];\n    }\n\n    return result;\n  }\n\n  handleShowTablesQuery(results) {\n    return results.map(resultSet => {\n      return {\n        tableName: resultSet.TABLE_NAME,\n        schema: resultSet.TABLE_SCHEMA\n      };\n    });\n  }\n\n  handleShowConstraintsQuery(data) {\n    //Convert snake_case keys to camelCase as its generated by stored procedure\n    return data.slice(1).map(result => {\n      const constraint = {};\n      for (const key in result) {\n        constraint[_.camelCase(key)] = result[key];\n      }\n      return constraint;\n    });\n  }\n\n  formatError(err) {\n    let match;\n    match = err.message.match(/Violation of UNIQUE KEY constraint '((.|\\s)*)'. Cannot insert duplicate key in object '.*'.(:? The duplicate key value is \\((.*)\\).)?/);\n    match = match || err.message.match(/Cannot insert duplicate key row in object .* with unique index '(.*)'/);\n    if (match && match.length > 1) {\n      let fields = {};\n      const uniqueKey = this.model && this.model.uniqueKeys[match[1]];\n      let message = 'Validation error';\n\n      if (uniqueKey && !!uniqueKey.msg) {\n        message = uniqueKey.msg;\n      }\n      if (match[4]) {\n        const values = match[4].split(',').map(part => part.trim());\n        if (uniqueKey) {\n          fields = Utils._.zipObject(uniqueKey.fields, values);\n        } else {\n          fields[match[1]] = match[4];\n        }\n      }\n\n      const errors = [];\n      Utils._.forOwn(fields, (value, field) => {\n        errors.push(new sequelizeErrors.ValidationErrorItem(\n          this.getUniqueConstraintErrorMessage(field),\n          'unique violation', field, value\n        ));\n      });\n\n      return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields });\n    }\n\n    match = err.message.match(/Failed on step '(.*)'.Could not create constraint. See previous errors./) ||\n      err.message.match(/The DELETE statement conflicted with the REFERENCE constraint \"(.*)\". The conflict occurred in database \"(.*)\", table \"(.*)\", column '(.*)'./) ||\n      err.message.match(/The INSERT statement conflicted with the FOREIGN KEY constraint \"(.*)\". The conflict occurred in database \"(.*)\", table \"(.*)\", column '(.*)'./) ||\n      err.message.match(/The MERGE statement conflicted with the FOREIGN KEY constraint \"(.*)\". The conflict occurred in database \"(.*)\", table \"(.*)\", column '(.*)'./) ||\n      err.message.match(/The UPDATE statement conflicted with the FOREIGN KEY constraint \"(.*)\". The conflict occurred in database \"(.*)\", table \"(.*)\", column '(.*)'./);\n    if (match && match.length > 0) {\n      return new sequelizeErrors.ForeignKeyConstraintError({\n        fields: null,\n        index: match[1],\n        parent: err\n      });\n    }\n\n    match = err.message.match(/Could not drop constraint. See previous errors./);\n\n    if (match && match.length > 0) {\n      return new sequelizeErrors.UnknownConstraintError(match[1]);\n    }\n\n    return new sequelizeErrors.DatabaseError(err);\n  }\n\n  isShowOrDescribeQuery() {\n    let result = false;\n\n    result = result || this.sql.toLowerCase().indexOf(\"select c.column_name as 'name', c.data_type as 'type', c.is_nullable as 'isnull'\") === 0;\n    result = result || this.sql.toLowerCase().indexOf('select tablename = t.name, name = ind.name,') === 0;\n    result = result || this.sql.toLowerCase().indexOf('exec sys.sp_helpindex @objname') === 0;\n\n    return result;\n  }\n\n  isShowIndexesQuery() {\n    return this.sql.toLowerCase().indexOf('exec sys.sp_helpindex @objname') === 0;\n  }\n\n  handleShowIndexesQuery(data) {\n    // Group by index name, and collect all fields\n    data = _.reduce(data, (acc, item) => {\n      if (!(item.index_name in acc)) {\n        acc[item.index_name] = item;\n        item.fields = [];\n      }\n\n      Utils._.forEach(item.index_keys.split(','), column => {\n        let columnName = column.trim();\n        if (columnName.indexOf('(-)') !== -1) {\n          columnName = columnName.replace('(-)', '');\n        }\n\n        acc[item.index_name].fields.push({\n          attribute: columnName,\n          length: undefined,\n          order: column.indexOf('(-)') !== -1 ? 'DESC' : 'ASC',\n          collate: undefined\n        });\n      });\n      delete item.index_keys;\n      return acc;\n    }, {});\n\n    return Utils._.map(data, item => ({\n      primary: item.index_name.toLowerCase().indexOf('pk') === 0,\n      fields: item.fields,\n      name: item.index_name,\n      tableName: undefined,\n      unique: item.index_description.toLowerCase().indexOf('unique') !== -1,\n      type: undefined\n    }));\n  }\n\n  handleInsertQuery(results, metaData) {\n    if (this.instance) {\n      // add the inserted row id to the instance\n      const autoIncrementAttribute = this.model.autoIncrementAttribute;\n      let id = null;\n      let autoIncrementAttributeAlias = null;\n\n      if (this.model.rawAttributes.hasOwnProperty(autoIncrementAttribute) &&\n        this.model.rawAttributes[autoIncrementAttribute].field !== undefined)\n        autoIncrementAttributeAlias = this.model.rawAttributes[autoIncrementAttribute].field;\n\n      id = id || results && results[0][this.getInsertIdField()];\n      id = id || metaData && metaData[this.getInsertIdField()];\n      id = id || results && results[0][autoIncrementAttribute];\n      id = id || autoIncrementAttributeAlias && results && results[0][autoIncrementAttributeAlias];\n\n      this.instance[autoIncrementAttribute] = id;\n    }\n  }\n}\n\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports.default = Query;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/dialects/mssql/query.js\n// module id = 86\n// module chunks = 0","'use strict';\n\nconst Utils = require('../../utils'),\n  DataTypes = require('../../data-types'),\n  AbstractQueryGenerator = require('../abstract/query-generator'),\n  randomBytes = require('crypto').randomBytes,\n  semver = require('semver');\n\n/* istanbul ignore next */\nconst throwMethodUndefined = function(methodName) {\n  throw new Error('The method \"' + methodName + '\" is not defined! Please add it to your sql dialect.');\n};\n\nconst QueryGenerator = {\n  __proto__: AbstractQueryGenerator,\n  options: {},\n  dialect: 'mssql',\n\n  createSchema(schema) {\n    return [\n      'IF NOT EXISTS (SELECT schema_name',\n      'FROM information_schema.schemata',\n      'WHERE schema_name =', wrapSingleQuote(schema), ')',\n      'BEGIN',\n      \"EXEC sp_executesql N'CREATE SCHEMA\",\n      this.quoteIdentifier(schema),\n      \";'\",\n      'END;'\n    ].join(' ');\n  },\n\n  showSchemasQuery() {\n    return [\n      'SELECT \"name\" as \"schema_name\" FROM sys.schemas as s',\n      'WHERE \"s\".\"name\" NOT IN (',\n      \"'INFORMATION_SCHEMA', 'dbo', 'guest', 'sys', 'archive'\",\n      ')', 'AND', '\"s\".\"name\" NOT LIKE', \"'db_%'\"\n    ].join(' ');\n  },\n\n  versionQuery() {\n    // Uses string manipulation to convert the MS Maj.Min.Patch.Build to semver Maj.Min.Patch\n    return [\n      'DECLARE @ms_ver NVARCHAR(20);',\n      \"SET @ms_ver = REVERSE(CONVERT(NVARCHAR(20), SERVERPROPERTY('ProductVersion')));\",\n      \"SELECT REVERSE(SUBSTRING(@ms_ver, CHARINDEX('.', @ms_ver)+1, 20)) AS 'version'\"\n    ].join(' ');\n  },\n\n  createTableQuery(tableName, attributes, options) {\n    const query = \"IF OBJECT_ID('<%= table %>', 'U') IS NULL CREATE TABLE <%= table %> (<%= attributes %>)\",\n      primaryKeys = [],\n      foreignKeys = {},\n      attrStr = [],\n      self = this;\n\n    for (const attr in attributes) {\n      if (attributes.hasOwnProperty(attr)) {\n        const dataType = attributes[attr];\n        let match;\n\n        if (Utils._.includes(dataType, 'PRIMARY KEY')) {\n          primaryKeys.push(attr);\n\n          if (Utils._.includes(dataType, 'REFERENCES')) {\n            // MSSQL doesn't support inline REFERENCES declarations: move to the end\n            match = dataType.match(/^(.+) (REFERENCES.*)$/);\n            attrStr.push(this.quoteIdentifier(attr) + ' ' + match[1].replace(/PRIMARY KEY/, ''));\n            foreignKeys[attr] = match[2];\n          } else {\n            attrStr.push(this.quoteIdentifier(attr) + ' ' + dataType.replace(/PRIMARY KEY/, ''));\n          }\n        } else if (Utils._.includes(dataType, 'REFERENCES')) {\n          // MSSQL doesn't support inline REFERENCES declarations: move to the end\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(this.quoteIdentifier(attr) + ' ' + match[1]);\n          foreignKeys[attr] = match[2];\n        } else {\n          attrStr.push(this.quoteIdentifier(attr) + ' ' + dataType);\n        }\n      }\n    }\n\n    const values = {\n        table: this.quoteTable(tableName),\n        attributes: attrStr.join(', ')\n      },\n      pkString = primaryKeys.map(pk => { return this.quoteIdentifier(pk); }).join(', ');\n\n    if (options.uniqueKeys) {\n      Utils._.each(options.uniqueKeys, (columns, indexName) => {\n        if (!Utils._.isString(indexName)) {\n          indexName = 'uniq_' + tableName + '_' + columns.fields.join('_');\n        }\n        values.attributes += ', CONSTRAINT ' + self.quoteIdentifier(indexName) + ' UNIQUE (' + Utils._.map(columns.fields, self.quoteIdentifier).join(', ') + ')';\n      });\n    }\n\n    if (pkString.length > 0) {\n      values.attributes += ', PRIMARY KEY (' + pkString + ')';\n    }\n\n    for (const fkey in foreignKeys) {\n      if (foreignKeys.hasOwnProperty(fkey)) {\n        values.attributes += ', FOREIGN KEY (' + this.quoteIdentifier(fkey) + ') ' + foreignKeys[fkey];\n      }\n    }\n\n    return Utils._.template(query)(values).trim() + ';';\n  },\n\n  describeTableQuery(tableName, schema) {\n    let sql = [\n      'SELECT',\n      \"c.COLUMN_NAME AS 'Name',\",\n      \"c.DATA_TYPE AS 'Type',\",\n      \"c.CHARACTER_MAXIMUM_LENGTH AS 'Length',\",\n      \"c.IS_NULLABLE as 'IsNull',\",\n      \"COLUMN_DEFAULT AS 'Default',\",\n      \"pk.CONSTRAINT_TYPE AS 'Constraint'\",\n      'FROM',\n      'INFORMATION_SCHEMA.TABLES t',\n      'INNER JOIN',\n      'INFORMATION_SCHEMA.COLUMNS c ON t.TABLE_NAME = c.TABLE_NAME AND t.TABLE_SCHEMA = c.TABLE_SCHEMA',\n      'LEFT JOIN (SELECT tc.table_schema, tc.table_name, ',\n      'cu.column_name, tc.constraint_type ',\n      'FROM information_schema.TABLE_CONSTRAINTS tc ',\n      'JOIN information_schema.KEY_COLUMN_USAGE  cu ',\n      'ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name ',\n      'and tc.constraint_name=cu.constraint_name ',\n      'and tc.constraint_type=\\'PRIMARY KEY\\') pk ',\n      'ON pk.table_schema=c.table_schema ',\n      'AND pk.table_name=c.table_name ',\n      'AND pk.column_name=c.column_name ',\n      'WHERE t.TABLE_NAME =', wrapSingleQuote(tableName)\n    ].join(' ');\n\n    if (schema) {\n      sql += 'AND t.TABLE_SCHEMA =' + wrapSingleQuote(schema);\n    }\n\n    return sql;\n  },\n\n  renameTableQuery(before, after) {\n    const query = 'EXEC sp_rename <%= before %>, <%= after %>;';\n    return Utils._.template(query)({\n      before: this.quoteTable(before),\n      after: this.quoteTable(after)\n    });\n  },\n\n  showTablesQuery() {\n    return 'SELECT TABLE_NAME, TABLE_SCHEMA FROM INFORMATION_SCHEMA.TABLES;';\n  },\n\n  dropTableQuery(tableName) {\n    const query = \"IF OBJECT_ID('<%= table %>', 'U') IS NOT NULL DROP TABLE <%= table %>\";\n    const values = {\n      table: this.quoteTable(tableName)\n    };\n\n    return Utils._.template(query)(values).trim() + ';';\n  },\n\n  addColumnQuery(table, key, dataType) {\n    // FIXME: attributeToSQL SHOULD be using attributes in addColumnQuery\n    //        but instead we need to pass the key along as the field here\n    dataType.field = key;\n\n    const query = 'ALTER TABLE <%= table %> ADD <%= attribute %>;',\n      attribute = Utils._.template('<%= key %> <%= definition %>')({\n        key: this.quoteIdentifier(key),\n        definition: this.attributeToSQL(dataType, {\n          context: 'addColumn'\n        })\n      });\n\n    return Utils._.template(query)({\n      table: this.quoteTable(table),\n      attribute\n    });\n  },\n\n  removeColumnQuery(tableName, attributeName) {\n    const query = 'ALTER TABLE <%= tableName %> DROP COLUMN <%= attributeName %>;';\n    return Utils._.template(query)({\n      tableName: this.quoteTable(tableName),\n      attributeName: this.quoteIdentifier(attributeName)\n    });\n  },\n\n  changeColumnQuery(tableName, attributes) {\n    const query = 'ALTER TABLE <%= tableName %> <%= query %>;';\n    const attrString = [],\n      constraintString = [];\n\n    for (const attributeName in attributes) {\n      const definition = attributes[attributeName];\n      if (definition.match(/REFERENCES/)) {\n        constraintString.push(Utils._.template('<%= fkName %> FOREIGN KEY (<%= attrName %>) <%= definition %>')({\n          fkName: this.quoteIdentifier(attributeName + '_foreign_idx'),\n          attrName: this.quoteIdentifier(attributeName),\n          definition: definition.replace(/.+?(?=REFERENCES)/, '')\n        }));\n      } else {\n        attrString.push(Utils._.template('<%= attrName %> <%= definition %>')({\n          attrName: this.quoteIdentifier(attributeName),\n          definition\n        }));\n      }\n    }\n\n    let finalQuery = '';\n    if (attrString.length) {\n      finalQuery += 'ALTER COLUMN ' + attrString.join(', ');\n      finalQuery += constraintString.length ? ' ' : '';\n    }\n    if (constraintString.length) {\n      finalQuery += 'ADD CONSTRAINT ' + constraintString.join(', ');\n    }\n\n    return Utils._.template(query)({\n      tableName: this.quoteTable(tableName),\n      query: finalQuery\n    });\n  },\n\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const query = \"EXEC sp_rename '<%= tableName %>.<%= before %>', '<%= after %>', 'COLUMN';\",\n      newName = Object.keys(attributes)[0];\n\n    return Utils._.template(query)({\n      tableName: this.quoteTable(tableName),\n      before: attrBefore,\n      after: newName\n    });\n  },\n\n  bulkInsertQuery(tableName, attrValueHashes, options, attributes) {\n    options = options || {};\n    attributes = attributes || {};\n    const query = 'INSERT INTO <%= table %> (<%= attributes %>)<%= output %> VALUES <%= tuples %>;',\n      emptyQuery = 'INSERT INTO <%= table %><%= output %> DEFAULT VALUES',\n      tuples = [],\n      allAttributes = [],\n      allQueries = [];\n\n    let needIdentityInsertWrapper = false,\n      outputFragment;\n\n    if (options.returning) {\n      outputFragment = ' OUTPUT INSERTED.*';\n    }\n\n    Utils._.forEach(attrValueHashes, attrValueHash => {\n      // special case for empty objects with primary keys\n      const fields = Object.keys(attrValueHash);\n      const firstAttr = attributes[fields[0]];\n      if (fields.length === 1 && firstAttr && firstAttr.autoIncrement && attrValueHash[fields[0]] === null) {\n        allQueries.push(emptyQuery);\n        return;\n      }\n\n      // normal case\n      Utils._.forOwn(attrValueHash, (value, key) => {\n        if (value !== null && attributes[key] && attributes[key].autoIncrement) {\n          needIdentityInsertWrapper = true;\n        }\n\n        if (allAttributes.indexOf(key) === -1) {\n          if (value === null && attributes[key].autoIncrement)\n            return;\n\n          allAttributes.push(key);\n        }\n      });\n    });\n\n    if (allAttributes.length > 0) {\n      Utils._.forEach(attrValueHashes, attrValueHash => {\n        tuples.push('(' +\n          allAttributes.map(key =>\n            this.escape(attrValueHash[key])).join(',') +\n        ')');\n      });\n\n      allQueries.push(query);\n    }\n    const commands = [];\n    let offset = 0;\n    const batch = Math.floor(250 / (allAttributes.length + 1)) + 1;\n    while (offset < Math.max(tuples.length, 1)) {\n      const replacements = {\n        table: this.quoteTable(tableName),\n        attributes: allAttributes.map(attr =>\n          this.quoteIdentifier(attr)).join(','),\n        tuples: tuples.slice(offset, Math.min(tuples.length, offset + batch)),\n        output: outputFragment\n      };\n\n      let generatedQuery = Utils._.template(allQueries.join(';'))(replacements);\n      if (needIdentityInsertWrapper) {\n        generatedQuery = [\n          'SET IDENTITY_INSERT', this.quoteTable(tableName), 'ON;',\n          generatedQuery,\n          'SET IDENTITY_INSERT', this.quoteTable(tableName), 'OFF;'\n        ].join(' ');\n      }\n      commands.push(generatedQuery);\n      offset += batch;\n    }\n    return commands.join(';');\n  },\n\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    let sql = super.updateQuery(tableName, attrValueHash, where, options, attributes);\n    if (options.limit) {\n      const updateArgs = `UPDATE TOP(${this.escape(options.limit)})`;\n      sql = sql.replace('UPDATE', updateArgs);\n    }\n    return sql;\n  },\n\n  upsertQuery(tableName, insertValues, updateValues, where, model) {\n    const targetTableAlias = this.quoteTable(`${tableName}_target`);\n    const sourceTableAlias = this.quoteTable(`${tableName}_source`);\n    const primaryKeysAttrs = [];\n    const identityAttrs = [];\n    const uniqueAttrs = [];\n    const tableNameQuoted = this.quoteTable(tableName);\n    let needIdentityInsertWrapper = false;\n\n\n    //Obtain primaryKeys, uniquekeys and identity attrs from rawAttributes as model is not passed\n    for (const key in model.rawAttributes) {\n      if (model.rawAttributes[key].primaryKey) {\n        primaryKeysAttrs.push(model.rawAttributes[key].field || key);\n      }\n      if (model.rawAttributes[key].unique) {\n        uniqueAttrs.push(model.rawAttributes[key].field || key);\n      }\n      if (model.rawAttributes[key].autoIncrement) {\n        identityAttrs.push(model.rawAttributes[key].field || key);\n      }\n    }\n\n    //Add unique indexes defined by indexes option to uniqueAttrs\n    for (const index of model.options.indexes) {\n      if (index.unique && index.fields) {\n        for (const field of index.fields) {\n          const fieldName = typeof field === 'string' ? field : field.name || field.attribute;\n          if (uniqueAttrs.indexOf(fieldName) === -1 && model.rawAttributes[fieldName]) {\n            uniqueAttrs.push(fieldName);\n          }\n        }\n      }\n    }\n\n    const updateKeys = Object.keys(updateValues);\n    const insertKeys = Object.keys(insertValues);\n    const insertKeysQuoted = insertKeys.map(key => this.quoteIdentifier(key)).join(', ');\n    const insertValuesEscaped = insertKeys.map(key => this.escape(insertValues[key])).join(', ');\n    const sourceTableQuery = `VALUES(${insertValuesEscaped})`; //Virtual Table\n    let joinCondition;\n\n    //IDENTITY_INSERT Condition\n    identityAttrs.forEach(key => {\n      if (updateValues[key] && updateValues[key] !== null) {\n        needIdentityInsertWrapper = true;\n        /*\n         * IDENTITY_INSERT Column Cannot be updated, only inserted\n         * http://stackoverflow.com/a/30176254/2254360\n         */\n      }\n    });\n\n    //Filter NULL Clauses\n    const clauses = where.$or.filter(clause => {\n      let valid = true;\n      /*\n       * Exclude NULL Composite PK/UK. Partial Composite clauses should also be excluded as it doesn't guarantee a single row\n       */\n      for (const key in clause) {\n        if (!clause[key]) {\n          valid = false;\n          break;\n        }\n      }\n      return valid;\n    });\n\n    /*\n     * Generate ON condition using PK(s).\n     * If not, generate using UK(s). Else throw error\n     */\n    const getJoinSnippet = array => {\n      return array.map(key => {\n        key = this.quoteIdentifier(key);\n        return `${targetTableAlias}.${key} = ${sourceTableAlias}.${key}`;\n      });\n    };\n\n    if (clauses.length === 0) {\n      throw new Error('Primary Key or Unique key should be passed to upsert query');\n    } else {\n      // Search for primary key attribute in clauses -- Model can have two separate unique keys\n      for (const key in clauses) {\n        const keys = Object.keys(clauses[key]);\n        if (primaryKeysAttrs.indexOf(keys[0]) !== -1) {\n          joinCondition = getJoinSnippet(primaryKeysAttrs).join(' AND ');\n          break;\n        }\n      }\n      if (!joinCondition) {\n        joinCondition = getJoinSnippet(uniqueAttrs).join(' AND ');\n      }\n    }\n\n    // Remove the IDENTITY_INSERT Column from update\n    const updateSnippet = updateKeys.filter(key => {\n      if (identityAttrs.indexOf(key) === -1) {\n        return true;\n      } else {\n        return false;\n      }\n    })\n      .map(key => {\n        const value = this.escape(updateValues[key]);\n        key = this.quoteIdentifier(key);\n        return `${targetTableAlias}.${key} = ${value}`;\n      }).join(', ');\n\n    const insertSnippet = `(${insertKeysQuoted}) VALUES(${insertValuesEscaped})`;\n    let query = `MERGE INTO ${tableNameQuoted} WITH(HOLDLOCK) AS ${targetTableAlias} USING (${sourceTableQuery}) AS ${sourceTableAlias}(${insertKeysQuoted}) ON ${joinCondition}`;\n    query += ` WHEN MATCHED THEN UPDATE SET ${updateSnippet} WHEN NOT MATCHED THEN INSERT ${insertSnippet} OUTPUT $action, INSERTED.*;`;\n    if (needIdentityInsertWrapper) {\n      query = `SET IDENTITY_INSERT ${tableNameQuoted} ON; ${query} SET IDENTITY_INSERT ${tableNameQuoted} OFF;`;\n    }\n    return query;\n  },\n\n  deleteQuery(tableName, where, options) {\n    options = options || {};\n\n    const table = this.quoteTable(tableName);\n    if (options.truncate === true) {\n      // Truncate does not allow LIMIT and WHERE\n      return 'TRUNCATE TABLE ' + table;\n    }\n\n    where = this.getWhereConditions(where);\n    let limit = '';\n    const query = 'DELETE<%= limit %> FROM <%= table %><%= where %>; ' +\n                'SELECT @@ROWCOUNT AS AFFECTEDROWS;';\n\n    if (Utils._.isUndefined(options.limit)) {\n      options.limit = 1;\n    }\n\n    if (options.limit) {\n      limit = ' TOP(' + this.escape(options.limit) + ')';\n    }\n\n    const replacements = {\n      limit,\n      table,\n      where\n    };\n\n    if (replacements.where) {\n      replacements.where = ' WHERE ' + replacements.where;\n    }\n\n    return Utils._.template(query)(replacements);\n  },\n\n  showIndexesQuery(tableName) {\n    const sql = \"EXEC sys.sp_helpindex @objname = N'<%= tableName %>';\";\n    return Utils._.template(sql)({\n      tableName: this.quoteTable(tableName)\n    });\n  },\n\n  showConstraintsQuery(tableName) {\n    return `EXEC sp_helpconstraint @objname = ${this.escape(this.quoteTable(tableName))};`;\n  },\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    const sql = 'DROP INDEX <%= indexName %> ON <%= tableName %>';\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(tableName + '_' + indexNameOrAttributes.join('_'));\n    }\n\n    const values = {\n      tableName: this.quoteIdentifiers(tableName),\n      indexName: this.quoteIdentifiers(indexName)\n    };\n\n    return Utils._.template(sql)(values);\n  },\n\n  attributeToSQL(attribute) {\n    if (!Utils._.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n\n    // handle self referential constraints\n    if (attribute.references) {\n\n      if (attribute.Model && attribute.Model.tableName === attribute.references.model) {\n        this.sequelize.log('MSSQL does not support self referencial constraints, '\n          + 'we will remove it but we recommend restructuring your query');\n        attribute.onDelete = '';\n        attribute.onUpdate = '';\n      }\n    }\n\n    let template;\n\n    if (attribute.type instanceof DataTypes.ENUM) {\n      if (attribute.type.values && !attribute.values) attribute.values = attribute.type.values;\n\n      // enums are a special case\n      template = attribute.type.toSql();\n      template += ' CHECK (' + this.quoteIdentifier(attribute.field) + ' IN(' + Utils._.map(attribute.values, value => {\n        return this.escape(value);\n      }).join(', ') + '))';\n      return template;\n    } else {\n      template = attribute.type.toString();\n    }\n\n    if (attribute.allowNull === false) {\n      template += ' NOT NULL';\n    } else if (!attribute.primaryKey && !Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ' NULL';\n    }\n\n    if (attribute.autoIncrement) {\n      template += ' IDENTITY(1,1)';\n    }\n\n    // Blobs/texts cannot have a defaultValue\n    if (attribute.type !== 'TEXT' && attribute.type._binary !== true &&\n        Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ' DEFAULT ' + this.escape(attribute.defaultValue);\n    }\n\n    if (attribute.unique === true) {\n      template += ' UNIQUE';\n    }\n\n    if (attribute.primaryKey) {\n      template += ' PRIMARY KEY';\n    }\n\n    if (attribute.references) {\n      template += ' REFERENCES ' + this.quoteTable(attribute.references.model);\n\n      if (attribute.references.key) {\n        template += ' (' + this.quoteIdentifier(attribute.references.key) + ')';\n      } else {\n        template += ' (' + this.quoteIdentifier('id') + ')';\n      }\n\n      if (attribute.onDelete) {\n        template += ' ON DELETE ' + attribute.onDelete.toUpperCase();\n      }\n\n      if (attribute.onUpdate) {\n        template += ' ON UPDATE ' + attribute.onUpdate.toUpperCase();\n      }\n    }\n\n    return template;\n  },\n\n  attributesToSQL(attributes, options) {\n    const result = {},\n      existingConstraints = [];\n    let key,\n      attribute;\n\n    for (key in attributes) {\n      attribute = attributes[key];\n\n      if (attribute.references) {\n\n        if (existingConstraints.indexOf(attribute.references.model.toString()) !== -1) {\n          // no cascading constraints to a table more than once\n          attribute.onDelete = '';\n          attribute.onUpdate = '';\n        } else {\n          existingConstraints.push(attribute.references.model.toString());\n\n          // NOTE: this really just disables cascading updates for all\n          //       definitions. Can be made more robust to support the\n          //       few cases where MSSQL actually supports them\n          attribute.onUpdate = '';\n        }\n\n      }\n\n      if (key && !attribute.field) attribute.field = key;\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n\n    return result;\n  },\n\n  createTrigger() {\n    throwMethodUndefined('createTrigger');\n  },\n\n  dropTrigger() {\n    throwMethodUndefined('dropTrigger');\n  },\n\n  renameTrigger() {\n    throwMethodUndefined('renameTrigger');\n  },\n\n  createFunction() {\n    throwMethodUndefined('createFunction');\n  },\n\n  dropFunction() {\n    throwMethodUndefined('dropFunction');\n  },\n\n  renameFunction() {\n    throwMethodUndefined('renameFunction');\n  },\n\n  quoteIdentifier(identifier) {\n    if (identifier === '*') return identifier;\n    return '[' + identifier.replace(/[\\[\\]']+/g, '') + ']';\n  },\n\n  getForeignKeysQuery(table) {\n    const tableName = table.tableName || table;\n    let sql = [\n      'SELECT',\n      'constraint_name = C.CONSTRAINT_NAME',\n      'FROM',\n      'INFORMATION_SCHEMA.TABLE_CONSTRAINTS C',\n      \"WHERE C.CONSTRAINT_TYPE = 'FOREIGN KEY'\",\n      'AND C.TABLE_NAME =', wrapSingleQuote(tableName)\n    ].join(' ');\n\n    if (table.schema) {\n      sql += ' AND C.TABLE_SCHEMA =' + wrapSingleQuote(table.schema);\n    }\n\n    return sql;\n  },\n\n  getForeignKeyQuery(table, attributeName) {\n    const tableName = table.tableName || table;\n    let sql = [\n      'SELECT',\n      'constraint_name = TC.CONSTRAINT_NAME',\n      'FROM',\n      'INFORMATION_SCHEMA.TABLE_CONSTRAINTS TC',\n      'JOIN INFORMATION_SCHEMA.CONSTRAINT_COLUMN_USAGE CCU',\n      'ON TC.CONSTRAINT_NAME = CCU.CONSTRAINT_NAME',\n      \"WHERE TC.CONSTRAINT_TYPE = 'FOREIGN KEY'\",\n      'AND TC.TABLE_NAME =', wrapSingleQuote(tableName),\n      'AND CCU.COLUMN_NAME =', wrapSingleQuote(attributeName)\n    ].join(' ');\n\n    if (table.schema) {\n      sql += ' AND TC.TABLE_SCHEMA =' + wrapSingleQuote(table.schema);\n    }\n\n    return sql;\n  },\n\n  getPrimaryKeyConstraintQuery(table, attributeName) {\n    const tableName = wrapSingleQuote(table.tableName || table);\n    return [\n      'SELECT K.TABLE_NAME AS tableName,',\n      'K.COLUMN_NAME AS columnName,',\n      'K.CONSTRAINT_NAME AS constraintName',\n      'FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS AS C',\n      'JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS K',\n      'ON C.TABLE_NAME = K.TABLE_NAME',\n      'AND C.CONSTRAINT_CATALOG = K.CONSTRAINT_CATALOG',\n      'AND C.CONSTRAINT_SCHEMA = K.CONSTRAINT_SCHEMA',\n      'AND C.CONSTRAINT_NAME = K.CONSTRAINT_NAME',\n      'WHERE C.CONSTRAINT_TYPE = \\'PRIMARY KEY\\'',\n      `AND K.COLUMN_NAME = ${wrapSingleQuote(attributeName)}`,\n      `AND K.TABLE_NAME = ${tableName};`\n    ].join(' ');\n  },\n\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return Utils._.template('ALTER TABLE <%= table %> DROP <%= key %>')({\n      table: this.quoteTable(tableName),\n      key: this.quoteIdentifier(foreignKey)\n    });\n  },\n\n  getDefaultConstraintQuery(tableName, attributeName) {\n    const sql = 'SELECT name FROM SYS.DEFAULT_CONSTRAINTS ' +\n      \"WHERE PARENT_OBJECT_ID = OBJECT_ID('<%= table %>', 'U') \" +\n      \"AND PARENT_COLUMN_ID = (SELECT column_id FROM sys.columns WHERE NAME = ('<%= column %>') \" +\n      \"AND object_id = OBJECT_ID('<%= table %>', 'U'));\";\n    return Utils._.template(sql)({\n      table: this.quoteTable(tableName),\n      column: attributeName\n    });\n  },\n\n  dropConstraintQuery(tableName, constraintName) {\n    const sql = 'ALTER TABLE <%= table %> DROP CONSTRAINT <%= constraint %>;';\n    return Utils._.template(sql)({\n      table: this.quoteTable(tableName),\n      constraint: this.quoteIdentifier(constraintName)\n    });\n  },\n\n  setAutocommitQuery() {\n    return '';\n  },\n\n  setIsolationLevelQuery() {\n\n  },\n\n  generateTransactionId() {\n    return randomBytes(10).toString('hex');\n  },\n\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return 'SAVE TRANSACTION ' + this.quoteIdentifier(transaction.name) + ';';\n    }\n\n    return 'BEGIN TRANSACTION;';\n  },\n\n  commitTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return;\n    }\n\n    return 'COMMIT TRANSACTION;';\n  },\n\n  rollbackTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return 'ROLLBACK TRANSACTION ' + this.quoteIdentifier(transaction.name) + ';';\n    }\n\n    return 'ROLLBACK TRANSACTION;';\n  },\n\n  selectFromTableFragment(options, model, attributes, tables, mainTableAs, where) {\n    let topFragment = '';\n    let mainFragment = 'SELECT ' + attributes.join(', ') + ' FROM ' + tables;\n\n    // Handle SQL Server 2008 with TOP instead of LIMIT\n    if (semver.valid(this.sequelize.options.databaseVersion) && semver.lt(this.sequelize.options.databaseVersion, '11.0.0')) {\n      if (options.limit) {\n        topFragment = 'TOP ' + options.limit + ' ';\n      }\n      if (options.offset) {\n        const offset = options.offset || 0,\n          isSubQuery = options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation;\n        let orders = { mainQueryOrder: [] };\n        if (options.order) {\n          orders = this.getQueryOrders(options, model, isSubQuery);\n        }\n\n        if (!orders.mainQueryOrder.length) {\n          orders.mainQueryOrder.push(this.quoteIdentifier(model.primaryKeyField));\n        }\n\n        const tmpTable = mainTableAs ? mainTableAs : 'OffsetTable';\n        const whereFragment = where ? ' WHERE ' + where : '';\n\n        /*\n         * For earlier versions of SQL server, we need to nest several queries\n         * in order to emulate the OFFSET behavior.\n         *\n         * 1. The outermost query selects all items from the inner query block.\n         *    This is due to a limitation in SQL server with the use of computed\n         *    columns (e.g. SELECT ROW_NUMBER()...AS x) in WHERE clauses.\n         * 2. The next query handles the LIMIT and OFFSET behavior by getting\n         *    the TOP N rows of the query where the row number is > OFFSET\n         * 3. The innermost query is the actual set we want information from\n         */\n        const fragment = 'SELECT TOP 100 PERCENT ' + attributes.join(', ') + ' FROM ' +\n                        '(SELECT ' + topFragment + '*' +\n                          ' FROM (SELECT ROW_NUMBER() OVER (ORDER BY ' + orders.mainQueryOrder.join(', ') + ') as row_num, * ' +\n                            ' FROM ' + tables + ' AS ' + tmpTable + whereFragment + ')' +\n                          ' AS ' + tmpTable + ' WHERE row_num > ' + offset + ')' +\n                        ' AS ' + tmpTable;\n        return fragment;\n      } else {\n        mainFragment = 'SELECT ' + topFragment + attributes.join(', ') + ' FROM ' + tables;\n      }\n    }\n\n    if (mainTableAs) {\n      mainFragment += ' AS ' + mainTableAs;\n    }\n\n    return mainFragment;\n  },\n\n  addLimitAndOffset(options, model) {\n    // Skip handling of limit and offset as postfixes for older SQL Server versions\n    if (semver.valid(this.sequelize.options.databaseVersion) && semver.lt(this.sequelize.options.databaseVersion, '11.0.0')) {\n      return '';\n    }\n\n    let fragment = '';\n    const offset = options.offset || 0,\n      isSubQuery = options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation;\n\n    let orders = {};\n    if (options.order) {\n      orders = this.getQueryOrders(options, model, isSubQuery);\n    }\n\n    if (options.limit || options.offset) {\n      if (!options.order || options.include && !orders.subQueryOrder.length) {\n        fragment += options.order && !isSubQuery ? ', ' : ' ORDER BY ';\n        fragment += this.quoteTable(options.tableAs || model.name) + '.' + this.quoteIdentifier(model.primaryKeyField);\n      }\n\n      if (options.offset || options.limit) {\n        fragment += ' OFFSET ' + this.escape(offset) + ' ROWS';\n      }\n\n      if (options.limit) {\n        fragment += ' FETCH NEXT ' + this.escape(options.limit) + ' ROWS ONLY';\n      }\n    }\n\n    return fragment;\n  },\n\n  booleanValue(value) {\n    return value ? 1 : 0;\n  }\n};\n\n// private methods\nfunction wrapSingleQuote(identifier) {\n  return Utils.addTicks(Utils.removeTicks(identifier, \"'\"), \"'\");\n}\n\nmodule.exports = QueryGenerator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/dialects/mssql/query-generator.js\n// module id = 87\n// module chunks = 0","module.exports = require(\"crypto\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"crypto\"\n// module id = 88\n// module chunks = 0","'use strict';\n\nconst _ = require('lodash');\nconst AbstractDialect = require('../abstract');\nconst ConnectionManager = require('./connection-manager');\nconst Query = require('./query');\nconst QueryGenerator = require('./query-generator');\nconst DataTypes = require('../../data-types').mysql;\n\nclass MysqlDialect extends AbstractDialect {\n  constructor(sequelize) {\n    super();\n    this.sequelize = sequelize;\n    this.connectionManager = new ConnectionManager(this, sequelize);\n    this.QueryGenerator = _.extend({}, QueryGenerator, {\n      options: sequelize.options,\n      _dialect: this,\n      sequelize\n    });\n  }\n}\n\nMysqlDialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {\n  'VALUES ()': true,\n  'LIMIT ON UPDATE': true,\n  'IGNORE': ' IGNORE',\n  lock: true,\n  forShare: 'LOCK IN SHARE MODE',\n  index: {\n    collate: false,\n    length: true,\n    parser: true,\n    type: true,\n    using: 1\n  },\n  constraints: {\n    dropConstraint: false,\n    check: false\n  },\n  ignoreDuplicates: ' IGNORE',\n  updateOnDuplicate: true,\n  indexViaAlter: true,\n  NUMERIC: true,\n  GEOMETRY: true,\n  REGEXP: true\n});\n\nConnectionManager.prototype.defaultVersion = '5.6.0';\nMysqlDialect.prototype.Query = Query;\nMysqlDialect.prototype.QueryGenerator = QueryGenerator;\nMysqlDialect.prototype.DataTypes = DataTypes;\nMysqlDialect.prototype.name = 'mysql';\nMysqlDialect.prototype.TICK_CHAR = '`';\nMysqlDialect.prototype.TICK_CHAR_LEFT = MysqlDialect.prototype.TICK_CHAR;\nMysqlDialect.prototype.TICK_CHAR_RIGHT = MysqlDialect.prototype.TICK_CHAR;\n\nmodule.exports = MysqlDialect;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/dialects/mysql/index.js\n// module id = 89\n// module chunks = 0","'use strict';\n\nconst AbstractConnectionManager = require('../abstract/connection-manager');\nconst SequelizeErrors = require('../../errors');\nconst Utils = require('../../utils');\nconst DataTypes = require('../../data-types').mysql;\nconst momentTz = require('moment-timezone');\nconst debug = Utils.getLogger().debugContext('connection:mysql');\nconst parserMap = new Map();\n\n/**\n * MySQL Connection Managger\n *\n * Get connections, validate and disconnect them.\n * AbstractConnectionManager pooling use it to handle MySQL specific connections\n * Use https://github.com/sidorares/node-mysql2 to connect with MySQL server\n *\n * @extends AbstractConnectionManager\n * @return Class<ConnectionManager>\n * @private\n */\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    super(dialect, sequelize);\n\n    this.sequelize = sequelize;\n    this.sequelize.config.port = this.sequelize.config.port || 3306;\n    try {\n      if (sequelize.config.dialectModulePath) {\n        this.lib = require(sequelize.config.dialectModulePath);\n      } else {\n        this.lib = require('mysql2');\n      }\n    } catch (err) {\n      if (err.code === 'MODULE_NOT_FOUND') {\n        throw new Error('Please install mysql2 package manually');\n      }\n      throw err;\n    }\n\n    this.refreshTypeParser(DataTypes);\n  }\n\n  // Update parsing when the user has added additional, custom types\n  _refreshTypeParser(dataType) {\n    for (const type of dataType.types.mysql) {\n      parserMap.set(type, dataType.parse);\n    }\n  }\n\n  _clearTypeParser() {\n    parserMap.clear();\n  }\n\n  static _typecast(field, next) {\n    if (parserMap.has(field.type)) {\n      return parserMap.get(field.type)(field, this.sequelize.options, next);\n    }\n    return next();\n  }\n\n  /**\n   * Connect with MySQL database based on config, Handle any errors in connection\n   * Set the pool handlers on connection.error\n   * Also set proper timezone once conection is connected\n   *\n   * @return Promise<Connection>\n   * @private\n   */\n  connect(config) {\n    const connectionConfig = {\n      host: config.host,\n      port: config.port,\n      user: config.username,\n      flags: '-FOUND_ROWS',\n      password: config.password,\n      database: config.database,\n      timezone: this.sequelize.options.timezone,\n      typeCast: ConnectionManager._typecast.bind(this),\n      bigNumberStrings: false,\n      supportBigNumbers: true\n    };\n\n    if (config.dialectOptions) {\n      for (const key of Object.keys(config.dialectOptions)) {\n        connectionConfig[key] = config.dialectOptions[key];\n      }\n    }\n\n    return new Utils.Promise((resolve, reject) => {\n      const connection = this.lib.createConnection(connectionConfig);\n\n      const errorHandler = e => {\n        // clean up connect event if there is error\n        connection.removeListener('connect', connectHandler);\n\n        if (config.pool.handleDisconnects) {\n          debug(`connection error ${e.code}`);\n\n          if (e.code === 'PROTOCOL_CONNECTION_LOST') {\n            return;\n          }\n        }\n\n        connection.removeListener('error', errorHandler);\n        reject(e);\n      };\n\n      const connectHandler = () => {\n        if (!config.pool.handleDisconnects) {\n          // clean up error event if connected\n          connection.removeListener('error', errorHandler);\n        }\n        resolve(connection);\n      };\n\n      connection.on('error', errorHandler);\n      connection.once('connect', connectHandler);\n    })\n      .tap (() => { debug('connection acquired'); })\n      .then(connection => {\n        return new Utils.Promise((resolve, reject) => {\n        // set timezone for this connection\n        // but named timezone are not directly supported in mysql, so get its offset first\n          let tzOffset = this.sequelize.options.timezone;\n          tzOffset = /\\//.test(tzOffset) ? momentTz.tz(tzOffset).format('Z') : tzOffset;\n          connection.query(`SET time_zone = '${tzOffset}'`, err => {\n            if (err) { reject(err); } else { resolve(connection); }\n          });\n        });\n      })\n      .catch(err => {\n        switch (err.code) {\n          case 'ECONNREFUSED':\n            throw new SequelizeErrors.ConnectionRefusedError(err);\n          case 'ER_ACCESS_DENIED_ERROR':\n            throw new SequelizeErrors.AccessDeniedError(err);\n          case 'ENOTFOUND':\n            throw new SequelizeErrors.HostNotFoundError(err);\n          case 'EHOSTUNREACH':\n            throw new SequelizeErrors.HostNotReachableError(err);\n          case 'EINVAL':\n            throw new SequelizeErrors.InvalidConnectionError(err);\n          default:\n            throw new SequelizeErrors.ConnectionError(err);\n        }\n      });\n  }\n\n  disconnect(connection) {\n    // Dont disconnect connections with CLOSED state\n    if (connection._closing) {\n      debug('connection tried to disconnect but was already at CLOSED state');\n      return Utils.Promise.resolve();\n    }\n\n    return new Utils.Promise((resolve, reject) => {\n      connection.end(err => {\n        if (err) {\n          reject(new SequelizeErrors.ConnectionError(err));\n        } else {\n          debug('connection disconnected');\n          resolve();\n        }\n      });\n    });\n  }\n\n  validate(connection) {\n    return connection && connection._fatalError === null && connection._protocolError === null && !connection._closing &&\n      !connection.stream.destroyed;\n  }\n}\n\nUtils._.extend(ConnectionManager.prototype, AbstractConnectionManager.prototype);\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/dialects/mysql/connection-manager.js\n// module id = 90\n// module chunks = 0","function webpackEmptyContext(req) {\n\tthrow new Error(\"Cannot find module '\" + req + \"'.\");\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 91;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/dialects/mysql\n// module id = 91\n// module chunks = 0","module.exports = require(\"mysql2\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"mysql2\"\n// module id = 92\n// module chunks = 0","'use strict';\n\nconst Utils = require('../../utils');\nconst debug = Utils.getLogger().debugContext('sql:mysql');\nconst AbstractQuery = require('../abstract/query');\nconst uuid = require('uuid');\nconst sequelizeErrors = require('../../errors.js');\nconst _ = require('lodash');\n\nclass Query extends AbstractQuery {\n  constructor(connection, sequelize, options) {\n    super();\n    this.connection = connection;\n    this.instance = options.instance;\n    this.model = options.model;\n    this.sequelize = sequelize;\n    this.uuid = uuid.v4();\n    this.options = Utils._.extend({\n      logging: console.log,\n      plain: false,\n      raw: false,\n      showWarnings: false\n    }, options || {});\n\n    this.checkLoggingOption();\n  }\n\n  run(sql) {\n    this.sql = sql;\n\n    //do we need benchmark for this query execution\n    const benchmark = this.sequelize.options.benchmark || this.options.benchmark;\n    const showWarnings = this.sequelize.options.showWarnings || this.options.showWarnings;\n\n    let queryBegin;\n    if (benchmark) {\n      queryBegin = Date.now();\n    } else {\n      this.sequelize.log('Executing (' + (this.connection.uuid || 'default') + '): ' + this.sql, this.options);\n    }\n\n    debug(`executing(${this.connection.uuid || 'default'}) : ${this.sql}`);\n\n    return new Utils.Promise((resolve, reject) => {\n      this.connection.query({ sql: this.sql }, (err, results) => {\n        debug(`executed(${this.connection.uuid || 'default'}) : ${this.sql}`);\n\n        if (benchmark) {\n          this.sequelize.log('Executed (' + (this.connection.uuid || 'default') + '): ' + this.sql, Date.now() - queryBegin, this.options);\n        }\n\n        if (err) {\n          err.sql = sql;\n\n          reject(this.formatError(err));\n        } else {\n          resolve(results);\n        }\n      }).setMaxListeners(100);\n    })\n    // Log warnings if we've got them.\n      .then(results => {\n        if (showWarnings && results && results.warningStatus > 0) {\n          return this.logWarnings(results);\n        }\n        return results;\n      })\n    // Return formatted results...\n      .then(results => this.formatResults(results));\n  }\n\n  /**\n   * High level function that handles the results of a query execution.\n   *\n   *\n   * Example:\n   *  query.formatResults([\n   *    {\n   *      id: 1,              // this is from the main table\n   *      attr2: 'snafu',     // this is from the main table\n   *      Tasks.id: 1,        // this is from the associated table\n   *      Tasks.title: 'task' // this is from the associated table\n   *    }\n   *  ])\n   *\n   * @param {Array} data - The result of the query execution.\n   * @private\n   */\n  formatResults(data) {\n    let result = this.instance;\n\n    if (this.isInsertQuery(data)) {\n      this.handleInsertQuery(data);\n\n      if (!this.instance) {\n        // handle bulkCreate AI primiary key\n        if (\n          data.constructor.name === 'ResultSetHeader'\n          && this.model\n          && this.model.autoIncrementAttribute\n          && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute\n          && this.model.rawAttributes[this.model.primaryKeyAttribute]\n        ) {\n          const startId = data[this.getInsertIdField()];\n          result = [];\n          for (let i = startId; i < startId + data.affectedRows; i++) {\n            result.push({ [this.model.rawAttributes[this.model.primaryKeyAttribute].field]: i });\n          }\n        } else {\n          result = data[this.getInsertIdField()];\n        }\n      }\n    }\n\n    if (this.isSelectQuery()) {\n      result = this.handleSelectQuery(data);\n    } else if (this.isShowTablesQuery()) {\n      result = this.handleShowTablesQuery(data);\n    } else if (this.isDescribeQuery()) {\n      result = {};\n\n      for (const _result of data) {\n        const enumRegex = /^enum/i;\n        result[_result.Field] = {\n          type: enumRegex.test(_result.Type) ? _result.Type.replace(enumRegex, 'ENUM') : _result.Type.toUpperCase(),\n          allowNull: _result.Null === 'YES',\n          defaultValue: _result.Default,\n          primaryKey: _result.Key === 'PRI'\n        };\n      }\n    } else if (this.isShowIndexesQuery()) {\n      result = this.handleShowIndexesQuery(data);\n\n    } else if (this.isCallQuery()) {\n      result = data[0];\n    } else if (this.isBulkUpdateQuery() || this.isBulkDeleteQuery() || this.isUpsertQuery()) {\n      result = data.affectedRows;\n    } else if (this.isVersionQuery()) {\n      result = data[0].version;\n    } else if (this.isForeignKeysQuery()) {\n      result = data;\n    } else if (this.isInsertQuery() || this.isUpdateQuery()) {\n      result = [result, data.affectedRows];\n    } else if (this.isShowConstraintsQuery()) {\n      result = data;\n    } else if (this.isRawQuery()) {\n      // MySQL returns row data and metadata (affected rows etc) in a single object - let's standarize it, sorta\n      result = [data, data];\n    }\n\n    return result;\n  }\n\n  logWarnings(results) {\n    return this.run('SHOW WARNINGS').then(warningResults => {\n      const warningMessage = 'MySQL Warnings (' + (this.connection.uuid||'default') + '): ';\n      const messages = [];\n      for (const _warningRow of warningResults) {\n        for (const _warningResult of _warningRow) {\n          if (_warningResult.hasOwnProperty('Message')) {\n            messages.push(_warningResult.Message);\n          } else {\n            for (const _objectKey of _warningResult.keys()) {\n              messages.push([_objectKey, _warningResult[_objectKey]].join(': '));\n            }\n          }\n        }\n      }\n\n      this.sequelize.log(warningMessage + messages.join('; '), this.options);\n\n      return results;\n    });\n  }\n\n  formatError(err) {\n    switch (err.errno || err.code) {\n      case 1062: {\n        const match = err.message.match(/Duplicate entry '(.*)' for key '?((.|\\s)*?)'?$/);\n\n        let fields = {};\n        let message = 'Validation error';\n        const values = match ? match[1].split('-') : undefined;\n        const uniqueKey = this.model && this.model.uniqueKeys[match[2]];\n\n        if (uniqueKey) {\n          if (uniqueKey.msg) message = uniqueKey.msg;\n          fields = Utils._.zipObject(uniqueKey.fields, values);\n        } else {\n          fields[match[2]] = match[1];\n        }\n\n        const errors = [];\n        Utils._.forOwn(fields, (value, field) => {\n          errors.push(new sequelizeErrors.ValidationErrorItem(\n            this.getUniqueConstraintErrorMessage(field),\n            'unique violation', field, value\n          ));\n        });\n\n        return new sequelizeErrors.UniqueConstraintError({message, errors, parent: err, fields});\n      }\n      case 1451: {\n        const match = err.message.match(/FOREIGN KEY \\(`(.*)`\\) REFERENCES `(.*)` \\(`(.*)`\\)(?: ON .*)?\\)$/);\n\n        return new sequelizeErrors.ForeignKeyConstraintError({\n          fields: null,\n          index: match ? match[3] : undefined,\n          parent: err\n        });\n      }\n      case 1452: {\n        const match = err.message.match(/FOREIGN KEY \\(`(.*)`\\) REFERENCES `(.*)` \\(`(.*)`\\)(.*)\\)$/);\n\n        return new sequelizeErrors.ForeignKeyConstraintError({\n          fields: null,\n          index: match ? match[1] : undefined,\n          parent: err\n        });\n      }\n      default:\n        return new sequelizeErrors.DatabaseError(err);\n    }\n  }\n\n  handleShowIndexesQuery(data) {\n    // Group by index name, and collect all fields\n    data = _.reduce(data, (acc, item) => {\n      if (!(item.Key_name in acc)) {\n        acc[item.Key_name] = item;\n        item.fields = [];\n      }\n\n      acc[item.Key_name].fields[item.Seq_in_index - 1] = {\n        attribute: item.Column_name,\n        length: item.Sub_part || undefined,\n        order: item.Collation === 'A' ? 'ASC' : undefined\n      };\n      delete item.column_name;\n\n      return acc;\n    }, {});\n\n    return Utils._.map(data, item => ({\n      primary: item.Key_name === 'PRIMARY',\n      fields: item.fields,\n      name: item.Key_name,\n      tableName: item.Table,\n      unique: item.Non_unique !== 1,\n      type: item.Index_type\n    }));\n  }\n}\n\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports.default = Query;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/dialects/mysql/query.js\n// module id = 93\n// module chunks = 0","'use strict';\n\nconst _ = require('lodash');\nconst AbstractDialect = require('../abstract');\nconst ConnectionManager = require('./connection-manager');\nconst Query = require('./query');\nconst QueryGenerator = require('./query-generator');\nconst DataTypes = require('../../data-types').postgres;\n\nclass PostgresDialect extends AbstractDialect {\n  constructor(sequelize) {\n    super();\n    this.sequelize = sequelize;\n    this.connectionManager = new ConnectionManager(this, sequelize);\n    this.QueryGenerator = _.extend({}, QueryGenerator, {\n      options: sequelize.options,\n      _dialect: this,\n      sequelize\n    });\n  }\n}\n\nPostgresDialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {\n  'DEFAULT VALUES': true,\n  'EXCEPTION': true,\n  'ON DUPLICATE KEY': false,\n  'ORDER NULLS': true,\n  returnValues: {\n    returning: true\n  },\n  bulkDefault: true,\n  schemas: true,\n  lock: true,\n  lockOf: true,\n  lockKey: true,\n  lockOuterJoinFailure: true,\n  forShare: 'FOR SHARE',\n  index: {\n    concurrently: true,\n    using: 2,\n    where: true\n  },\n  NUMERIC: true,\n  ARRAY: true,\n  RANGE: true,\n  GEOMETRY: true,\n  REGEXP: true,\n  GEOGRAPHY: true,\n  JSON: true,\n  JSONB: true,\n  HSTORE: true,\n  deferrableConstraints: true,\n  searchPath : true\n});\n\nConnectionManager.prototype.defaultVersion = '9.4.0';\nPostgresDialect.prototype.Query = Query;\nPostgresDialect.prototype.DataTypes = DataTypes;\nPostgresDialect.prototype.name = 'postgres';\nPostgresDialect.prototype.TICK_CHAR = '\"';\nPostgresDialect.prototype.TICK_CHAR_LEFT = PostgresDialect.prototype.TICK_CHAR;\nPostgresDialect.prototype.TICK_CHAR_RIGHT = PostgresDialect.prototype.TICK_CHAR;\n\nmodule.exports = PostgresDialect;\nmodule.exports.default = PostgresDialect;\nmodule.exports.PostgresDialect = PostgresDialect;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/dialects/postgres/index.js\n// module id = 94\n// module chunks = 0","'use strict';\n\nconst AbstractConnectionManager = require('../abstract/connection-manager');\nconst Utils = require('../../utils');\nconst debug = Utils.getLogger().debugContext('connection:pg');\nconst Promise = require('../../promise');\nconst sequelizeErrors = require('../../errors');\nconst semver = require('semver');\nconst dataTypes = require('../../data-types');\nconst moment = require('moment-timezone');\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    super(dialect, sequelize);\n\n    this.sequelize = sequelize;\n    this.sequelize.config.port = this.sequelize.config.port || 5432;\n    try {\n      let pgLib;\n      if (sequelize.config.dialectModulePath) {\n        pgLib = require(sequelize.config.dialectModulePath);\n      } else {\n        pgLib = require('pg');\n      }\n      this.lib = sequelize.config.native ? pgLib.native : pgLib;\n    } catch (err) {\n      if (err.code === 'MODULE_NOT_FOUND') {\n        throw new Error('Please install \\'' + (sequelize.config.dialectModulePath || 'pg') + '\\' module manually');\n      }\n      throw err;\n    }\n\n    this.refreshTypeParser(dataTypes.postgres);\n  }\n\n  // Expose this as a method so that the parsing may be updated when the user has added additional, custom types\n  _refreshTypeParser(dataType) {\n\n    if (dataType.types.postgres.oids) {\n      for (const oid of dataType.types.postgres.oids) {\n        this.lib.types.setTypeParser(oid, value => dataType.parse(value, oid, this.lib.types.getTypeParser));\n      }\n    }\n\n    if (dataType.types.postgres.array_oids) {\n      for (const oid of dataType.types.postgres.array_oids) {\n        this.lib.types.setTypeParser(oid, value =>\n          this.lib.types.arrayParser.create(value, v =>\n            dataType.parse(v, oid, this.lib.types.getTypeParser)\n          ).parse()\n        );\n      }\n    }\n  }\n\n  connect(config) {\n\n    config.user = config.username;\n    const connectionConfig = Utils._.pick(config, [\n      'user', 'password', 'host', 'database', 'port'\n    ]);\n\n    if (config.dialectOptions) {\n      Utils._.merge(connectionConfig,\n        Utils._.pick(config.dialectOptions, [\n        // see [http://www.postgresql.org/docs/9.3/static/runtime-config-logging.html#GUC-APPLICATION-NAME]\n          'application_name',\n          // choose the SSL mode with the PGSSLMODE environment variable\n          // object format: [https://github.com/brianc/node-postgres/blob/master/lib/connection.js#L79]\n          // see also [http://www.postgresql.org/docs/9.3/static/libpq-ssl.html]\n          'ssl',\n          // In addition to the values accepted by the corresponding server,\n          // you can use \"auto\" to determine the right encoding from the\n          // current locale in the client (LC_CTYPE environment variable on Unix systems)\n          'client_encoding',\n          // !! DONT SET THIS TO TRUE !!\n          // (unless you know what you're doing)\n          // see [http://www.postgresql.org/message-id/flat/bc9549a50706040852u27633f41ib1e6b09f8339d845@mail.gmail.com#bc9549a50706040852u27633f41ib1e6b09f8339d845@mail.gmail.com]\n          'binary',\n          // This should help with backends incorrectly considering idle clients to be dead and prematurely disconnecting them.\n          // this feature has been added in pg module v6.0.0, check pg/CHANGELOG.md\n          'keepAlive'\n        ]));\n    }\n\n    return new Promise((resolve, reject) => {\n      const connection = new this.lib.Client(connectionConfig);\n      let responded = false;\n\n      connection.connect(err => {\n        if (err) {\n          if (err.code) {\n            switch (err.code) {\n              case 'ECONNREFUSED':\n                reject(new sequelizeErrors.ConnectionRefusedError(err));\n                break;\n              case 'ENOTFOUND':\n                reject(new sequelizeErrors.HostNotFoundError(err));\n                break;\n              case 'EHOSTUNREACH':\n                reject(new sequelizeErrors.HostNotReachableError(err));\n                break;\n              case 'EINVAL':\n                reject(new sequelizeErrors.InvalidConnectionError(err));\n                break;\n              default:\n                reject(new sequelizeErrors.ConnectionError(err));\n                break;\n            }\n          } else {\n            reject(new sequelizeErrors.ConnectionError(err));\n          }\n          return;\n        }\n        responded = true;\n        debug('connection acquired');\n        resolve(connection);\n      });\n\n      // If we didn't ever hear from the client.connect() callback the connection timeout, node-postgres does not treat this as an error since no active query was ever emitted\n      connection.on('end', () => {\n        debug('connection timeout');\n        if (!responded) {\n          reject(new sequelizeErrors.ConnectionTimedOutError(new Error('Connection timed out')));\n        }\n      });\n\n      // Don't let a Postgres restart (or error) to take down the whole app\n      connection.on('error', err => {\n        debug(`connection error ${err.code}`);\n        connection._invalid = true;\n      });\n    }).tap(connection => {\n      // Disable escape characters in strings, see https://github.com/sequelize/sequelize/issues/3545\n      let query = '';\n\n      if (this.sequelize.options.databaseVersion !== 0 && semver.gte(this.sequelize.options.databaseVersion, '8.2.0')) {\n        query += 'SET standard_conforming_strings=on;';\n      }\n\n      if (!this.sequelize.config.keepDefaultTimezone) {\n        const isZone = !!moment.tz.zone(this.sequelize.options.timezone);\n        if (isZone) {\n          query += 'SET client_min_messages TO warning; SET TIME ZONE \\'' + this.sequelize.options.timezone + '\\';';\n        } else {\n          query += 'SET client_min_messages TO warning; SET TIME ZONE INTERVAL \\'' + this.sequelize.options.timezone + '\\' HOUR TO MINUTE;';\n        }\n      }\n\n      // oids for hstore and geometry are dynamic - so select them at connection time\n      const supportedVersion = this.sequelize.options.databaseVersion !== 0 && semver.gte(this.sequelize.options.databaseVersion, '8.3.0');\n      if (dataTypes.HSTORE.types.postgres.oids.length === 0 && supportedVersion) {\n        query += 'SELECT typname, oid, typarray FROM pg_type WHERE typtype = \\'b\\' AND typname IN (\\'hstore\\', \\'geometry\\', \\'geography\\')';\n      }\n\n      return new Promise((resolve, reject) => connection.query(query, (error, result) => error ? reject(error) : resolve(result))).then(results => {\n        const result = Array.isArray(results) ? results.pop() : results;\n        \n        for (const row of result.rows) {\n          let type;\n          if (row.typname === 'geometry') {\n            type = dataTypes.postgres.GEOMETRY;\n          } else if (row.typname === 'hstore') {\n            type = dataTypes.postgres.HSTORE;\n          } else if (row.typname === 'geography') {\n            type = dataTypes.postgres.GEOGRAPHY;\n          }\n\n          type.types.postgres.oids.push(row.oid);\n          type.types.postgres.array_oids.push(row.typarray);\n\n          this._refreshTypeParser(type);\n        }\n      });\n    });\n  }\n  disconnect(connection) {\n    return new Promise(resolve => {\n      connection.end();\n      resolve();\n    });\n  }\n\n  validate(connection) {\n    return connection._invalid === undefined;\n  }\n}\n\nUtils._.extend(ConnectionManager.prototype, AbstractConnectionManager.prototype);\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/dialects/postgres/connection-manager.js\n// module id = 95\n// module chunks = 0","function webpackEmptyContext(req) {\n\tthrow new Error(\"Cannot find module '\" + req + \"'.\");\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 96;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/dialects/postgres\n// module id = 96\n// module chunks = 0","module.exports = require(\"pg\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"pg\"\n// module id = 97\n// module chunks = 0","'use strict';\n\nconst Utils = require('../../utils');\nconst debug = Utils.getLogger().debugContext('sql:pg');\nconst AbstractQuery = require('../abstract/query');\nconst QueryTypes = require('../../query-types');\nconst Promise = require('../../promise');\nconst sequelizeErrors = require('../../errors.js');\nconst _ = require('lodash');\n\nclass Query extends AbstractQuery {\n  constructor(client, sequelize, options) {\n    super();\n    this.client = client;\n    this.sequelize = sequelize;\n    this.instance = options.instance;\n    this.model = options.model;\n    this.options = _.extend({\n      logging: console.log,\n      plain: false,\n      raw: false\n    }, options || {});\n\n    this.checkLoggingOption();\n  }\n\n  /**\n   * rewrite query with parameters\n   * @private\n   */\n  static formatBindParameters(sql, values, dialect) {\n    let bindParam = [];\n    if (Array.isArray(values)) {\n      bindParam = values;\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, { skipValueReplace: true })[0];\n    } else {\n      let i = 0;\n      const seen = {};\n      const replacementFunc = (match, key, values) => {\n        if (seen[key] !== undefined) {\n          return seen[key];\n        }\n        if (values[key] !== undefined) {\n          i = i + 1;\n          bindParam.push(values[key]);\n          seen[key] = '$'+i;\n          return '$'+i;\n        }\n        return undefined;\n      };\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];\n    }\n    return [sql, bindParam];\n  }\n\n  run(sql, parameters) {\n    this.sql = sql;\n\n    if (!Utils._.isEmpty(this.options.searchPath)) {\n      this.sql = this.sequelize.getQueryInterface().QueryGenerator.setSearchPath(this.options.searchPath) + sql;\n    }\n\n    const query = parameters && parameters.length\n      ? new Promise((resolve, reject) => this.client.query(this.sql, parameters, (error, result) => error ? reject(error) : resolve(result)))\n      : new Promise((resolve, reject) => this.client.query(this.sql, (error, result) => error ? reject(error) : resolve(result)));\n\n    //do we need benchmark for this query execution\n    const benchmark = this.sequelize.options.benchmark || this.options.benchmark;\n\n    let queryBegin;\n    if (benchmark) {\n      queryBegin = Date.now();\n    } else {\n      this.sequelize.log('Executing (' + (this.client.uuid || 'default') + '): ' + this.sql, this.options);\n    }\n\n    debug(`executing(${this.client.uuid || 'default'}) : ${this.sql}`);\n\n    return query.catch(err => {\n      // set the client so that it will be reaped if the connection resets while executing\n      if (err.code === 'ECONNRESET') {\n        this.client._invalid = true;\n      }\n\n      err.sql = sql;\n      throw this.formatError(err);\n    })\n      .then(queryResult => {\n        debug(`executed(${this.client.uuid || 'default'}) : ${this.sql}`);\n\n        if (benchmark) {\n          this.sequelize.log('Executed (' + (this.client.uuid || 'default') + '): ' + this.sql, Date.now() - queryBegin, this.options);\n        }\n\n        return queryResult;\n      })\n      .then(queryResult => {\n        const rows = queryResult.rows;\n        const rowCount = queryResult.rowCount;\n        const isTableNameQuery = sql.indexOf('SELECT table_name FROM information_schema.tables') === 0;\n        const isRelNameQuery = sql.indexOf('SELECT relname FROM pg_class WHERE oid IN') === 0;\n\n        if (isRelNameQuery) {\n          return rows.map(row => ({\n            name: row.relname,\n            tableName: row.relname.split('_')[0]\n          }));\n        } else if (isTableNameQuery) {\n          return rows.map(row => _.values(row));\n        }\n\n        if (rows[0] && rows[0].sequelize_caught_exception !== undefined) {\n          if (rows[0].sequelize_caught_exception !== null) {\n            throw this.formatError({\n              code: '23505',\n              detail: rows[0].sequelize_caught_exception\n            });\n          } else {\n            for (const row of rows) {\n              delete row.sequelize_caught_exception;\n            }\n          }\n        }\n\n        if (this.isShowIndexesQuery()) {\n          for (const row of rows) {\n            const attributes = /ON .*? (?:USING .*?\\s)?\\(([^]*)\\)/gi.exec(row.definition)[1].split(',');\n\n            // Map column index in table to column name\n            const columns = _.zipObject(\n              row.column_indexes,\n              this.sequelize.getQueryInterface().QueryGenerator.fromArray(row.column_names)\n            );\n            delete row.column_indexes;\n            delete row.column_names;\n\n            let field;\n            let attribute;\n\n            // Indkey is the order of attributes in the index, specified by a string of attribute indexes\n            row.fields = row.indkey.split(' ').map((indKey, index) => {\n              field = columns[indKey];\n              // for functional indices indKey = 0\n              if (!field) {\n                return null;\n              }\n              attribute = attributes[index];\n              return {\n                attribute: field,\n                collate: attribute.match(/COLLATE \"(.*?)\"/) ? /COLLATE \"(.*?)\"/.exec(attribute)[1] : undefined,\n                order: attribute.indexOf('DESC') !== -1 ? 'DESC' : attribute.indexOf('ASC') !== -1 ? 'ASC': undefined,\n                length: undefined\n              };\n            }).filter(n => n !== null);\n            delete row.columns;\n          }\n          return rows;\n        } else if (this.isForeignKeysQuery()) {\n          const result = [];\n          for (const row of rows) {\n            let defParts;\n            if (row.condef !== undefined && (defParts = row.condef.match(/FOREIGN KEY \\((.+)\\) REFERENCES (.+)\\((.+)\\)( ON (UPDATE|DELETE) (CASCADE|RESTRICT))?( ON (UPDATE|DELETE) (CASCADE|RESTRICT))?/))) {\n              row.id = row.constraint_name;\n              row.table = defParts[2];\n              row.from = defParts[1];\n              row.to = defParts[3];\n              let i;\n              for (i=5;i<=8;i+=3) {\n                if (/(UPDATE|DELETE)/.test(defParts[i])) {\n                  row['on_'+defParts[i].toLowerCase()] = defParts[i+1];\n                }\n              }\n            }\n            result.push(row);\n          }\n          return result;\n        } else if (this.isSelectQuery()) {\n          let result = rows;\n          // Postgres will treat tables as case-insensitive, so fix the case\n          // of the returned values to match attributes\n          if (this.options.raw === false && this.sequelize.options.quoteIdentifiers === false) {\n            const attrsMap = _.reduce(this.model.rawAttributes, (m, v, k) => {\n              m[k.toLowerCase()] = k;\n              return m;\n            }, {});\n            result = _.map(rows, row=> {\n              return _.mapKeys(row, (value, key)=> {\n                const targetAttr = attrsMap[key];\n                if (typeof targetAttr === 'string' && targetAttr !== key) {\n                  return targetAttr;\n                } else {\n                  return key;\n                }\n              });\n            });\n          }\n          return this.handleSelectQuery(result);\n        } else if (QueryTypes.DESCRIBE === this.options.type) {\n          const result = {};\n\n          for (const row of rows) {\n            result[row.Field] = {\n              type: row.Type.toUpperCase(),\n              allowNull: row.Null === 'YES',\n              defaultValue: row.Default,\n              special: row.special ? this.sequelize.getQueryInterface().QueryGenerator.fromArray(row.special) : [],\n              primaryKey: row.Constraint === 'PRIMARY KEY'\n            };\n\n            if (result[row.Field].type === 'BOOLEAN') {\n              result[row.Field].defaultValue = { 'false': false, 'true': true }[result[row.Field].defaultValue];\n\n              if (result[row.Field].defaultValue === undefined) {\n                result[row.Field].defaultValue = null;\n              }\n            }\n\n            if (typeof result[row.Field].defaultValue === 'string') {\n              result[row.Field].defaultValue = result[row.Field].defaultValue.replace(/'/g, '');\n\n              if (result[row.Field].defaultValue.indexOf('::') > -1) {\n                const split = result[row.Field].defaultValue.split('::');\n                if (split[1].toLowerCase() !== 'regclass)') {\n                  result[row.Field].defaultValue = split[0];\n                }\n              }\n            }\n          }\n\n          return result;\n        } else if (this.isVersionQuery()) {\n          return rows[0].server_version;\n        } else if (this.isShowOrDescribeQuery()) {\n          return rows;\n        } else if (QueryTypes.BULKUPDATE === this.options.type) {\n          if (!this.options.returning) {\n            return parseInt(rowCount, 10);\n          }\n\n          return this.handleSelectQuery(rows);\n        } else if (QueryTypes.BULKDELETE === this.options.type) {\n          return parseInt(rowCount, 10);\n        } else if (this.isUpsertQuery()) {\n          return rows[0].sequelize_upsert;\n        } else if (this.isInsertQuery() || this.isUpdateQuery()) {\n          if (this.instance && this.instance.dataValues) {\n            for (const key in rows[0]) {\n              if (rows[0].hasOwnProperty(key)) {\n                const record = rows[0][key];\n\n                const attr = _.find(this.model.rawAttributes, attribute => attribute.fieldName === key || attribute.field === key);\n\n                this.instance.dataValues[attr && attr.fieldName || key] = record;\n              }\n            }\n          }\n\n          return [\n            this.instance || rows && (this.options.plain && rows[0] || rows) || undefined,\n            rowCount\n          ];\n        } else if (this.isRawQuery()) {\n          return [rows, queryResult];\n        } else {\n          return rows;\n        }\n      });\n  }\n\n  formatError(err) {\n    let match;\n    let table;\n    let index;\n    let fields;\n    let errors;\n    let message;\n\n    const code = err.code || err.sqlState;\n    const errMessage = err.message || err.messagePrimary;\n    const errDetail = err.detail || err.messageDetail;\n\n    switch (code) {\n      case '23503':\n        index = errMessage.match(/violates foreign key constraint \\\"(.+?)\\\"/);\n        index = index ? index[1] : undefined;\n        table = errMessage.match(/on table \\\"(.+?)\\\"/);\n        table = table ? table[1] : undefined;\n\n        return new sequelizeErrors.ForeignKeyConstraintError({message: errMessage, fields: null, index, table, parent: err});\n      case '23505':\n        // there are multiple different formats of error messages for this error code\n        // this regex should check at least two\n        if (errDetail && (match = errDetail.replace(/\"/g, '').match(/Key \\((.*?)\\)=\\((.*?)\\)/))) {\n          fields = _.zipObject(match[1].split(', '), match[2].split(', '));\n          errors = [];\n          message = 'Validation error';\n\n          _.forOwn(fields, (value, field) => {\n            errors.push(new sequelizeErrors.ValidationErrorItem(\n              this.getUniqueConstraintErrorMessage(field),\n              'unique violation', field, value));\n          });\n\n          if (this.model && this.model.uniqueKeys) {\n            _.forOwn(this.model.uniqueKeys, constraint => {\n              if (_.isEqual(constraint.fields, Object.keys(fields)) && !!constraint.msg) {\n                message = constraint.msg;\n                return false;\n              }\n            });\n          }\n\n          return new sequelizeErrors.UniqueConstraintError({message, errors, parent: err, fields});\n        }\n\n        return new sequelizeErrors.UniqueConstraintError({\n          message: errMessage,\n          parent: err\n        });\n\n      case '23P01':\n        match = errDetail.match(/Key \\((.*?)\\)=\\((.*?)\\)/);\n\n        if (match) {\n          fields = _.zipObject(match[1].split(', '), match[2].split(', '));\n        }\n        message = 'Exclusion constraint error';\n\n        return new sequelizeErrors.ExclusionConstraintError({\n          message,\n          constraint: err.constraint,\n          fields,\n          table: err.table,\n          parent: err\n        });\n\n      case '42704':\n        if (err.sql && /CONSTRAINT/gi.test(err.sql)) {\n          message = 'Unknown constraint error';\n\n          throw new sequelizeErrors.UnknownConstraintError({\n            message,\n            constraint: err.constraint,\n            fields,\n            table: err.table,\n            parent: err\n          });\n        }\n\n      default:\n        return new sequelizeErrors.DatabaseError(err);\n    }\n  }\n\n  isForeignKeysQuery() {\n    return /SELECT conname as constraint_name, pg_catalog\\.pg_get_constraintdef\\(r\\.oid, true\\) as condef FROM pg_catalog\\.pg_constraint r WHERE r\\.conrelid = \\(SELECT oid FROM pg_class WHERE relname = '.*' LIMIT 1\\) AND r\\.contype = 'f' ORDER BY 1;/.test(this.sql);\n  }\n\n  getInsertIdField() {\n    return 'id';\n  }\n}\n\n\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports.default = Query;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/dialects/postgres/query.js\n// module id = 98\n// module chunks = 0","'use strict';\n\nconst Utils = require('../../utils');\nconst util = require('util');\nconst DataTypes = require('../../data-types');\nconst AbstractQueryGenerator = require('../abstract/query-generator');\nconst semver = require('semver');\nconst _ = require('lodash');\n\nconst QueryGenerator = {\n  __proto__: AbstractQueryGenerator,\n  options: {},\n  dialect: 'postgres',\n\n  setSearchPath(searchPath) {\n    return `SET search_path to ${searchPath};`;\n  },\n\n  createSchema(schema) {\n    return `CREATE SCHEMA ${schema};`;\n  },\n\n  dropSchema(schema) {\n    return `DROP SCHEMA IF EXISTS ${schema} CASCADE;`;\n  },\n\n  showSchemasQuery() {\n    return \"SELECT schema_name FROM information_schema.schemata WHERE schema_name <> 'information_schema' AND schema_name != 'public' AND schema_name !~ E'^pg_';\";\n  },\n\n  versionQuery() {\n    return 'SHOW SERVER_VERSION';\n  },\n\n  createTableQuery(tableName, attributes, options) {\n\n    options = Utils._.extend({\n    }, options || {});\n\n    //Postgres 9.0 does not support CREATE TABLE IF NOT EXISTS, 9.1 and above do\n    const databaseVersion = Utils._.get(this, 'sequelize.options.databaseVersion', 0);\n    const attrStr = [];\n    let comments = '';\n\n    if (options.comment && Utils._.isString(options.comment)) {\n      comments += '; COMMENT ON TABLE <%= table %> IS ' + this.escape(options.comment);\n    }\n\n    for (const attr in attributes) {\n      const i = attributes[attr].indexOf('COMMENT');\n      if (i !== -1) {\n        // Move comment to a separate query\n        comments += '; ' + attributes[attr].substring(i);\n        attributes[attr] = attributes[attr].substring(0, i);\n      }\n\n      const dataType = this.dataTypeMapping(tableName, attr, attributes[attr]);\n      attrStr.push(this.quoteIdentifier(attr) + ' ' + dataType);\n    }\n\n    const values = {\n      table: this.quoteTable(tableName),\n      attributes: attrStr.join(', '),\n      comments: Utils._.template(comments)({ table: this.quoteTable(tableName) })\n    };\n\n    if (options.uniqueKeys) {\n      Utils._.each(options.uniqueKeys, columns => {\n        if (!columns.singleField) { // If it's a single field its handled in column def, not as an index\n          values.attributes += ', UNIQUE (' + columns.fields.map(f => this.quoteIdentifiers(f)).join(', ') + ')';\n        }\n      });\n    }\n\n    const pks = _.reduce(attributes, (acc, attribute, key) => {\n      if (_.includes(attribute, 'PRIMARY KEY')) {\n        acc.push(this.quoteIdentifier(key));\n      }\n      return acc;\n    }, []).join(',');\n\n    if (pks.length > 0) {\n      values.attributes += ', PRIMARY KEY (' + pks + ')';\n    }\n\n    return `CREATE TABLE ${databaseVersion === 0 || semver.gte(databaseVersion, '9.1.0') ? 'IF NOT EXISTS ' : ''}${values.table} (${values.attributes})${values.comments};`;\n  },\n\n  dropTableQuery(tableName, options) {\n    options = options || {};\n    return `DROP TABLE IF EXISTS ${this.quoteTable(tableName)}${options.cascade ? ' CASCADE' : ''};`;\n  },\n\n  showTablesQuery() {\n    return \"SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_type LIKE '%TABLE' AND table_name != 'spatial_ref_sys';\";\n  },\n\n  describeTableQuery(tableName, schema) {\n    if (!schema) {\n      schema = 'public';\n    }\n    return 'SELECT pk.constraint_type as \"Constraint\", c.column_name as \"Field\", ' +\n              'c.column_default as \"Default\", c.is_nullable as \"Null\", ' +\n              '(CASE WHEN c.udt_name = \\'hstore\\' THEN c.udt_name ELSE c.data_type END) || (CASE WHEN c.character_maximum_length IS NOT NULL THEN \\'(\\' || c.character_maximum_length || \\')\\' ELSE \\'\\' END) as \"Type\", ' +\n              '(SELECT array_agg(e.enumlabel) ' +\n              'FROM pg_catalog.pg_type t JOIN pg_catalog.pg_enum e ON t.oid=e.enumtypid ' +\n              'WHERE t.typname=c.udt_name) AS \"special\" ' +\n            'FROM information_schema.columns c ' +\n            'LEFT JOIN (SELECT tc.table_schema, tc.table_name, ' +\n              'cu.column_name, tc.constraint_type ' +\n              'FROM information_schema.TABLE_CONSTRAINTS tc ' +\n              'JOIN information_schema.KEY_COLUMN_USAGE  cu ' +\n              'ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name ' +\n                'and tc.constraint_name=cu.constraint_name ' +\n                'and tc.constraint_type=\\'PRIMARY KEY\\') pk ' +\n            'ON pk.table_schema=c.table_schema ' +\n            'AND pk.table_name=c.table_name ' +\n            'AND pk.column_name=c.column_name ' +\n      `WHERE c.table_name = ${this.escape(tableName)} AND c.table_schema = ${this.escape(schema)} `;\n  },\n\n  /**\n   * Check whether the statmement is json function or simple path\n   *\n   * @param   {String}  stmt  The statement to validate\n   * @returns {Boolean}       true if the given statement is json function\n   * @throws  {Error}         throw if the statement looks like json function but has invalid token\n   */\n  checkValidJsonStatement(stmt) {\n    if (!_.isString(stmt)) {\n      return false;\n    }\n\n    // https://www.postgresql.org/docs/current/static/functions-json.html\n    const jsonFunctionRegex = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\n    const jsonOperatorRegex = /^\\s*(->>?|#>>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\n    const tokenCaptureRegex = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\n\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = jsonFunctionRegex.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf('(');\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const operatorMatches = jsonOperatorRegex.exec(string);\n      if (operatorMatches) {\n        currentIndex += operatorMatches[0].length;\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const tokenMatches = tokenCaptureRegex.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === '(') {\n          openingBrackets++;\n        } else if (capturedToken === ')') {\n          closingBrackets++;\n        } else if (capturedToken === ';') {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n\n      break;\n    }\n\n    // Check invalid json statement\n    hasInvalidToken |= openingBrackets !== closingBrackets;\n    if (hasJsonFunction && hasInvalidToken) {\n      throw new Error('Invalid json statement: ' + stmt);\n    }\n\n    // return true if the statement has valid json function\n    return hasJsonFunction;\n  },\n\n  /**\n   * Generates an SQL query that extract JSON property of given path.\n   *\n   * @param   {String}               column  The JSON column\n   * @param   {String|Array<String>} [path]  The path to extract (optional)\n   * @returns {String}                       The generated sql query\n   * @private\n   */\n  jsonPathExtractionQuery(column, path) {\n    const paths = _.toPath(path);\n    const pathStr = this.escape(`{${paths.join(',')}}`);\n    const quotedColumn = this.isIdentifierQuoted(column) ? column : this.quoteIdentifier(column);\n    return `(${quotedColumn}#>>${pathStr})`;\n  },\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Utils.Json) {\n      // Parse nested object\n      if (smth.conditions) {\n        const conditions = _.map(this.parseConditionObject(smth.conditions), condition =>\n          `${this.jsonPathExtractionQuery(_.first(condition.path), _.tail(condition.path))} = '${condition.value}'`\n        );\n\n        return conditions.join(' AND ');\n      } else if (smth.path) {\n        let str;\n\n        // Allow specifying conditions using the postgres json syntax\n        if (this.checkValidJsonStatement(smth.path)) {\n          str = smth.path;\n        } else {\n          // Also support json property accessors\n          const paths = _.toPath(smth.path);\n          const column = paths.shift();\n          str = this.jsonPathExtractionQuery(column, paths);\n        }\n\n        if (smth.value) {\n          str += util.format(' = %s', this.escape(smth.value));\n        }\n\n        return str;\n      }\n    }\n    return AbstractQueryGenerator.handleSequelizeMethod.call(this, smth, tableName, factory, options, prepend);\n  },\n\n  addColumnQuery(table, key, dataType) {\n\n    const dbDataType = this.attributeToSQL(dataType, { context: 'addColumn' });\n    const definition = this.dataTypeMapping(table, key, dbDataType);\n    const quotedKey = this.quoteIdentifier(key);\n    const quotedTable = this.quoteTable(this.extractTableDetails(table));\n\n    let query = `ALTER TABLE ${quotedTable} ADD COLUMN ${quotedKey} ${definition};`;\n\n    if (dataType.type && dataType.type instanceof DataTypes.ENUM || dataType instanceof DataTypes.ENUM) {\n      query = this.pgEnum(table, key, dataType) + query;\n    }\n\n    return query;\n  },\n\n  removeColumnQuery(tableName, attributeName) {\n    const quotedTableName = this.quoteTable(this.extractTableDetails(tableName));\n    const quotedAttributeName = this.quoteIdentifier(attributeName);\n    return `ALTER TABLE ${quotedTableName} DROP COLUMN ${quotedAttributeName};`;\n  },\n\n  changeColumnQuery(tableName, attributes) {\n    const query = 'ALTER TABLE <%= tableName %> ALTER COLUMN <%= query %>;';\n    const sql = [];\n\n    for (const attributeName in attributes) {\n      let definition = this.dataTypeMapping(tableName, attributeName, attributes[attributeName]);\n      let attrSql = '';\n\n      if (definition.indexOf('NOT NULL') > 0) {\n        attrSql += Utils._.template(query)({\n          tableName: this.quoteTable(tableName),\n          query: this.quoteIdentifier(attributeName) + ' SET NOT NULL'\n        });\n\n        definition = definition.replace('NOT NULL', '').trim();\n      } else if (!definition.match(/REFERENCES/)) {\n        attrSql += Utils._.template(query)({\n          tableName: this.quoteTable(tableName),\n          query: this.quoteIdentifier(attributeName) + ' DROP NOT NULL'\n        });\n      }\n\n      if (definition.indexOf('DEFAULT') > 0) {\n        attrSql += Utils._.template(query)({\n          tableName: this.quoteTable(tableName),\n          query: this.quoteIdentifier(attributeName) + ' SET DEFAULT ' + definition.match(/DEFAULT ([^;]+)/)[1]\n        });\n\n        definition = definition.replace(/(DEFAULT[^;]+)/, '').trim();\n      } else if (!definition.match(/REFERENCES/)) {\n        attrSql += Utils._.template(query)({\n          tableName: this.quoteTable(tableName),\n          query: this.quoteIdentifier(attributeName) + ' DROP DEFAULT'\n        });\n      }\n\n      if (attributes[attributeName].match(/^ENUM\\(/)) {\n        attrSql += this.pgEnum(tableName, attributeName, attributes[attributeName]);\n        definition = definition.replace(/^ENUM\\(.+\\)/, this.pgEnumName(tableName, attributeName, { schema: false }));\n        definition += ' USING (' + this.quoteIdentifier(attributeName) + '::' + this.pgEnumName(tableName, attributeName) + ')';\n      }\n\n      if (definition.match(/UNIQUE;*$/)) {\n        definition = definition.replace(/UNIQUE;*$/, '');\n\n        attrSql += Utils._.template(query.replace('ALTER COLUMN', ''))({\n          tableName: this.quoteTable(tableName),\n          query: 'ADD CONSTRAINT ' + this.quoteIdentifier(attributeName + '_unique_idx') + ' UNIQUE (' + this.quoteIdentifier(attributeName) + ')'\n        });\n      }\n\n      if (definition.match(/REFERENCES/)) {\n        definition = definition.replace(/.+?(?=REFERENCES)/, '');\n        attrSql += Utils._.template(query.replace('ALTER COLUMN', ''))({\n          tableName: this.quoteTable(tableName),\n          query: 'ADD CONSTRAINT ' + this.quoteIdentifier(attributeName + '_foreign_idx') + ' FOREIGN KEY (' + this.quoteIdentifier(attributeName) + ') ' + definition\n        });\n      } else {\n        attrSql += Utils._.template(query)({\n          tableName: this.quoteTable(tableName),\n          query: this.quoteIdentifier(attributeName) + ' TYPE ' + definition\n        });\n      }\n\n      sql.push(attrSql);\n    }\n\n    return sql.join('');\n  },\n\n  renameColumnQuery(tableName, attrBefore, attributes) {\n\n    const attrString = [];\n\n    for (const attributeName in attributes) {\n      attrString.push(Utils._.template('<%= before %> TO <%= after %>')({\n        before: this.quoteIdentifier(attrBefore),\n        after: this.quoteIdentifier(attributeName)\n      }));\n    }\n\n    return `ALTER TABLE ${this.quoteTable(tableName)} RENAME COLUMN ${attrString.join(', ')};`;\n  },\n\n  fn(fnName, tableName, body, returns, language) {\n    fnName = fnName || 'testfunc';\n    language = language || 'plpgsql';\n    returns = returns || 'SETOF ' + this.quoteTable(tableName);\n\n    return `CREATE OR REPLACE FUNCTION pg_temp.${fnName}() RETURNS ${returns} AS $func$ BEGIN ${body} END; $func$ LANGUAGE ${language}; SELECT * FROM pg_temp.${fnName}();`;\n  },\n\n  exceptionFn(fnName, tableName, main, then, when, returns, language) {\n    when = when || 'unique_violation';\n\n    const body = `${main} EXCEPTION WHEN ${when} THEN ${then};`;\n\n    return this.fn(fnName, tableName, body, returns, language);\n  },\n\n  upsertQuery(tableName, insertValues, updateValues, where, model, options) {\n    const insert = this.insertQuery(tableName, insertValues, model.rawAttributes, options);\n    const update = this.updateQuery(tableName, updateValues, where, options, model.rawAttributes);\n\n    // The numbers here are selected to match the number of affected rows returned by MySQL\n    return this.exceptionFn(\n      'sequelize_upsert',\n      tableName,\n      insert + ' RETURN 1;',\n      update + '; RETURN 2',\n      'unique_violation',\n      'integer'\n    );\n  },\n\n  deleteQuery(tableName, where, options, model) {\n    let query;\n\n    options = options || {};\n\n    tableName = this.quoteTable(tableName);\n\n    if (options.truncate === true) {\n      query = 'TRUNCATE ' + tableName;\n\n      if (options.restartIdentity) {\n        query += ' RESTART IDENTITY';\n      }\n\n      if (options.cascade) {\n        query += ' CASCADE';\n      }\n\n      return query;\n    }\n\n    if (Utils._.isUndefined(options.limit)) {\n      options.limit = 1;\n    }\n\n    const replacements = {\n      table: tableName,\n      where: this.getWhereConditions(where, null, model, options),\n      limit: options.limit ? ' LIMIT ' + this.escape(options.limit) : ''\n    };\n\n    if (options.limit) {\n      if (!model) {\n        throw new Error('Cannot LIMIT delete without a model.');\n      }\n\n      const pks = _.map(_.values(model.primaryKeys), pk => this.quoteIdentifier(pk.field)).join(',');\n\n      replacements.primaryKeys = model.primaryKeyAttributes.length > 1 ? '(' + pks + ')' : pks;\n      replacements.primaryKeysSelection = pks;\n\n      query = 'DELETE FROM <%= table %> WHERE <%= primaryKeys %> IN (SELECT <%= primaryKeysSelection %> FROM <%= table %><%= where %><%= limit %>)';\n    } else {\n      query = 'DELETE FROM <%= table %><%= where %>';\n    }\n\n    if (replacements.where) {\n      replacements.where = ' WHERE ' + replacements.where;\n    }\n\n    return Utils._.template(query)(replacements);\n  },\n\n  showIndexesQuery(tableName) {\n    let schemaJoin = '';\n    let schemaWhere = '';\n    if (!Utils._.isString(tableName)) {\n      schemaJoin = ', pg_namespace s';\n      schemaWhere = ` AND s.oid = t.relnamespace AND s.nspname = '${tableName.schema}'`;\n      tableName = tableName.tableName;\n    }\n\n    // This is ARCANE!\n    return 'SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, ' +\n      'array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) ' +\n      `AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a${schemaJoin} ` +\n      'WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND ' +\n      `t.relkind = 'r' and t.relname = '${tableName}'${schemaWhere} ` +\n      'GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;';\n  },\n\n  showConstraintsQuery(tableName) {\n    //Postgres converts camelCased alias to lowercase unless quoted\n    return [\n      'SELECT constraint_catalog AS \"constraintCatalog\",',\n      'constraint_schema AS \"constraintSchema\",',\n      'constraint_name AS \"constraintName\",',\n      'table_catalog AS \"tableCatalog\",',\n      'table_schema AS \"tableSchema\",',\n      'table_name AS \"tableName\",',\n      'constraint_type AS \"constraintType\",',\n      'is_deferrable AS \"isDeferrable\",',\n      'initially_deferred AS \"initiallyDeferred\"',\n      'from INFORMATION_SCHEMA.table_constraints',\n      `WHERE table_name='${tableName}';`\n    ].join(' ');\n  },\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(tableName + '_' + indexNameOrAttributes.join('_'));\n    }\n\n    return `DROP INDEX IF EXISTS ${this.quoteIdentifiers(indexName)}`;\n  },\n\n  addLimitAndOffset(options) {\n    let fragment = '';\n    /* eslint-disable */\n    if (options.limit != null) {\n      fragment += ' LIMIT ' + this.escape(options.limit);\n    }\n    if (options.offset != null) {\n      fragment += ' OFFSET ' + this.escape(options.offset);\n    }\n    /* eslint-enable */\n\n    return fragment;\n  },\n\n  attributeToSQL(attribute) {\n    if (!Utils._.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n\n    let type;\n    if (attribute.type instanceof DataTypes.ENUM) {\n      if (attribute.type.values && !attribute.values) attribute.values = attribute.type.values;\n\n      if (Array.isArray(attribute.values) && attribute.values.length > 0) {\n        type = 'ENUM(' + Utils._.map(attribute.values, value => this.escape(value)).join(', ') + ')';\n      } else {\n        throw new Error(\"Values for ENUM haven't been defined.\");\n      }\n    }\n\n    if (!type) {\n      type = attribute.type;\n    }\n\n    let sql = type + '';\n\n    if (attribute.hasOwnProperty('allowNull') && !attribute.allowNull) {\n      sql += ' NOT NULL';\n    }\n\n    if (attribute.autoIncrement) {\n      sql += ' SERIAL';\n    }\n\n    if (Utils.defaultValueSchemable(attribute.defaultValue)) {\n      sql += ' DEFAULT ' + this.escape(attribute.defaultValue, attribute);\n    }\n\n    if (attribute.unique === true) {\n      sql += ' UNIQUE';\n    }\n\n    if (attribute.primaryKey) {\n      sql += ' PRIMARY KEY';\n    }\n\n    if (attribute.references) {\n      const referencesTable = this.quoteTable(attribute.references.model);\n      let referencesKey;\n\n      if (attribute.references.key) {\n        referencesKey = this.quoteIdentifiers(attribute.references.key);\n      } else {\n        referencesKey = this.quoteIdentifier('id');\n      }\n\n      sql += ` REFERENCES ${referencesTable} (${referencesKey})`;\n\n      if (attribute.onDelete) {\n        sql += ' ON DELETE ' + attribute.onDelete.toUpperCase();\n      }\n\n      if (attribute.onUpdate) {\n        sql += ' ON UPDATE ' + attribute.onUpdate.toUpperCase();\n      }\n\n      if (attribute.references.deferrable) {\n        sql += ' ' + attribute.references.deferrable.toString(this);\n      }\n    }\n\n    return sql;\n  },\n\n  deferConstraintsQuery(options) {\n    return options.deferrable.toString(this);\n  },\n\n  setConstraintQuery(columns, type) {\n    let columnFragment = 'ALL';\n\n    if (columns) {\n      columnFragment = columns.map(column => this.quoteIdentifier(column)).join(', ');\n    }\n\n    return 'SET CONSTRAINTS ' + columnFragment + ' ' + type;\n  },\n\n  setDeferredQuery(columns) {\n    return this.setConstraintQuery(columns, 'DEFERRED');\n  },\n\n  setImmediateQuery(columns) {\n    return this.setConstraintQuery(columns, 'IMMEDIATE');\n  },\n\n  attributesToSQL(attributes, options) {\n    const result = {};\n\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n\n    return result;\n  },\n\n  createTrigger(tableName, triggerName, eventType, fireOnSpec, functionName, functionParams, optionsArray) {\n\n    const decodedEventType = this.decodeTriggerEventType(eventType);\n    const eventSpec = this.expandTriggerEventSpec(fireOnSpec);\n    const expandedOptions = this.expandOptions(optionsArray);\n    const paramList = this.expandFunctionParamList(functionParams);\n\n    return `CREATE ${this.triggerEventTypeIsConstraint(eventType)}TRIGGER ${triggerName}\\n`\n      + `\\t${decodedEventType} ${eventSpec}\\n`\n      + `\\tON ${tableName}\\n`\n      + `\\t${expandedOptions}\\n`\n      + `\\tEXECUTE PROCEDURE ${functionName}(${paramList});`;\n  },\n\n  dropTrigger(tableName, triggerName) {\n    return `DROP TRIGGER ${triggerName} ON ${tableName} RESTRICT;`;\n  },\n\n  renameTrigger(tableName, oldTriggerName, newTriggerName) {\n    return `ALTER TRIGGER ${oldTriggerName} ON ${tableName} RENAME TO ${newTriggerName};`;\n  },\n\n  createFunction(functionName, params, returnType, language, body, options) {\n    if (!functionName || !returnType || !language || !body) throw new Error('createFunction missing some parameters. Did you pass functionName, returnType, language and body?');\n\n    const paramList = this.expandFunctionParamList(params);\n    const indentedBody = body.replace('\\n', '\\n\\t');\n    const expandedOptions = this.expandOptions(options);\n\n    return `CREATE FUNCTION ${functionName}(${paramList})\\n`\n      + `RETURNS ${returnType} AS $func$\\n`\n      + 'BEGIN\\n'\n      + `\\t${indentedBody}\\n`\n      + 'END;\\n'\n      + `$func$ language '${language}'${expandedOptions};`;\n  },\n\n  dropFunction(functionName, params) {\n    if (!functionName) throw new Error('requires functionName');\n    // RESTRICT is (currently, as of 9.2) default but we'll be explicit\n    const paramList = this.expandFunctionParamList(params);\n    return `DROP FUNCTION ${functionName}(${paramList}) RESTRICT;`;\n  },\n\n  renameFunction(oldFunctionName, params, newFunctionName) {\n    const paramList = this.expandFunctionParamList(params);\n    return `ALTER FUNCTION ${oldFunctionName}(${paramList}) RENAME TO ${newFunctionName};`;\n  },\n\n  databaseConnectionUri(config) {\n    let uri = config.protocol + '://' + config.user + ':' + config.password + '@' + config.host;\n    if (config.port) {\n      uri += ':' + config.port;\n    }\n    uri += '/' + config.database;\n    if (config.ssl) {\n      uri += '?ssl=' + config.ssl;\n    }\n    return uri;\n  },\n\n  pgEscapeAndQuote(val) {\n    return this.quoteIdentifier(Utils.removeTicks(this.escape(val), \"'\"));\n  },\n\n  expandFunctionParamList(params) {\n    if (Utils._.isUndefined(params) || !Utils._.isArray(params)) {\n      throw new Error('expandFunctionParamList: function parameters array required, including an empty one for no arguments');\n    }\n\n    const paramList = [];\n    Utils._.each(params, curParam => {\n      const paramDef = [];\n      if (Utils._.has(curParam, 'type')) {\n        if (Utils._.has(curParam, 'direction')) { paramDef.push(curParam.direction); }\n        if (Utils._.has(curParam, 'name')) { paramDef.push(curParam.name); }\n        paramDef.push(curParam.type);\n      } else {\n        throw new Error('function or trigger used with a parameter without any type');\n      }\n\n      const joined = paramDef.join(' ');\n      if (joined) paramList.push(joined);\n\n    });\n\n    return paramList.join(', ');\n  },\n\n  expandOptions(options) {\n    return Utils._.isUndefined(options) || Utils._.isEmpty(options) ?\n      '' : '\\n\\t' + options.join('\\n\\t');\n  },\n\n  decodeTriggerEventType(eventSpecifier) {\n    const EVENT_DECODER = {\n      'after': 'AFTER',\n      'before': 'BEFORE',\n      'instead_of': 'INSTEAD OF',\n      'after_constraint': 'AFTER'\n    };\n\n    if (!Utils._.has(EVENT_DECODER, eventSpecifier)) {\n      throw new Error('Invalid trigger event specified: ' + eventSpecifier);\n    }\n\n    return EVENT_DECODER[eventSpecifier];\n  },\n\n  triggerEventTypeIsConstraint(eventSpecifier) {\n    return eventSpecifier === 'after_constraint' ? 'CONSTRAINT ' : '';\n  },\n\n  expandTriggerEventSpec(fireOnSpec) {\n    if (Utils._.isEmpty(fireOnSpec)) {\n      throw new Error('no table change events specified to trigger on');\n    }\n\n    return Utils._.map(fireOnSpec, (fireValue, fireKey) => {\n      const EVENT_MAP = {\n        'insert': 'INSERT',\n        'update': 'UPDATE',\n        'delete': 'DELETE',\n        'truncate': 'TRUNCATE'\n      };\n\n      if (!Utils._.has(EVENT_MAP, fireKey)) {\n        throw new Error('parseTriggerEventSpec: undefined trigger event ' + fireKey);\n      }\n\n      let eventSpec = EVENT_MAP[fireKey];\n      if (eventSpec === 'UPDATE') {\n        if (Utils._.isArray(fireValue) && fireValue.length > 0) {\n          eventSpec += ' OF ' + fireValue.join(', ');\n        }\n      }\n\n      return eventSpec;\n    }).join(' OR ');\n  },\n\n  pgEnumName(tableName, attr, options) {\n    options = options || {};\n    const tableDetails = this.extractTableDetails(tableName, options);\n    let enumName = '\"enum_' + tableDetails.tableName + '_' + attr + '\"';\n\n    // pgListEnums requires the enum name only, without the schema\n    if (options.schema !== false && tableDetails.schema) {\n      enumName = this.quoteIdentifier(tableDetails.schema) + tableDetails.delimiter + enumName;\n    }\n\n    return enumName;\n\n  },\n\n  pgListEnums(tableName, attrName, options) {\n    let enumName = '';\n    const tableDetails = this.extractTableDetails(tableName, options);\n\n    if (tableDetails.tableName && attrName) {\n      enumName = ' AND t.typname=' + this.pgEnumName(tableDetails.tableName, attrName, { schema: false }).replace(/\"/g, \"'\");\n    }\n\n    return 'SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t ' +\n      'JOIN pg_enum e ON t.oid = e.enumtypid ' +\n      'JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace ' +\n      `WHERE n.nspname = '${tableDetails.schema}'${enumName} GROUP BY 1`;\n  },\n\n  pgEnum(tableName, attr, dataType, options) {\n    const enumName = this.pgEnumName(tableName, attr, options);\n    let values;\n\n    if (dataType.values) {\n      values = \"ENUM('\" + dataType.values.join(\"', '\") + \"')\";\n    } else {\n      values = dataType.toString().match(/^ENUM\\(.+\\)/)[0];\n    }\n\n    let sql = 'CREATE TYPE ' + enumName + ' AS ' + values + ';';\n    if (!!options && options.force === true) {\n      sql = this.pgEnumDrop(tableName, attr) + sql;\n    }\n    return sql;\n  },\n\n  pgEnumAdd(tableName, attr, value, options) {\n    const enumName = this.pgEnumName(tableName, attr);\n    let sql = 'ALTER TYPE ' + enumName + ' ADD VALUE ';\n\n    if (semver.gte(this.sequelize.options.databaseVersion, '9.3.0')) {\n      sql += 'IF NOT EXISTS ';\n    }\n    sql += this.escape(value);\n\n    if (options.before) {\n      sql += ' BEFORE ' + this.escape(options.before);\n    } else if (options.after) {\n      sql += ' AFTER ' + this.escape(options.after);\n    }\n\n    return sql;\n  },\n\n  pgEnumDrop(tableName, attr, enumName) {\n    enumName = enumName || this.pgEnumName(tableName, attr);\n    return 'DROP TYPE IF EXISTS ' + enumName + '; ';\n  },\n\n  fromArray(text) {\n    text = text.replace(/^{/, '').replace(/}$/, '');\n    let matches = text.match(/(\"(?:\\\\.|[^\"\\\\\\\\])*\"|[^,]*)(?:\\s*,\\s*|\\s*$)/ig);\n\n    if (matches.length < 1) {\n      return [];\n    }\n\n    matches = matches.map(m => m.replace(/\",$/, '').replace(/,$/, '').replace(/(^\"|\"$)/, ''));\n\n    return matches.slice(0, -1);\n  },\n\n  padInt(i) {\n    return i < 10 ? '0' + i.toString() : i.toString();\n  },\n\n  dataTypeMapping(tableName, attr, dataType) {\n    if (Utils._.includes(dataType, 'PRIMARY KEY')) {\n      dataType = dataType.replace(/PRIMARY KEY/, '');\n    }\n\n    if (Utils._.includes(dataType, 'SERIAL')) {\n      if (Utils._.includes(dataType, 'BIGINT')) {\n        dataType = dataType.replace(/SERIAL/, 'BIGSERIAL');\n        dataType = dataType.replace(/BIGINT/, '');\n      } else {\n        dataType = dataType.replace(/INTEGER/, '');\n      }\n      dataType = dataType.replace(/NOT NULL/, '');\n    }\n\n    if (dataType.match(/^ENUM\\(/)) {\n      dataType = dataType.replace(/^ENUM\\(.+\\)/, this.pgEnumName(tableName, attr));\n    }\n\n    return dataType;\n  },\n\n  quoteIdentifier(identifier, force) {\n    if (identifier === '*') return identifier;\n    if (!force && this.options && this.options.quoteIdentifiers === false && identifier.indexOf('.') === -1 && identifier.indexOf('->') === -1) { // default is `true`\n      // In Postgres, if tables or attributes are created double-quoted,\n      // they are also case sensitive. If they contain any uppercase\n      // characters, they must always be double-quoted. This makes it\n      // impossible to write queries in portable SQL if tables are created in\n      // this way. Hence, we strip quotes if we don't want case sensitivity.\n      return Utils.removeTicks(identifier, '\"');\n    } else {\n      return Utils.addTicks(Utils.removeTicks(identifier, '\"'), '\"');\n    }\n  },\n\n  /**\n   * Generates an SQL query that returns all foreign keys of a table.\n   *\n   * @param  {String} tableName  The name of the table.\n   * @return {String}            The generated sql query.\n   * @private\n   */\n  getForeignKeysQuery(tableName) {\n    return 'SELECT conname as constraint_name, pg_catalog.pg_get_constraintdef(r.oid, true) as condef FROM pg_catalog.pg_constraint r ' +\n      `WHERE r.conrelid = (SELECT oid FROM pg_class WHERE relname = '${tableName}' LIMIT 1) AND r.contype = 'f' ORDER BY 1;`;\n  },\n\n  /**\n   * Generates an SQL query that removes a foreign key from a table.\n   *\n   * @param  {String} tableName  The name of the table.\n   * @param  {String} foreignKey The name of the foreign key constraint.\n   * @return {String}            The generated sql query.\n   * @private\n   */\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return 'ALTER TABLE ' + this.quoteTable(tableName) + ' DROP CONSTRAINT ' + this.quoteIdentifier(foreignKey) + ';';\n  },\n\n  setAutocommitQuery(value, options) {\n    if (options.parent) {\n      return;\n    }\n\n    // POSTGRES does not support setting AUTOCOMMIT = OFF as of 9.4.0\n    // Additionally it does not support AUTOCOMMIT at all starting at v9.5\n    // The assumption is that it won't be returning in future versions either\n    // If you are on a Pg version that is not semver compliant e.g. '9.5.0beta2', which fails due to the 'beta' qualification, then you need to pass\n    // the database version as \"9.5.0\" explicitly through the options param passed when creating the Sequelize instance under the key \"databaseVersion\"\n    // otherwise Pg version \"9.4.0\" is assumed by default as per Sequelize 3.14.2.\n    // For Pg versions that are semver compliant, this is auto-detected upon the first connection.\n    if (!value || semver.gte(this.sequelize.options.databaseVersion, '9.4.0')) {\n      return;\n    }\n\n    return AbstractQueryGenerator.setAutocommitQuery.call(this, value, options);\n  }\n};\n\nmodule.exports = QueryGenerator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/dialects/postgres/query-generator.js\n// module id = 99\n// module chunks = 0","'use strict';\n\nconst _ = require('lodash');\nconst AbstractDialect = require('../abstract');\nconst ConnectionManager = require('./connection-manager');\nconst Query = require('./query');\nconst QueryGenerator = require('./query-generator');\nconst DataTypes = require('../../data-types').sqlite;\n\nclass SqliteDialect extends AbstractDialect {\n  constructor(sequelize) {\n    super();\n    this.sequelize = sequelize;\n    this.connectionManager = new ConnectionManager(this, sequelize);\n    this.QueryGenerator = _.extend({}, QueryGenerator, {\n      options: sequelize.options,\n      _dialect: this,\n      sequelize\n    });\n  }\n}\n\nSqliteDialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {\n  'DEFAULT': false,\n  'DEFAULT VALUES': true,\n  'UNION ALL': false,\n  'IGNORE': ' OR IGNORE',\n  index: {\n    using: false\n  },\n  transactionOptions: {\n    type: true,\n    autocommit: false\n  },\n  constraints: {\n    addConstraint: false,\n    dropConstraint: false\n  },\n  joinTableDependent: false,\n  groupedLimit: false,\n  ignoreDuplicates: ' OR IGNORE',\n  JSON: true\n});\n\nConnectionManager.prototype.defaultVersion = '3.8.0';\nSqliteDialect.prototype.Query = Query;\nSqliteDialect.prototype.DataTypes = DataTypes;\nSqliteDialect.prototype.name = 'sqlite';\nSqliteDialect.prototype.TICK_CHAR = '`';\nSqliteDialect.prototype.TICK_CHAR_LEFT = SqliteDialect.prototype.TICK_CHAR;\nSqliteDialect.prototype.TICK_CHAR_RIGHT = SqliteDialect.prototype.TICK_CHAR;\n\nmodule.exports = SqliteDialect;\nmodule.exports.SqliteDialect = SqliteDialect;\nmodule.exports.default = SqliteDialect;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/dialects/sqlite/index.js\n// module id = 100\n// module chunks = 0","'use strict';\n\nconst AbstractConnectionManager = require('../abstract/connection-manager');\nconst Promise = require('../../promise');\nconst Utils = require('../../utils');\nconst debug = Utils.getLogger().debugContext('connection:sqlite');\nconst dataTypes = require('../../data-types').sqlite;\nconst sequelizeErrors = require('../../errors');\nconst parserStore = require('../parserStore')('sqlite');\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    super(dialect, sequelize);\n    this.sequelize = sequelize;\n    this.config = sequelize.config;\n    this.dialect = dialect;\n    this.dialectName = this.sequelize.options.dialect;\n    this.connections = {};\n\n    // We attempt to parse file location from a connection uri but we shouldn't match sequelize default host.\n    if (this.sequelize.options.host === 'localhost') delete this.sequelize.options.host;\n\n    try {\n      if (sequelize.config.dialectModulePath) {\n        this.lib = require(sequelize.config.dialectModulePath).verbose();\n      } else {\n        this.lib = require('sqlite3').verbose();\n      }\n    } catch (err) {\n      if (err.code === 'MODULE_NOT_FOUND') {\n        throw new Error('Please install sqlite3 package manually');\n      }\n      throw err;\n    }\n\n    this.refreshTypeParser(dataTypes);\n  }\n\n  // Expose this as a method so that the parsing may be updated when the user has added additional, custom types\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  getConnection(options) {\n    options = options || {};\n    options.uuid = options.uuid || 'default';\n    options.inMemory = (this.sequelize.options.storage || this.sequelize.options.host || ':memory:') === ':memory:' ? 1 : 0;\n\n    const dialectOptions = this.sequelize.options.dialectOptions;\n    options.readWriteMode = dialectOptions && dialectOptions.mode;\n\n    if (this.connections[options.inMemory || options.uuid]) {\n      return Promise.resolve(this.connections[options.inMemory || options.uuid]);\n    }\n\n    return new Promise((resolve, reject) => {\n      this.connections[options.inMemory || options.uuid] = new this.lib.Database(\n        this.sequelize.options.storage || this.sequelize.options.host || ':memory:',\n        options.readWriteMode || this.lib.OPEN_READWRITE | this.lib.OPEN_CREATE, // default mode\n        err => {\n          if (err) {\n            if (err.code === 'SQLITE_CANTOPEN') return reject(new sequelizeErrors.ConnectionError(err));\n            return reject(new sequelizeErrors.ConnectionError(err));\n          }\n          debug(`connection acquired ${options.uuid}`);\n          resolve(this.connections[options.inMemory || options.uuid]);\n        }\n      );\n    }).tap(connection => {\n      if (this.sequelize.config.password) {\n        // Make it possible to define and use password for sqlite encryption plugin like sqlcipher\n        connection.run('PRAGMA KEY=' + this.sequelize.escape(this.sequelize.config.password));\n      }\n      if (this.sequelize.options.foreignKeys !== false) {\n        // Make it possible to define and use foreign key constraints unless\n        // explicitly disallowed. It's still opt-in per relation\n        connection.run('PRAGMA FOREIGN_KEYS=ON');\n      }\n    });\n  }\n\n  releaseConnection(connection, force) {\n    if (connection.filename === ':memory:' && force !== true) return;\n\n    if (connection.uuid) {\n      connection.close();\n      debug(`connection released ${connection.uuid}`);\n      delete this.connections[connection.uuid];\n    }\n  }\n}\n\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/dialects/sqlite/connection-manager.js\n// module id = 101\n// module chunks = 0","function webpackEmptyContext(req) {\n\tthrow new Error(\"Cannot find module '\" + req + \"'.\");\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 102;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/dialects/sqlite\n// module id = 102\n// module chunks = 0","module.exports = require(\"sqlite3\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"sqlite3\"\n// module id = 103\n// module chunks = 0","'use strict';\n\nconst _ = require('lodash');\nconst Utils = require('../../utils');\nconst debug = Utils.getLogger().debugContext('sql:sqlite');\nconst Promise = require('../../promise');\nconst AbstractQuery = require('../abstract/query');\nconst QueryTypes = require('../../query-types');\nconst sequelizeErrors = require('../../errors.js');\nconst parserStore = require('../parserStore')('sqlite');\n\nclass Query extends AbstractQuery {\n\n  constructor(database, sequelize, options) {\n    super();\n    this.database = database;\n    this.sequelize = sequelize;\n    this.instance = options.instance;\n    this.model = options.model;\n    this.options = _.extend({\n      logging: console.log,\n      plain: false,\n      raw: false\n    }, options || {});\n\n    this.checkLoggingOption();\n  }\n\n  getInsertIdField() {\n    return 'lastID';\n  }\n\n  /**\n   * rewrite query with parameters\n   * @private\n   */\n  static formatBindParameters(sql, values, dialect) {\n    let bindParam;\n    if (Array.isArray(values)) {\n      bindParam = {};\n      values.forEach((v, i) => {\n        bindParam['$'+(i+1)] = v;\n      });\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, { skipValueReplace: true })[0];\n    } else {\n      bindParam = {};\n      if (typeof values === 'object') {\n        for (const k of Object.keys(values)) {\n          bindParam['$'+k] = values[k];\n        }\n      }\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, { skipValueReplace: true })[0];\n    }\n    return [sql, bindParam];\n  }\n\n  _collectModels(include, prefix) {\n    const ret = {};\n\n    if (include) {\n      for (const _include of include) {\n        let key;\n        if (!prefix) {\n          key = _include.as;\n        } else {\n          key = prefix + '.' + _include.as;\n        }\n        ret[key] = _include.model;\n\n        if (_include.include) {\n          _.merge(ret, this._collectModels(_include.include, key));\n        }\n      }\n    }\n\n    return ret;\n  }\n\n  run(sql, parameters) {\n    this.sql = sql;\n    const method = this.getDatabaseMethod();\n    if (method === 'exec') {\n      // exec does not support bind parameter\n      sql = AbstractQuery.formatBindParameters(sql, this.options.bind, this.options.dialect, { skipUnescape: true })[0];\n      this.sql = sql;\n    }\n\n    //do we need benchmark for this query execution\n    const benchmark = this.sequelize.options.benchmark || this.options.benchmark;\n\n    let queryBegin;\n    if (benchmark) {\n      queryBegin = Date.now();\n    } else {\n      this.sequelize.log('Executing (' + (this.database.uuid || 'default') + '): ' + this.sql, this.options);\n    }\n\n    debug(`executing(${this.database.uuid || 'default'}) : ${this.sql}`);\n\n    return new Promise(resolve => {\n      const columnTypes = {};\n      this.database.serialize(() => {\n        const executeSql = () => {\n          if (this.sql.indexOf('-- ') === 0) {\n            return resolve();\n          } else {\n            resolve(new Promise((resolve, reject) => {\n              const query = this;\n              // cannot use arrow function here because the function is bound to the statement\n              function afterExecute(err, results) {\n                debug(`executed(${query.database.uuid || 'default'}) : ${query.sql}`);\n\n                if (benchmark) {\n                  query.sequelize.log('Executed (' + (query.database.uuid || 'default') + '): ' + query.sql, Date.now() - queryBegin, query.options);\n                }\n\n                if (err) {\n                  err.sql = query.sql;\n                  reject(query.formatError(err));\n                } else {\n                  const metaData = this;\n                  let result = query.instance;\n\n                  // add the inserted row id to the instance\n                  if (query.isInsertQuery(results, metaData)) {\n                    query.handleInsertQuery(results, metaData);\n                    if (!query.instance) {\n                      // handle bulkCreate AI primary key\n                      if (\n                        metaData.constructor.name === 'Statement'\n                        && query.model\n                        && query.model.autoIncrementAttribute\n                        && query.model.autoIncrementAttribute === query.model.primaryKeyAttribute\n                        && query.model.rawAttributes[query.model.primaryKeyAttribute]\n                      ) {\n                        const startId = metaData[query.getInsertIdField()] - metaData.changes + 1;\n                        result = [];\n                        for (let i = startId; i < startId + metaData.changes; i++) {\n                          result.push({ [query.model.rawAttributes[query.model.primaryKeyAttribute].field]: i });\n                        }\n                      } else {\n                        result = metaData[query.getInsertIdField()];\n                      }\n                    }\n                  }\n\n                  if (query.sql.indexOf('sqlite_master') !== -1) {\n                    if (query.sql.indexOf('SELECT sql FROM sqlite_master WHERE tbl_name') !== -1) {\n                      result = results;\n                      if (result && result[0] && result[0].sql.indexOf('CONSTRAINT') !== -1) {\n                        result = query.parseConstraintsFromSql(results[0].sql);\n                      }\n                    } else {\n                      result = results.map(resultSet => resultSet.name);\n                    }\n                  } else if (query.isSelectQuery()) {\n                    if (!query.options.raw) {\n                      // This is a map of prefix strings to models, e.g. user.projects -> Project model\n                      const prefixes = query._collectModels(query.options.include);\n\n                      results = results.map(result => {\n                        return _.mapValues(result, (value, name) => {\n                          let model;\n                          if (name.indexOf('.') !== -1) {\n                            const lastind = name.lastIndexOf('.');\n\n                            model = prefixes[name.substr(0, lastind)];\n\n                            name = name.substr(lastind + 1);\n                          } else {\n                            model = query.options.model;\n                          }\n\n                          const tableName = model.getTableName().toString().replace(/`/g, '');\n                          const tableTypes = columnTypes[tableName] || {};\n\n                          if (tableTypes && !(name in tableTypes)) {\n                            // The column is aliased\n                            _.forOwn(model.rawAttributes, (attribute, key) => {\n                              if (name === key && attribute.field) {\n                                name = attribute.field;\n                                return false;\n                              }\n                            });\n                          }\n\n                          return tableTypes[name]\n                            ? query.applyParsers(tableTypes[name], value)\n                            : value;\n                        });\n                      });\n                    }\n\n                    result = query.handleSelectQuery(results);\n                  } else if (query.isShowOrDescribeQuery()) {\n                    result = results;\n                  } else if (query.sql.indexOf('PRAGMA INDEX_LIST') !== -1) {\n                    result = query.handleShowIndexesQuery(results);\n                  } else if (query.sql.indexOf('PRAGMA INDEX_INFO') !== -1) {\n                    result = results;\n                  } else if (query.sql.indexOf('PRAGMA TABLE_INFO') !== -1) {\n                    // this is the sqlite way of getting the metadata of a table\n                    result = {};\n\n                    let defaultValue;\n                    for (const _result of results) {\n                      if (_result.dflt_value === null) {\n                        // Column schema omits any \"DEFAULT ...\"\n                        defaultValue = undefined;\n                      } else if (_result.dflt_value === 'NULL') {\n                        // Column schema is a \"DEFAULT NULL\"\n                        defaultValue = null;\n                      } else {\n                        defaultValue = _result.dflt_value;\n                      }\n\n                      result[_result.name] = {\n                        type: _result.type,\n                        allowNull: _result.notnull === 0,\n                        defaultValue,\n                        primaryKey: _result.pk !== 0\n                      };\n\n                      if (result[_result.name].type === 'TINYINT(1)') {\n                        result[_result.name].defaultValue = { '0': false, '1': true }[result[_result.name].defaultValue];\n                      }\n\n                      if (typeof result[_result.name].defaultValue === 'string') {\n                        result[_result.name].defaultValue = result[_result.name].defaultValue.replace(/'/g, '');\n                      }\n                    }\n                  } else if (query.sql.indexOf('PRAGMA foreign_keys;') !== -1) {\n                    result = results[0];\n                  } else if (query.sql.indexOf('PRAGMA foreign_keys') !== -1) {\n                    result = results;\n                  } else if (query.sql.indexOf('PRAGMA foreign_key_list') !== -1) {\n                    result = results;\n                  } else if ([QueryTypes.BULKUPDATE, QueryTypes.BULKDELETE].indexOf(query.options.type) !== -1) {\n                    result = metaData.changes;\n                  } else if (query.options.type === QueryTypes.UPSERT) {\n                    result = undefined;\n                  } else if (query.options.type === QueryTypes.VERSION) {\n                    result = results[0].version;\n                  } else if (query.options.type === QueryTypes.RAW) {\n                    result = [results, metaData];\n                  } else if (query.isUpdateQuery() || query.isInsertQuery()) {\n                    result = [result, metaData.changes];\n                  }\n\n                  resolve(result);\n                }\n              }\n\n              if (method === 'exec') {\n                // exec does not support bind parameter\n                this.database[method](this.sql, afterExecute);\n              } else {\n                if (!parameters) parameters = [];\n                this.database[method](this.sql, parameters, afterExecute);\n              }\n            }));\n            return null;\n          }\n        };\n\n        if (this.getDatabaseMethod() === 'all') {\n          let tableNames = [];\n          if (this.options && this.options.tableNames) {\n            tableNames = this.options.tableNames;\n          } else if (/FROM `(.*?)`/i.exec(this.sql)) {\n            tableNames.push(/FROM `(.*?)`/i.exec(this.sql)[1]);\n          }\n\n          // If we already have the metadata for the table, there's no need to ask for it again\n          tableNames = _.filter(tableNames, tableName => !(tableName in columnTypes) && tableName !== 'sqlite_master');\n\n          if (!tableNames.length) {\n            return executeSql();\n          } else {\n            return Promise.map(tableNames, tableName =>\n              new Promise(resolve => {\n                tableName = tableName.replace(/`/g, '');\n                columnTypes[tableName] = {};\n\n                this.database.all('PRAGMA table_info(`' + tableName + '`)', (err, results) => {\n                  if (!err) {\n                    for (const result of results) {\n                      columnTypes[tableName][result.name] = result.type;\n                    }\n                  }\n                  resolve();\n                });\n              })\n            ).then(executeSql);\n          }\n        } else {\n          return executeSql();\n        }\n      });\n    });\n  }\n\n  parseConstraintsFromSql(sql) {\n    let constraints = sql.split('CONSTRAINT ');\n    let referenceTableName, referenceTableKeys, updateAction, deleteAction;\n    constraints.splice(0, 1);\n    constraints = constraints.map(constraintSql => {\n      //Parse foreign key snippets\n      if (constraintSql.indexOf('REFERENCES') !== -1) {\n        //Parse out the constraint condition form sql string\n        updateAction = constraintSql.match(/ON UPDATE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);\n        deleteAction = constraintSql.match(/ON DELETE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);\n\n        if (updateAction) {\n          updateAction = updateAction[1];\n        }\n\n        if (deleteAction) {\n          deleteAction = deleteAction[1];\n        }\n\n        const referencesRegex = /REFERENCES.+\\((?:[^)(]+|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\)/;\n        const referenceConditions = constraintSql.match(referencesRegex)[0].split(' ');\n        referenceTableName = Utils.removeTicks(referenceConditions[1]);\n        let columnNames = referenceConditions[2];\n        columnNames = columnNames.replace(/\\(|\\)/g, '').split(', ');\n        referenceTableKeys = columnNames.map(column => Utils.removeTicks(column));\n      }\n\n      const constraintCondition = constraintSql.match(/\\((?:[^)(]+|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\)/)[0];\n      constraintSql = constraintSql.replace(/\\(.+\\)/, '');\n      const constraint = constraintSql.split(' ');\n\n      if (constraint[1] === 'PRIMARY' || constraint[1] === 'FOREIGN') {\n        constraint[1]+= ' KEY';\n      }\n\n      return {\n        constraintName: Utils.removeTicks(constraint[0]),\n        constraintType: constraint[1],\n        updateAction,\n        deleteAction,\n        sql: sql.replace(/\\\"/g, '\\`'), //Sqlite returns double quotes for table name\n        constraintCondition,\n        referenceTableName,\n        referenceTableKeys\n      };\n    });\n\n    return constraints;\n  }\n\n  applyParsers(type, value) {\n    if (type.indexOf('(') !== -1) {\n      // Remove the length part\n      type = type.substr(0, type.indexOf('('));\n    }\n    type = type.replace('UNSIGNED', '').replace('ZEROFILL', '');\n    type = type.trim().toUpperCase();\n    const parse = parserStore.get(type);\n\n    if (value !== null && parse) {\n      return parse(value, { timezone: this.sequelize.options.timezone });\n    }\n    return value;\n  }\n\n  formatError(err) {\n\n    switch (err.code) {\n      case 'SQLITE_CONSTRAINT': {\n        let match = err.message.match(/FOREIGN KEY constraint failed/);\n        if (match !== null) {\n          return new sequelizeErrors.ForeignKeyConstraintError({\n            parent :err\n          });\n        }\n\n        let fields = [];\n\n        // Sqlite pre 2.2 behavior - Error: SQLITE_CONSTRAINT: columns x, y are not unique\n        match = err.message.match(/columns (.*?) are/);\n        if (match !== null && match.length >= 2) {\n          fields = match[1].split(', ');\n        } else {\n\n          // Sqlite post 2.2 behavior - Error: SQLITE_CONSTRAINT: UNIQUE constraint failed: table.x, table.y\n          match = err.message.match(/UNIQUE constraint failed: (.*)/);\n          if (match !== null && match.length >= 2) {\n            fields = match[1].split(', ').map(columnWithTable => columnWithTable.split('.')[1]);\n          }\n        }\n\n        const errors = [];\n        let message = 'Validation error';\n\n        for (const field of fields) {\n          errors.push(new sequelizeErrors.ValidationErrorItem(\n            this.getUniqueConstraintErrorMessage(field),\n            'unique violation', field, this.instance && this.instance[field]));\n        }\n\n        if (this.model) {\n          _.forOwn(this.model.uniqueKeys, constraint => {\n            if (_.isEqual(constraint.fields, fields) && !!constraint.msg) {\n              message = constraint.msg;\n              return false;\n            }\n          });\n        }\n\n        return new sequelizeErrors.UniqueConstraintError({message, errors, parent: err, fields});\n      }\n      case 'SQLITE_BUSY':\n        return new sequelizeErrors.TimeoutError(err);\n\n      default:\n        return new sequelizeErrors.DatabaseError(err);\n    }\n  }\n\n  handleShowIndexesQuery(data) {\n\n    // Sqlite returns indexes so the one that was defined last is returned first. Lets reverse that!\n    return this.sequelize.Promise.map(data.reverse(), item => {\n      item.fields = [];\n      item.primary = false;\n      item.unique = !!item.unique;\n      item.constraintName = item.name;\n      return this.run('PRAGMA INDEX_INFO(`' + item.name + '`)').then(columns => {\n        for (const column of columns) {\n          item.fields[column.seqno] = {\n            attribute: column.name,\n            length: undefined,\n            order: undefined\n          };\n        }\n\n        return item;\n      });\n    });\n  }\n\n  getDatabaseMethod() {\n    if (this.isUpsertQuery()) {\n      return 'exec'; // Needed to run multiple queries in one\n    } else if (this.isInsertQuery() || this.isUpdateQuery() || this.isBulkUpdateQuery() || this.sql.toLowerCase().indexOf('CREATE TEMPORARY TABLE'.toLowerCase()) !== -1 || this.options.type === QueryTypes.BULKDELETE) {\n      return 'run';\n    } else {\n      return 'all';\n    }\n  }\n}\n\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports.default = Query;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/dialects/sqlite/query.js\n// module id = 104\n// module chunks = 0","'use strict';\n\nconst Utils = require('../../utils');\nconst util = require('util');\nconst Transaction = require('../../transaction');\nconst _ = require('lodash');\nconst MySqlQueryGenerator = require('../mysql/query-generator');\nconst AbstractQueryGenerator = require('../abstract/query-generator');\n\nconst QueryGenerator = {\n  __proto__: MySqlQueryGenerator,\n  options: {},\n  dialect: 'sqlite',\n\n  createSchema() {\n    return \"SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';\";\n  },\n\n  showSchemasQuery() {\n    return \"SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';\";\n  },\n\n  versionQuery() {\n    return 'SELECT sqlite_version() as `version`';\n  },\n\n  createTableQuery(tableName, attributes, options) {\n    options = options || {};\n\n    const primaryKeys = [];\n    const needsMultiplePrimaryKeys = Utils._.values(attributes).filter(definition => _.includes(definition, 'PRIMARY KEY')).length > 1;\n    const attrArray = [];\n\n    for (const attr in attributes) {\n      if (attributes.hasOwnProperty(attr)) {\n        let dataType = attributes[attr];\n        const containsAutoIncrement = Utils._.includes(dataType, 'AUTOINCREMENT');\n\n        if (containsAutoIncrement) {\n          dataType = dataType.replace(/BIGINT/, 'INTEGER');\n        }\n\n        let dataTypeString = dataType;\n        if (Utils._.includes(dataType, 'PRIMARY KEY')) {\n          if (Utils._.includes(dataType, 'INTEGER')) { // Only INTEGER is allowed for primary key, see https://github.com/sequelize/sequelize/issues/969 (no lenght, unsigned etc)\n            dataTypeString = containsAutoIncrement ? 'INTEGER PRIMARY KEY AUTOINCREMENT' : 'INTEGER PRIMARY KEY';\n          }\n\n          if (needsMultiplePrimaryKeys) {\n            primaryKeys.push(attr);\n            dataTypeString = dataType.replace(/PRIMARY KEY/, 'NOT NULL');\n          }\n        }\n        attrArray.push(this.quoteIdentifier(attr) + ' ' + dataTypeString);\n      }\n    }\n\n    const table = this.quoteTable(tableName);\n    let attrStr = attrArray.join(', ');\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\n\n    if (options.uniqueKeys) {\n      Utils._.each(options.uniqueKeys, columns => {\n        if (!columns.singleField) { // If it's a single field its handled in column def, not as an index\n          attrStr += ', UNIQUE (' + columns.fields.map(field => this.quoteIdentifier(field)).join(', ') + ')';\n        }\n      });\n    }\n\n    if (pkString.length > 0) {\n      attrStr += ', PRIMARY KEY (' + pkString + ')';\n    }\n\n    const sql = `CREATE TABLE IF NOT EXISTS ${table} (${attrStr});`;\n    return this.replaceBooleanDefaults(sql);\n  },\n\n  booleanValue(value) {\n    return value ? 1 : 0;\n  },\n\n  /**\n   * Check whether the statmement is json function or simple path\n   *\n   * @param   {String}  stmt  The statement to validate\n   * @returns {Boolean}       true if the given statement is json function\n   * @throws  {Error}         throw if the statement looks like json function but has invalid token\n   */\n  checkValidJsonStatement(stmt) {\n    if (!_.isString(stmt)) {\n      return false;\n    }\n\n    // https://sqlite.org/json1.html\n    const jsonFunctionRegex = /^\\s*(json(?:_[a-z]+){0,2})\\([^)]*\\)/i;\n    const tokenCaptureRegex = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\n\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = jsonFunctionRegex.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf('(');\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const tokenMatches = tokenCaptureRegex.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === '(') {\n          openingBrackets++;\n        } else if (capturedToken === ')') {\n          closingBrackets++;\n        } else if (capturedToken === ';') {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n\n      break;\n    }\n\n    // Check invalid json statement\n    hasInvalidToken |= openingBrackets !== closingBrackets;\n    if (hasJsonFunction && hasInvalidToken) {\n      throw new Error('Invalid json statement: ' + stmt);\n    }\n\n    // return true if the statement has valid json function\n    return hasJsonFunction;\n  },\n\n  /**\n   * Generates an SQL query that extract JSON property of given path.\n   *\n   * @param   {String}               column  The JSON column\n   * @param   {String|Array<String>} [path]  The path to extract (optional)\n   * @returns {String}                       The generated sql query\n   * @private\n   */\n  jsonPathExtractionQuery(column, path) {\n    const paths = _.toPath(path);\n    const pathStr = this.escape(['$']\n      .concat(paths)\n      .join('.')\n      .replace(/\\.(\\d+)(?:(?=\\.)|$)/g, (_, digit) => `[${digit}]`));\n\n    const quotedColumn = this.isIdentifierQuoted(column) ? column : this.quoteIdentifier(column);\n    return `json_extract(${quotedColumn}, ${pathStr})`;\n  },\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Utils.Json) {\n      // Parse nested object\n      if (smth.conditions) {\n        const conditions = this.parseConditionObject(smth.conditions).map(condition =>\n          `${this.jsonPathExtractionQuery(_.first(condition.path), _.tail(condition.path))} = '${condition.value}'`\n        );\n\n        return conditions.join(' AND ');\n      } else if (smth.path) {\n        let str;\n\n        // Allow specifying conditions using the sqlite json functions\n        if (this.checkValidJsonStatement(smth.path)) {\n          str = smth.path;\n        } else {\n          // Also support json property accessors\n          const paths = _.toPath(smth.path);\n          const column = paths.shift();\n          str = this.jsonPathExtractionQuery(column, paths);\n        }\n\n        if (smth.value) {\n          str += util.format(' = %s', this.escape(smth.value));\n        }\n\n        return str;\n      }\n    } else if (smth instanceof Utils.Cast) {\n      if (/timestamp/i.test(smth.type)) {\n        smth.type = 'datetime';\n      }\n    }\n    return AbstractQueryGenerator.handleSequelizeMethod.call(this, smth, tableName, factory, options, prepend);\n  },\n\n  addColumnQuery(table, key, dataType) {\n    const attributes = {};\n    attributes[key] = dataType;\n    const fields = this.attributesToSQL(attributes, { context: 'addColumn' });\n    const attribute = this.quoteIdentifier(key) + ' ' + fields[key];\n\n    const sql = `ALTER TABLE ${this.quoteTable(table)} ADD ${attribute};`;\n\n    return this.replaceBooleanDefaults(sql);\n  },\n\n  showTablesQuery() {\n    return \"SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';\";\n  },\n\n  upsertQuery(tableName, insertValues, updateValues, where, model, options) {\n    options.ignoreDuplicates = true;\n\n    const sql = this.insertQuery(tableName, insertValues, model.rawAttributes, options) + ' ' + this.updateQuery(tableName, updateValues, where, options, model.rawAttributes);\n\n    return sql;\n  },\n\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    options = options || {};\n    _.defaults(options, this.options);\n\n    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);\n\n    const modelAttributeMap = {};\n    const values = [];\n\n    if (attributes) {\n      _.each(attributes, (attribute, key) => {\n        modelAttributeMap[key] = attribute;\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n\n    for (const key in attrValueHash) {\n      const value = attrValueHash[key];\n      values.push(this.quoteIdentifier(key) + '=' + this.escape(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'UPDATE' }));\n    }\n\n    return `UPDATE ${this.quoteTable(tableName)} SET ${values.join(',')} ${this.whereQuery(where, options)}`;\n  },\n\n  deleteQuery(tableName, where, options, model) {\n    options = options || {};\n    _.defaults(options, this.options);\n\n    let whereClause = this.getWhereConditions(where, null, model, options);\n    if (whereClause) {\n      whereClause = ' WHERE ' + whereClause;\n    }\n\n    return `DELETE FROM ${this.quoteTable(tableName)}${whereClause}`;\n  },\n\n  attributesToSQL(attributes) {\n    const result = {};\n\n    for (const name in attributes) {\n      const dataType = attributes[name];\n      const fieldName = dataType.field || name;\n\n      if (Utils._.isObject(dataType)) {\n        let sql = dataType.type.toString();\n\n        if (dataType.hasOwnProperty('allowNull') && !dataType.allowNull) {\n          sql += ' NOT NULL';\n        }\n\n        if (Utils.defaultValueSchemable(dataType.defaultValue)) {\n          // TODO thoroughly check that DataTypes.NOW will properly\n          // get populated on all databases as DEFAULT value\n          // i.e. mysql requires: DEFAULT CURRENT_TIMESTAMP\n          sql += ' DEFAULT ' + this.escape(dataType.defaultValue, dataType);\n        }\n\n        if (dataType.unique === true) {\n          sql += ' UNIQUE';\n        }\n\n        if (dataType.primaryKey) {\n          sql += ' PRIMARY KEY';\n\n          if (dataType.autoIncrement) {\n            sql += ' AUTOINCREMENT';\n          }\n        }\n\n        if (dataType.references) {\n          const referencesTable = this.quoteTable(dataType.references.model);\n\n          let referencesKey;\n          if (dataType.references.key) {\n            referencesKey = this.quoteIdentifier(dataType.references.key);\n          } else {\n            referencesKey = this.quoteIdentifier('id');\n          }\n\n          sql += ` REFERENCES ${referencesTable} (${referencesKey})`;\n\n          if (dataType.onDelete) {\n            sql += ' ON DELETE ' + dataType.onDelete.toUpperCase();\n          }\n\n          if (dataType.onUpdate) {\n            sql += ' ON UPDATE ' + dataType.onUpdate.toUpperCase();\n          }\n\n        }\n\n        result[fieldName] = sql;\n      } else {\n        result[fieldName] = dataType;\n      }\n    }\n\n    return result;\n  },\n\n  showIndexesQuery(tableName) {\n    return `PRAGMA INDEX_LIST(${this.quoteTable(tableName)})`;\n  },\n\n  showConstraintsQuery(tableName, constraintName) {\n    let sql =  `SELECT sql FROM sqlite_master WHERE tbl_name='${tableName}'`;\n\n    if (constraintName) {\n      sql += ` AND sql LIKE '%${constraintName}%'`;\n    }\n\n    return sql + ';';\n  },\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(tableName + '_' + indexNameOrAttributes.join('_'));\n    }\n\n    return `DROP INDEX IF EXISTS ${this.quoteIdentifier(indexName)}`;\n  },\n\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = {\n      _schema: schema,\n      _schemaDelimiter: schemaDelimiter,\n      tableName\n    };\n    return `PRAGMA TABLE_INFO(${this.quoteTable(this.addSchema(table))});`;\n  },\n\n  describeCreateTableQuery(tableName) {\n    return `SELECT sql FROM sqlite_master WHERE tbl_name='${tableName}';`;\n  },\n\n  removeColumnQuery(tableName, attributes) {\n\n    attributes = this.attributesToSQL(attributes);\n\n    let backupTableName;\n    if (typeof tableName === 'object') {\n      backupTableName = {\n        tableName: tableName.tableName + '_backup',\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = tableName + '_backup';\n    }\n\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNames = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');\n\n    return this.createTableQuery(backupTableName, attributes).replace('CREATE TABLE', 'CREATE TEMPORARY TABLE')\n      + `INSERT INTO ${quotedBackupTableName} SELECT ${attributeNames} FROM ${quotedTableName};`\n      + `DROP TABLE ${quotedTableName};`\n      + this.createTableQuery(tableName, attributes)\n      + `INSERT INTO ${quotedTableName} SELECT ${attributeNames} FROM ${quotedBackupTableName};`\n      + `DROP TABLE ${quotedBackupTableName};`;\n  },\n\n  _alterConstraintQuery(tableName, attributes, createTableSql) {\n    let backupTableName;\n\n    attributes = this.attributesToSQL(attributes);\n\n    if (typeof tableName === 'object') {\n      backupTableName = {\n        tableName: tableName.tableName + '_backup',\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = tableName + '_backup';\n    }\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNames = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');\n\n    return createTableSql.replace(`CREATE TABLE ${quotedTableName}`, `CREATE TABLE ${quotedBackupTableName}`)\n      + `INSERT INTO ${quotedBackupTableName} SELECT ${attributeNames} FROM ${quotedTableName};`\n      + `DROP TABLE ${quotedTableName};`\n      + `ALTER TABLE ${quotedBackupTableName} RENAME TO ${quotedTableName};`;\n  },\n\n  renameColumnQuery(tableName, attrNameBefore, attrNameAfter, attributes) {\n\n    let backupTableName;\n\n    attributes = this.attributesToSQL(attributes);\n\n    if (typeof tableName === 'object') {\n      backupTableName = {\n        tableName: tableName.tableName + '_backup',\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = tableName + '_backup';\n    }\n\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNamesImport = Object.keys(attributes).map(attr =>\n      attrNameAfter === attr ? this.quoteIdentifier(attrNameBefore) + ' AS ' + this.quoteIdentifier(attr) : this.quoteIdentifier(attr)\n    ).join(', ');\n    const attributeNamesExport = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');\n\n    return this.createTableQuery(backupTableName, attributes).replace('CREATE TABLE', 'CREATE TEMPORARY TABLE')\n      + `INSERT INTO ${quotedBackupTableName} SELECT ${attributeNamesImport} FROM ${quotedTableName};`\n      + `DROP TABLE ${quotedTableName};`\n      + this.createTableQuery(tableName, attributes)\n      + `INSERT INTO ${quotedTableName} SELECT ${attributeNamesExport} FROM ${quotedBackupTableName};`\n      + `DROP TABLE ${quotedBackupTableName};`;\n  },\n\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return 'SAVEPOINT ' + this.quoteIdentifier(transaction.name) + ';';\n    }\n\n    return 'BEGIN ' + transaction.options.type + ' TRANSACTION;';\n  },\n\n  setAutocommitQuery() {\n    // SQLite does not support SET autocommit\n    return null;\n  },\n\n  setIsolationLevelQuery(value) {\n    switch (value) {\n      case Transaction.ISOLATION_LEVELS.REPEATABLE_READ:\n        return '-- SQLite is not able to choose the isolation level REPEATABLE READ.';\n      case Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED:\n        return 'PRAGMA read_uncommitted = ON;';\n      case Transaction.ISOLATION_LEVELS.READ_COMMITTED:\n        return 'PRAGMA read_uncommitted = OFF;';\n      case Transaction.ISOLATION_LEVELS.SERIALIZABLE:\n        return \"-- SQLite's default isolation level is SERIALIZABLE. Nothing to do.\";\n      default:\n        throw new Error('Unknown isolation level: ' + value);\n    }\n  },\n\n  replaceBooleanDefaults(sql) {\n    return sql.replace(/DEFAULT '?false'?/g, 'DEFAULT 0').replace(/DEFAULT '?true'?/g, 'DEFAULT 1');\n  },\n\n  quoteIdentifier(identifier) {\n    if (identifier === '*') return identifier;\n    return Utils.addTicks(Utils.removeTicks(identifier, '`'), '`');\n  },\n\n  /**\n   * Generates an SQL query that returns all foreign keys of a table.\n   *\n   * @param  {String} tableName  The name of the table.\n   * @return {String}            The generated sql query.\n   * @private\n   */\n  getForeignKeysQuery(tableName) {\n    return `PRAGMA foreign_key_list(${tableName})`;\n  }\n};\n\nmodule.exports = QueryGenerator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib/dialects/sqlite/query-generator.js\n// module id = 105\n// module chunks = 0","function webpackEmptyContext(req) {\n\tthrow new Error(\"Cannot find module '\" + req + \"'.\");\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 106;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/lib\n// module id = 106\n// module chunks = 0","module.exports = {\"name\":\"sequelize\",\"description\":\"Multi dialect ORM for Node.JS\",\"version\":\"4.8.2\",\"author\":\"Sascha Depold <sascha@depold.com>\",\"contributors\":[{\"name\":\"Sascha Depold\",\"email\":\"sascha@depold.com\"},{\"name\":\"Jan Aagaard Meier\",\"email\":[\"janzeh@gmail.com\",\"jmei@itu.dk\"]},{\"name\":\"Daniel Durante\",\"email\":\"me@danieldurante.com\"},{\"name\":\"Mick Hansen\",\"email\":\"mick.kasper.hansen@gmail.com\"},{\"name\":\"Sushant Dhiman\",\"email\":\"sushantdhiman@outlook.com\"}],\"repository\":{\"type\":\"git\",\"url\":\"https://github.com/sequelize/sequelize.git\"},\"bugs\":{\"url\":\"https://github.com/sequelize/sequelize/issues\"},\"dependencies\":{\"bluebird\":\"^3.4.6\",\"cls-bluebird\":\"^2.0.1\",\"debug\":\"^3.0.0\",\"depd\":\"^1.1.0\",\"dottie\":\"^2.0.0\",\"generic-pool\":\"^3.1.6\",\"inflection\":\"1.12.0\",\"lodash\":\"^4.17.1\",\"moment\":\"^2.13.0\",\"moment-timezone\":\"^0.5.4\",\"retry-as-promised\":\"^2.0.0\",\"semver\":\"^5.0.1\",\"terraformer-wkt-parser\":\"^1.1.2\",\"toposort-class\":\"^1.0.1\",\"uuid\":\"^3.0.0\",\"validator\":\"^8.0.0\",\"wkx\":\"^0.4.1\"},\"devDependencies\":{\"chai\":\"^3.5.0\",\"chai-as-promised\":\"^5.3.0\",\"chai-datetime\":\"^1.4.1\",\"chai-spies\":\"^0.7.1\",\"cheerio\":\"^1.0.0-rc.2\",\"commitizen\":\"^2.9.6\",\"continuation-local-storage\":\"^3.2.0\",\"cross-env\":\"^5.0.5\",\"cz-conventional-changelog\":\"^2.0.0\",\"env-cmd\":\"^5.1.0\",\"esdoc\":\"^0.5.2\",\"eslint\":\"^4.6.0\",\"hints\":\"^1.1.0\",\"husky\":\"^0.14.2\",\"istanbul\":\"^0.4.5\",\"lcov-result-merger\":\"^1.2.0\",\"mocha\":\"^3.0.2\",\"mysql2\":\"^1.4.1\",\"pg\":\"^6.1.0\",\"pg-hstore\":\"^2.3.2\",\"pg-native\":\"^1.10.0\",\"pg-types\":\"^1.11.0\",\"rimraf\":\"^2.5.4\",\"semantic-release\":\"^7.0.2\",\"sinon\":\"^1.17.6\",\"sinon-chai\":\"^2.13.0\",\"sqlite3\":\"^3.1.4\",\"tedious\":\"1.14.0\",\"uuid-validate\":\"^0.0.2\",\"validate-commit-msg\":\"^2.12.2\"},\"keywords\":[\"mysql\",\"sqlite\",\"postgresql\",\"postgres\",\"mssql\",\"orm\",\"nodejs\",\"object relational mapper\"],\"main\":\"index\",\"scripts\":{\"lint\":\"eslint lib test --quiet\",\"test\":\"npm run teaser && npm run test-unit && npm run test-integration\",\"test-docker\":\"npm run test-docker-unit && npm run test-docker-integration\",\"test-docker-unit\":\"env-cmd ./test/config/.docker.env npm run test-unit\",\"test-docker-integration\":\"env-cmd ./test/config/.docker.env npm run test-integration\",\"docs\":\"esdoc && cp docs/ROUTER esdoc/ROUTER\",\"teaser\":\"node -e \\\"console.log('#'.repeat(process.env.DIALECT.length + 22) + '\\\\n# Running tests for ' + process.env.DIALECT + ' #\\\\n' + '#'.repeat(process.env.DIALECT.length + 22))\\\"\",\"test-unit\":\"mocha --globals setImmediate,clearImmediate --ui tdd --check-leaks --colors -t 30000 --reporter spec \\\"test/unit/**/*.js\\\"\",\"test-unit-mysql\":\"cross-env DIALECT=mysql npm run test-unit\",\"test-unit-postgres\":\"cross-env DIALECT=postgres npm run test-unit\",\"test-unit-postgres-native\":\"cross-env DIALECT=postgres-native npm run test-unit\",\"test-unit-sqlite\":\"cross-env DIALECT=sqlite npm run test-unit\",\"test-unit-mssql\":\"cross-env DIALECT=mssql npm run test-unit\",\"test-unit-all\":\"npm run test-unit-mysql && npm run test-unit-postgres && npm run test-unit-postgres-native && npm run test-unit-mssql && npm run test-unit-sqlite\",\"test-integration\":\"mocha --globals setImmediate,clearImmediate --ui tdd --check-leaks --colors -t 30000 --reporter spec \\\"test/integration/**/*.test.js\\\"\",\"test-integration-mysql\":\"cross-env DIALECT=mysql npm run test-integration\",\"test-integration-postgres\":\"cross-env DIALECT=postgres npm run test-integration\",\"test-integration-postgres-native\":\"cross-env DIALECT=postgres-native npm run test-integration\",\"test-integration-sqlite\":\"cross-env DIALECT=sqlite npm run test-integration\",\"test-integration-mssql\":\"cross-env DIALECT=mssql npm run test-integration\",\"test-integration-all\":\"npm run test-integration-mysql && npm run test-integration-postgres && npm run test-integration-postgres-native && npm run test-integration-mssql && npm run test-integration-sqlite\",\"test-mysql\":\"cross-env DIALECT=mysql npm test\",\"test-sqlite\":\"cross-env DIALECT=sqlite npm test\",\"test-postgres\":\"cross-env DIALECT=postgres npm test\",\"test-pgsql\":\"npm run test-postgres\",\"test-postgres-native\":\"cross-env DIALECT=postgres-native npm test\",\"test-postgresn\":\"npm run test-postgres-native\",\"test-mssql\":\"cross-env DIALECT=mssql npm test\",\"test-all\":\"npm run test-mysql && npm run test-sqlite && npm run test-postgres && npm run test-postgres-native && npm run test-mssql\",\"cover\":\"rimraf coverage && npm run teaser && npm run cover-integration && npm run cover-unit && npm run merge-coverage\",\"cover-integration\":\"cross-env COVERAGE=true node_modules/.bin/istanbul cover ./node_modules/mocha/bin/_mocha --report lcovonly -- -t 60000 --ui tdd \\\"test/integration/**/*.test.js\\\" && node -e \\\"require('fs').renameSync('coverage/lcov.info', 'coverage/integration.info')\\\"\",\"cover-unit\":\"cross-env COVERAGE=true node_modules/.bin/istanbul cover ./node_modules/mocha/bin/_mocha --report lcovonly -- -t 30000 --ui tdd \\\"test/unit/**/*.test.js\\\" && node -e \\\"require('fs').renameSync('coverage/lcov.info', 'coverage/unit.info')\\\"\",\"merge-coverage\":\"lcov-result-merger \\\"coverage/*.info\\\" \\\"coverage/lcov.info\\\"\",\"sscce\":\"docker-compose run sequelize /bin/sh -c \\\"node sscce.js\\\"\",\"sscce-mysql\":\"cross-env DIALECT=mysql npm run sscce\",\"sscce-postgres\":\"cross-env DIALECT=postgres npm run sscce\",\"sscce-sqlite\":\"cross-env DIALECT=sqlite npm run sscce\",\"semantic-release\":\"./node_modules/.bin/semantic-release pre && npm publish && ./node_modules/.bin/semantic-release post\",\"commitmsg\":\"validate-commit-msg\"},\"engines\":{\"node\":\">=4.0.0\"},\"license\":\"MIT\",\"config\":{\"commitizen\":{\"path\":\"./node_modules/cz-conventional-changelog\"}}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/Sequelize/package.json\n// module id = 107\n// module chunks = 0","require('dotenv').config();\n\nlet {\n  DATABASE_DIALECT = 'mysql',\n  DATABASE_STORAGE = './db.sqlite',\n  DATABASE_HOST = '127.0.0.1',\n  DATABASE_PORT = 3306,\n  DATABASE_NAME = 'piper',\n  DATABASE_USER,\n  DATABASE_PASSWORD,\n  DATABASE_URL\n} = process.env;\n\nlet base = {\n  \"username\": DATABASE_USER,\n  \"password\": DATABASE_PASSWORD,\n  \"database\": DATABASE_NAME,\n  \"host\": DATABASE_HOST,\n  \"port\": DATABASE_PORT,\n  \"dialect\": DATABASE_DIALECT,\n  \"storage\": DATABASE_STORAGE,\n  \"url\": DATABASE_URL\n};\n\nexport default {\n  \"development\": base,\n  \"test\": base,\n  \"production\": base\n}\n\n\n\n// WEBPACK FOOTER //\n// ./server/models/db.js","/* jshint indent: 2 */\n\nexport default function(sequelize, DataTypes) {\n  let changelog = sequelize.define('changelog', {\n    id: {\n      type: DataTypes.INTEGER(11),\n      allowNull: false,\n      primaryKey: true,\n      autoIncrement: true\n    },\n    action: {\n      type: DataTypes.INTEGER(4),\n      allowNull: false,\n      defaultValue: '0'\n    },\n    page_id: {\n      type: DataTypes.INTEGER(11),\n      allowNull: false\n    },\n    items: {\n      type: DataTypes.STRING(10240),\n      allowNull: true,\n      defaultValue: ''\n    },\n    create_by: {\n      type: DataTypes.INTEGER(11),\n      allowNull: false,\n      defaultValue: '0'\n    }\n  }, {\n    tableName: 'changelog'\n  });\n\n  changelog.associate = function(models) {\n    changelog.belongsTo(models.pages, {foreignKey: 'page_id'});\n    changelog.belongsTo(models.users, {foreignKey: 'create_by'});\n  }\n\n  return changelog;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./server/models/changelog.js","/* jshint indent: 2 */\n\nexport default function(sequelize, DataTypes) {\n  let pages = sequelize.define('pages', {\n    id: {\n      type: DataTypes.INTEGER(11),\n      allowNull: false,\n      primaryKey: true,\n      autoIncrement: true\n    },\n    title: {\n      type: DataTypes.STRING(64),\n      allowNull: false\n    },\n    cover: {\n      type: DataTypes.STRING(64),\n      allowNull: true,\n      defaultValue: ''\n    },\n    config: {\n      type: DataTypes.STRING(512),\n      allowNull: false,\n      defaultValue: ''\n    },\n    items: {\n      type: DataTypes.STRING(10240),\n      allowNull: false\n    },\n    create_by: {\n      type: DataTypes.INTEGER(11),\n      allowNull: false,\n      defaultValue: '0'\n    },\n    is_publish: {\n      type: DataTypes.INTEGER(4),\n      allowNull: false,\n      defaultValue: '0'\n    },\n    is_delete: {\n      type: DataTypes.INTEGER(4),\n      allowNull: false,\n      defaultValue: '0'\n    },\n    publish_at: {\n      type: DataTypes.DATE,\n      allowNull: true,\n      defaultValue: sequelize.NOW\n    }\n  }, {\n    tableName: 'pages'\n  });\n\n  pages.associate = function(models) {\n    pages.hasOne(models.changelog, {foreignKey: 'page_id'});\n    pages.belongsTo(models.users, {foreignKey: 'create_by'});\n  }\n\n  return pages;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./server/models/pages.js","/* jshint indent: 2 */\n\nexport default function(sequelize, DataTypes) {\n  let users = sequelize.define('users', {\n    id: {\n      type: DataTypes.INTEGER(11),\n      allowNull: false,\n      primaryKey: true,\n      autoIncrement: true\n    },\n    name: {\n      type: DataTypes.STRING(64),\n      allowNull: false\n    },\n    email: {\n      type: DataTypes.STRING(64),\n      allowNull: false\n    },\n    github_id: {\n      type: DataTypes.INTEGER(11),\n      allowNull: false,\n      defaultValue: '0'\n    },\n    avatar: {\n      type: DataTypes.STRING(64),\n      allowNull: true,\n      defaultValue: '',\n    }\n  }, {\n    tableName: 'users'\n  });\n\n  users.associate = function(models) {\n    users.hasOne(models.changelog, {foreignKey: 'create_by'});\n    users.hasOne(models.pages, {foreignKey: 'create_by'});\n  }\n\n  return users;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./server/models/users.js","import models from '../models'\n\nexport default class {\n  constructor() {\n    this.url = '/count';\n  }\n\n  async get(ctx) {\n    let [result] = await models.pages.findAll({\n      attributes: [\n        [models.sequelize.fn('COUNT', models.sequelize.literal('CASE WHEN is_publish = 0 THEN 1 ELSE NULL END')), 'working'],\n        [models.sequelize.fn('COUNT', models.sequelize.literal('CASE WHEN is_publish = 1 THEN 1 ELSE NULL END')), 'published']\n      ],\n      where: {\n        is_delete: 0\n      }\n    })\n\n    ctx.body = result;\n  }\n\n};\n\n\n\n// WEBPACK FOOTER //\n// ./server/controllers/count.js","import asyncBusboy from 'async-busboy'\nimport upload from '../lib/publish'\n\nexport default class {\n  constructor() {\n    this.url = '/files';\n  }\n\n  async post(ctx) {\n    const {files, fields} = await asyncBusboy(ctx.req);\n\n    let uploadRes = await upload(files);\n\n    ctx.body = uploadRes\n  }\n\n};\n\n\n\n// WEBPACK FOOTER //\n// ./server/controllers/files.js","module.exports = require(\"async-busboy\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"async-busboy\"\n// module id = 114\n// module chunks = 0","require('dotenv').config();\nconst _ = require('lodash')\nconst qiniu = require('qiniu')\n\nlet {\n  QINIU_ACCESS_KEY,\n  QINIU_SECRET_KEY,\n  QINIU_BUCKET,\n  QINIU_BASEURL\n} = process.env;\n\nqiniu.conf.ACCESS_KEY = QINIU_ACCESS_KEY;\nqiniu.conf.SECRET_KEY = QINIU_SECRET_KEY;\n\nconst getUptoken = (key) => {\n  if (_.isEmpty(key)) return\n\n  const putPolicy = new qiniu.rs.PutPolicy(`${QINIU_BUCKET}:${key}`)\n  return putPolicy.token()\n}\n\nconst upload = (uptoken, localFile) => {\n\n  if (_.isEmpty(uptoken)) return\n\n  const extra = new qiniu.io.PutExtra()\n\n  return new Promise((resolve, reject) => {\n    qiniu.io.putFile(uptoken, localFile, localFile, extra, (err, ret) => {\n      if (!err) {\n        resolve({\n          hash: ret.hash,\n          key: ret.key,\n          url: `${QINIU_BASEURL}/${ret.key}`\n        })\n      } else {\n        console.log(\"upload error\", err, localFile)\n        reject(err)\n      }\n    })\n  })\n}\n\nexport default async (files) => {\n\n  if (\n    QINIU_ACCESS_KEY === 'YOUR QINIU AK' ||\n    QINIU_SECRET_KEY === 'YOUR QINIU SK' ||\n    QINIU_BUCKET === 'YOUR QINIU BUCKET' ||\n    QINIU_BASEURL === 'YOUR QINIU URL'\n    ) {\n    throw { status: 404, name: 'UPLOAD_ERROR_CONFIG', message: '请在 process.env 里配置 qiniu 上传相关的配置: QINIU_ACCESS_KEY/QINIU_SECRET_KEY/QINIU_BUCKET/QINIU_BASEURL' };\n  }\n\n  let tasks = files.map((file, key) => upload(getUptoken(file.path), file.path));\n\n  return await Promise.all(tasks);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./server/lib/publish/qiniu.js","module.exports = require(\"qiniu\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"qiniu\"\n// module id = 116\n// module chunks = 0","import __ from '../constants'\nimport models from '../models'\n\nexport default class {\n  constructor() {\n    this.url = '/pages';\n  }\n\n  async get(ctx) {\n    let { page, size, title, isPublish } = ctx.query;\n    page = parseInt(page, 10)\n    size = parseInt(size, 10)\n    let start = (page - 1) * size;\n    let limit = size;\n    let where = {\n      is_delete: 0\n    };\n    if (title) {\n      where['title'] = {\n        $like: `%${title}%`\n      }\n    }\n    if (isPublish != -1) {\n      where['is_publish'] = isPublish\n    }\n    let result = await models.pages.findAndCountAll({\n      include: [\n        {\n          model: models.users,\n          attributes: ['name']\n        }\n      ],\n      offset: start,\n      limit: limit,\n      where: where,\n      order: [['create_at', 'DESC']]\n    });\n\n    ctx.body = {\n      total: result.count,\n      page: page,\n      size: size,\n      data: result.rows\n    };\n  }\n\n  async put(ctx) {\n    let { title = '', config = '', items = '' } = ctx.request.body;\n    title = title.trim();\n    if (!title) throw { status: 400, name: 'ERROR_PARAMS', message: 'Title 不能为空' };\n    items = JSON.stringify(items);\n    if (items.length > __.VALUE_MAX_LENGTH) throw __.VALUE_TOO_LONG;\n    config = JSON.stringify(config);\n\n    let [page, created] = await models.pages.findOrCreate({\n      where: {\n        is_delete: 0,\n        title: title\n      },\n      defaults: {\n        title: title,\n        config: config,\n        items: items,\n        create_by: ctx.state.user.id\n      }\n    });\n\n    if (page && !created) {\n      throw { status: 400, name: 'DUP', message: '记录已存在' };\n    }\n\n    await models.changelog.create({\n      action: 1,\n      page_id: page.id,\n      items: items,\n      create_by: ctx.state.user.id\n    })\n\n    ctx.body = {\n      message: 'Save success',\n      item: page\n    };\n  }\n\n};\n\n\n\n// WEBPACK FOOTER //\n// ./server/controllers/pages.js","import pageApi from './page'\nimport models from '../models'\nimport path from 'path'\nimport fs from 'fs'\nimport mkdirp from 'mkdirp'\nimport upload from '../lib/publish'\nimport webshot from 'webshot'\n\nconst protocol = 'http://'\n\nexport default class {\n  constructor() {\n    this.url = '/publish/:id';\n  }\n\n  async put(ctx) {\n    // save data first\n    await new pageApi().put(ctx)\n\n    let { id } = ctx.params;\n\n    let [page] = await models.pages.findAll({\n      where: {\n        is_delete: 0,\n        id: id\n      }\n    });\n\n    if (!page) throw { status: 404, name: 'PAGES_NOT_FOUND', message: 'page is not found' };\n\n    await models.pages.update({\n      is_publish: 1,\n      publish_at: Date.now()\n    }, {\n      where: {\n        id: id\n      }\n    })\n\n    await models.changelog.create({\n      action: 4,\n      page_id: id,\n      items: null,\n      create_by: ctx.state.user.id\n    });\n\n    const dir = `public/${id}`;\n\n    if (!fs.existsSync(dir)) {\n\n      mkdirp(dir, function (err) {\n        if (err) {\n          console.error(err)\n        }\n      });\n    }\n\n    try {\n      page.config = JSON.parse(page.config);\n      page.items = JSON.parse(page.items);\n    } catch(error) {\n      throw { status: 500, name: 'JSON_PARSE_ERROR', message: 'json parse error' }\n    };\n\n    let shotUrl = `http://127.0.0.1:3000/view/${id}`\n    \n    var options = {\n      screenSize: {\n        width: 375\n      , height: 375\n      }\n    , shotSize: {\n        width: 375\n      , height: 'all'\n      }\n    , userAgent: 'Mozilla/5.0 (iPhone; U; CPU iPhone OS 3_2 like Mac OS X; en-us)'\n        + ' AppleWebKit/531.21.20 (KHTML, like Gecko) Mobile/7B298g'\n    };\n\n    webshot(shotUrl, `${dir}/cover.png`, options, function(err) {\n      if(err) {\n        throw { status: 404, name: 'WEBSHOT_ERR', message: 'webshot failed' };\n      }\n\n      upload([fs.createReadStream(`${dir}/cover.png`)]).then((coverRes) => {\n        models.pages.update({\n          cover: protocol + coverRes[0].url\n        }, {\n          where: {\n            id: id\n          }\n        })\n      })\n    });\n\n    ctx.body = {\n      url: shotUrl\n    }\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./server/controllers/publish.js","module.exports = require(\"mkdirp\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"mkdirp\"\n// module id = 119\n// module chunks = 0","module.exports = require(\"webshot\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"webshot\"\n// module id = 120\n// module chunks = 0","import models from '../models'\n\nexport default class {\n  constructor() {\n    this.url = '/users';\n  }\n\n  async get(ctx) {\n    let users = await models.users.findAll();\n    ctx.body = users;\n  }\n\n};\n\n\n\n// WEBPACK FOOTER //\n// ./server/controllers/users.js","module.exports = require(\"koa-session\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"koa-session\"\n// module id = 122\n// module chunks = 0","module.exports = require(\"koa-bodyparser\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"koa-bodyparser\"\n// module id = 123\n// module chunks = 0","require('dotenv').config()\nconst passport = require('koa-passport')\nimport models from '../models'\n\npassport.serializeUser(function(user, done) {\n  done(null, user.id)\n})\n\npassport.deserializeUser(async function(id, done) {\n  try {\n    const user = await models.users.findById(id)\n    done(null, user)\n  } catch(err) {\n    done(err)\n  }\n})\n\nconst GitHubStrategy = require('passport-github').Strategy;\npassport.use(new GitHubStrategy({\n    clientID: process.env.GITHUB_CLIENT_ID,\n    clientSecret: process.env.GITHUB_CLIENT_SECRET,\n    callbackURL: process.env.GITHUB_CLIENT_CALLBACK_URL\n  },\n  function(accessToken, refreshToken, profile, cb) {\n    let {\n      name,\n      email,\n      id,\n      avatar_url\n    } = profile._json;\n    models.users.findOrCreate({where: {github_id: id}, defaults: {\n      name: name,\n      email: email,\n      avatar: avatar_url\n    }}).spread((user, created) => cb(null, user)).catch(err => {\n      console.log(err)\n    })\n  }\n));\n\n\n\n// WEBPACK FOOTER //\n// ./server/lib/passport.js","module.exports = require(\"passport-github\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"passport-github\"\n// module id = 125\n// module chunks = 0","const path = require('path')\n\nmodule.exports = {\n  srcDir: 'client/',\n  /*\n  ** Router config\n  */\n  router: {\n    middleware: [\n      'check-auth'\n    ]\n  },\n  /*\n  ** Headers of the page\n  */\n  head: {\n    title: 'Piper',\n    meta: [\n      { charset: 'utf-8' },\n      { hid: 'viewport', name: 'viewport', content: 'width=device-width, initial-scale=1' },\n      { hid: 'description', name: 'description', content: 'A drag-and-drop mobile website builder base on Vue.' }\n    ],\n    link: [\n      { rel: 'icon', type: 'image/x-icon', href: '/favicon.ico' }\n    ]\n  },\n  /*\n  ** Global CSS\n  */\n  css: [\n    '@/assets/main.css'\n  ],\n  /*\n  ** Customize the progress-bar color\n  */\n  loading: { color: '#3B8070' },\n  /*\n  ** Build\n  */\n  build: {\n    vendor: [\n      'axios',\n      'element-ui',\n      'interactjs',\n      'lodash',\n      'qr.js',\n      'feather-icons'\n    ]\n  },\n  plugins: [\n    '@/plugins/filters.js',\n    '@/plugins/element-ui.js',\n    '@/plugins/axios-defaults'\n  ]\n}\n\n\n\n// WEBPACK FOOTER //\n// ./nuxt.config.js"],"sourceRoot":""}